<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous">
    </script>

    <!-- 웹 폰트 설정 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- Font Awesome 설정 -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- custom.css -->
    <link rel="stylesheet" href="/assets/built/custom.css">

    <!-- syntax.css -->
    <link rel="stylesheet" href="/assets/built/syntax.css">

    <!-- gist.css -->
    <link rel="stylesheet" href="/assets/built/better-gist-styles.css">

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Development & Technical Training" />
    <link rel="shortcut icon" href="https://moon9342.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://moon9342.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="IT Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Development & Technical Training" />
    <meta property="og:url" content="https://moon9342.github.io/search" />
    <meta property="og:image" content="https://moon9342.github.io/assets/built/images/blog-cover.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Development & Technical Training" />
    <meta name="twitter:url" content="https://moon9342.github.io/" />
    <meta name="twitter:image" content="https://moon9342.github.io/assets/built/images/blog-cover.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="IT Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "IT Blog",
        "logo": "https://moon9342.github.io/"
    },
    "url": "https://moon9342.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://moon9342.github.io/assets/built/images/blog-cover.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://moon9342.github.io/search"
    },
    "description": "Development & Technical Training"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <!-- 사용자 browser 확인 코드 - Chrome이 아니면 경고 메시지 출력 -->

    <script>
        var agent = navigator.userAgent.toLowerCase();
        var _iPhone = false;
        var _chrome = false;
        var result = false;
        if (agent.indexOf("iphone") != -1) {
            _iPhone = true;
        }
        if (agent.indexOf("chrome") != -1) {
            _chrome = true;
        }

        if( _iPhone || _chrome ) {
            result = true;
        }

        if( !result ) {
            alert("이 블로그는 Google Chrome Browser에 최적화 되어 있습니다 !!");
        }

    </script>

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://moon9342.github.io">IT Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-back-end" role="menuitem"><a href="/tag/back-end/">Back End</a></li>
    <li class="nav-front-end" role="menuitem"><a href="/tag/front-end/">Front End</a></li>
    <li class="nav-miscellaneous-article" role="menuitem"><a href="/tag/miscellaneous-article/">Miscellaneous Article</a></li>
    <li class="nav-archive" role="menuitem"><a href="/archive.html">Archive</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>

    window.store = {
    
    "mysql-5-7-archive-setting": {
        "title": "MySQL 5.7.2 Windows용 ZIP Archive 설치",
            "author": "database",
            "category": "",
            "content": "IntroductionMySQL을 install하지 않고 ZIP Archive를 다운받고 압축 풀어서 사용하는 사용하는 방식에 대한 설명입니다. 기존 5.6버전은 JSON에 대한 지원이 되지 않기 때문에 5.7버전을 대상으로 진행합니다. MySQL 5.7.2 ZIP Archive DownloadMySQL을 다운로드 받기 위해 링크를 눌러 이동합니다.아래의 그림처럼 다운로드 링크가 보이게 되는데 이 중 Windows (x86, 64-bit), ZIP Archive으로 되어있는 것을 찾아 다운로드 링크를 눌러 다운로드를 받습니다. 링크를 누르면 로그인하거나 회원가입하라는 화면이 나오는데 화면 하단에 보면그냥 다운로드 할 수 있는 링크가 있습니다.다운로드가 끝나면 적절한 위치에 압축을 풀어줍니다. 저는 D:/[Tools]/mysql 이라는 폴더로 압축된 내용을 풀었습니다. 해당 폴더 하단에 보면 기본적으로 다음과 같은 폴더와 파일들이 보이게 됩니다. MySQL System Database 생성ZIP Archive 버전은 MySQL을 기동하기 위한 System Database가 제공되지 않기 때문에 기본 System Database부터 생성해야 합니다.먼저 mysql 폴더 하단에 data라는 폴더를 생성합니다.그런 다음 관리자 권한으로 command 창을 열고 다음의 명령을 실행합니다. 명령을 실행시키는 폴더는 mysql하단의 bin folder에서 실행합니다.mysqld --initialize약간의 시간이 지나면 data 폴더 하단에 필요한 파일들이 생성됩니다. root 계정 패스워드 변경root계정의 패스워드를 변경하는 부분입니다. 꼭 필요한건 아니지만 현재 root계정은 패스워드 없이 바로 사용할 수 있기 때문에 보안상 설정하는게 좋습니다.다음과 같이 mysqld 명령을 이용해 MySQL 서버를 기동시킵니다.mysqld --console --explicit_defaults_for_timestamp --skip-grant-tables정상적으로 MySQL 서버가 기동되면 다음과 같은 화면을 보실 수 있습니다.이제 별도의 command창을 열고 다음의 명령을 입력해서 MySQL console에 진입합니다. 정상적으로 수행되면 mysql&gt; 프롬프트가떨어지게 됩니다.mysql -u root mysql이제 다음의 SQL문을 이용해서 root 계정의 패스워드를 갱신합니다. 패스워드를 root1234로 변경한다면 다음과 같이 하시면 됩니다.update USER set authentication_string=password('root1234') where user='root';변경이 정상적으로 수행되었으면 다음의 구문을 실행합니다.flush privileges;이제 마지막으로 다음과 같은 구문을 실행합니다.alter user 'root'@'localhost' identified by 'root1234', 'root'@'localhost' password expire never;이제 exit를 입력해 MySQL console을 빠져나옵니다. 그런다음 다음의 명령을 실행하면 root 계정의 패스워드를 입력하라고 합니다. 아까 설정한 root1234를 입력하면 MySQL console에 정상적으로 진입할 수 있습니다.mysql -u root -p MySQL 서버 중지현재 동작중인 MySQL 서버를 중지시킬려면 command 창에서 다음과 같은 명령을 실행시키시면 됩니다.mysqladmin -u root -p shutdown성공적으로 수행되면 실행되고 있던 MySQL 서버의 실행이 중지됩니다. 새로운 사용자 생성 및 권한 부여이전까지 정상적으로 수행되었다면 현재 MySQL 서버는 기동이 중지되어 있을겁니다.초기화 작업이 이미 진행되었기 때문에 이제 MySQL 서버를 기동시키기 위해서 다음과 같이 실행하시면 됩니다.mysqld새로운 사용자 계정을 생성하기 위해 새로운 command 창을 열어서 root계정으로 MySQL console에 진입합니다.mysql -u root -p새로운 사용자를 생성합니다. 아이디는 java, 패스워드 java로 설정해서 생성하도록 하겠습니다. 아래의 두 문장을 실행합니다.create user java identified by 'java';create user java@localhost identified by 'java';이제 데이터가 입력될 새로운 데이터베이스를 하나 생성 합니다. 다음의 명령을 이용해 library라는 이름의 데이터베이스를생성하겠습니다.create database library;새로 생성된 library database에 대한 모든 권한을 조금 전에 추가한 java 계정에게 부여하려면 다음과 같이 하시면 됩니다.grant all privileges on library.* to java;grant all privileges on library.* to java@localhost; SQL Script 파일을 이용해 Database 구축만일 기존에 사용하던 Database에 대한 SQL Script 파일을 가지고 있다면 해당 파일을 이용해 간단하게 데이터베이스를구축할 수 있습니다.command 창을 열어서 다음과 같은 명령어로 Script를 실행시켜 데이터베이스를 구축할 수 있습니다.mysql -u java -p library &lt; SQL_Script_File.sqlEnd.",
        "url": "/mysql-5.7-archive-setting"
    }
    ,
    
    "jekyll-regenerate-speed-up": {
        "title": "Jekyll 기반의 GitHub Page 생성(9)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Site Regeneration 속도 올리기블로그에 포스트개수가 많아지고 기능이 추가될수록 Jekyll의 site generation 속도가 현저하게 떨어지게 됩니다. 어쩔 수 없는일이긴 합니다. 포스트가 1,000개 정도 되면 컴퓨터 사양에 따라 많이 다르겠지만 약 1분 가량의 시간이 걸리게 된답니다.처음에야 포스트가 얼마 없다보니 금방 site가 생성되지만 말이죠.일반적으로 우리가 새로운 포스트를 쓸 때 로컬에서 watch mode를 이용해서 파일이 변경되면 다시 site를 regeneration하도록 설정하고사용합니다. 그래야 변경된 내용을 빠르게 확인할 수 있기 때문이지요.하지만 우리가 포스트의 내용을 변경해서 저장할 때 마다 가지고 있는 모든 폴더에 있는 파일을 검색하고 generation하는 건 비효율적입니다. site regeneration 시간이 너무 오래걸려서 내가 수정한 혹은 작성한 내용을 확인하기 위해 많이 기다려야 하는 것이지요. 추후에 블로그에 글 내용이 많아지신다면 무슨 말인지 충분히 공감하실 겁니다.이 문제를 해결하기 위해 간단한 설정하나를 추가해 보도록 하겠습니다.지금까지 우리는 site를 생성하고 로컬 웹서버를 이용해 실행시키기 위해 다음과 같이 명령을 실행시켰습니다.  bundle exec jekyll serve이제 저 명령 뒤에 option을 하나 주시면 됩니다. --limit_posts 라는 option은데 뒤쪽에 숫자 인자가 들어옵니다. 예를 들어 다음과 같이 실행시키면  bundle exec jekyll serve --limit_posts 1시간상으로 마지막으로 등록된 포스트 1개만 가지고 site를 regeneration시키게 됩니다. 물론 기존의 내용은 컴파일 되지 않기때문에사이트에 나타나지는 않겠지만 현재 작업하고 있는 포스트에 대한 내용은 빠르게 확인이 가능합니다. 이렇게 작업하고 최종적으로는site 전체를 다시 build해 주시면 될 듯 합니다.End.",
        "url": "/jekyll-regenerate-speed-up"
    }
    ,
    
    "git-github": {
        "title": "Git과 GitHub의 간단 사용법",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionGit과 GitHub에 대한 간단한 설명입니다. 간단한 이론과 함께 실습을 통해 command 기반의 명령어로 어떤일을 처리할 수 있는지를 알아보도록 하겠습니다. 누구나 한번쯤은 겪었던 일위의 그림은 누구나 한번쯤 겪어봤을 만한 상황입니다. 파일을 계속 수정해 나가면서 이름을 바꾸어 저장하는 경우입니다.그 당시야 최종 파일이 어떤것인지 알 수 있겠지만 시간이 흐르면 당연히 저 중 어떤 파일이 최종 Report파일인지 알 수없게 됩니다.아래의 그림은 조금 다른 경우입니다.( 이미지 출처 : http://slidedeck.io/cursor-education )여러명이 공동으로 같은 파일을 작업할 때 파일 내용을 덮어쓰는 문제가 생길 수 있습니다. 다른 사람이 작업한 사항을유실할 수 있다는 것이죠.이와 같은 문제가 항시 빈번하게 발생하게되고 이를 해결하기 위해 나온 시스템이 바로 VCS( Version Control System )입니다. Version Control System ( VCS )VCS 는 파일의 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템을 의미합니다. 이런 VCS는다음과 같은 특징을 가지고 있습니다.  각 파일을 이전 상태로 되돌릴 수 있습니다.  시간에 따라 수정 내용을 비교해 볼 수 있습니다.  누가 문제를 일으켰는지 쉽게 추적할 수 있습니다.  파일을 잘못 고쳤을 때 쉽게 복구할 수 있습니다. Centralized Version Control System ( CVCS )CVCS는 중앙집중식 버전 관리 시스템입니다. 우리가 예전에 사용했던 CVS나 Subversion같은 제품이 이 범주에 들어갑니다.파일을 관리하는 서버가 별도록 존재하고 클라이언트는 중앙 서버에서 파일을 받아서 사용하는 개념입니다. 그림으로표현하면 다음과 같습니다.( 이미지 출처 : https://git-scm.com/ )여기서 Checkout이라는 용어가 나오는데 나중에 우리가 살펴볼 Git의 Checkout과는 다른 개념임에 유의하셔야 합니다.이런 CVCS는 중앙서버에 문제가 발생하면 다른 사람과의 협업 자체가 불가능해지게 됩니다. 또한 중앙서버의 하드디스크에문제가 발생하면 프로젝트의 모든 History를 잃어버리게 됩니다.Backup서버를 운영하면 이런 문제점을 일시 해결할 순 있지만 본질적인 문제는 남아있게 됩니다. ( 백업서버까지 날라간다면??? )이런 문제점을 해결하기 위해 분산형 VCS가 등장하게 됩니다. Distributed Version Control System ( DVCS )DVCS는 분산 버전 관리 시스템입니다. 우리가 알고 있는 Git이 대표적 제품입니다. 이 외에 다른 제품들도 있지만Git만 알아도 됩니다.이 방식은 CVCS처럼 클라이언트가 파일의 마지막 Snapshot을 Checkout하는 방식이 아닙니다. 클라이언트는 서버 저장소를통째로 로컬에 복제해서 사용합니다. 즉, 그림으로 보면 다음과 같습니다.( 이미지 출처 : https://git-scm.com/ ) Git의 탄생Linux kernel은 대규모의 open source project입니다. 이 project의 버전관리를 위해 초기에는BitKeeper라는 상용 DVCS를 사용했었는데 2005년도에 이 BitKeeper의 무료사용이 제고되면서 리누스 토발즈의 주도로Linux 개발 커뮤니티가 자체 VCS를 개발했는데 이게 바로 Git입니다.Git은 다음과 같은 특징을 가집니다.  단순한 구조에서 오는 빠른 속도  완벽한 분산처리  branch를 사용한 비선형적 개발 가능  속도나 크기면에서 대형 Project에 적합Git의 데이터 저장 방식은 이 포스트의 범주를 넘어가니 그 부분은 제외하겠습니다. 실제 Git이 어떤 방식으로 데이터를 저장하는가에대한 내용은 여기를 클릭해 살펴보시면 될 듯 합니다. Git의 기본Git은 파일을 3가지 상태로 관리합니다. Committed, Modified, Staged라고 불리는 3가지 상태로 파일을 관리하게 되는데각각의 의미는 다음과 같습니다.  Git의 파일 상태      Committed : 파일을 수정한 후 해당 파일에 대해 commit명령을 실행해 파일을 로컬 데이터베이스(로컬 Repository)에 안전하게 저장한 상태를 의미합니다.    Modified : 파일을 수정한 후 아직 로컬 데이터베이스에 commit하지 않은 상태를 의미합니다.    Staged : 파일을 수정한 후 수정할 파일을 곧 commit할 것이라고 표시한 상태를 의미합니다.  Git은 파일상태 관리와 더불어 3가지 영역을 사용합니다.  Git의 사용 영역      Git directory : Git이 project의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미합니다.다른말로 Local Repository라고 하며 만약 특정 폴더를 Git directory(Local Repository)로 설정하려면 git init명령을이용하면 됩니다. Repository로 설정되면 .git이라는 숨김폴더가 생성되고 이 안에 Git 관리 정보들이 생성되게 됩니다.    Working directory : project의 특정 branch를 checkout한 내용이 들어있는 폴더입니다.    Staging Area : Git directory에 존재하며 단순한 파일입니다. 곧 commit할 파일에 대한 정보를 가지고 있게 됩니다.   Git으로 하는 작업의 기본 순서작업의 기본순서는 다음과 같습니다.  Working directory에서 파일 수정  Staging Area에 수정한 파일을 Stage해서 commit할 Snapshot 생성 ( git add )  Staging Area에 있는 수정된 파일을 commit해서 Git directory에 영구적인 Snapshot으로 저장 ( git commit )( 이미지 출처 : https://git-scm.com/ )( 이미지 출처 : http://egloos.zum.com/incredible/v/7278471 ) Git 설치 &amp; 기본 설정http://git-scm.com를 클릭해서 Git Official HomePage로 이동해서 Git을다운로드 한 후 기본설정으로 install하시면 됩니다.Git을 설치하신 후 git config를 이용해 기본적인 환경설정을 하시면 됩니다. 설정파일은 크게 3가지 종류가 존재하는데 다음과 같습니다.  Git의 환경설정파일( Windows system 기준 )      $GIT_HOME/mingw64/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정으로git config --system으로 설정합니다.    $USER_HOME/.gitconfig : 특정 사용자에게만 적용되는 설정입니다. git config --global으로 설정합니다.    .git/config : Git directory안에 위치하며 특정 저장소에만 적용되는 설정입니다.  각각의 설정파일은 위에 나열된 순서의 역순으로 적용된다는 것도 같이 기억해 두셔야 합니다.Windows system에서 Git을 설치하면 Git Bash 메뉴가 생성되는데 이를 실행해 console을 실행시킨 후 사용자 이름과Email주소를 설정하시면 됩니다.  참고로 MINGW64는 Windows system으로 porting한 GNU 소프트웨어 도구 모음입니다. Git Local Repository 생성그럼 Git을 이용해 Git Repository를 만들어서 사용해 보도록 하겠습니다. 가지고 있는 project가 없기 때문에 간단하게폴더를 하나 생성하고 그 폴더를 project 폴더로 간주하고 진행하겠습니다.Git의 기본 명령과 개념을 이해하는 목적이기 때문에 command 창에서 명령어를 이용해서 작업을 진행하겠습니다.추후에 실제 project에 적용하실 때는 IDE의 기능을 이용하거나 SourceTree와같은 GUI툴을 이용하시는게 좋습니다.다음과 같은 순서로 진행합니다.  윈도우 탐색기를 이용해 먼저 프로젝트 폴더를 생성합니다. D:/MyProject로 생성합니다. 나중에 Git으로 관리할파일을 하나 생성합니다. 다음과 같은 내용을 가지고 있는 파일을 생성하고 파일 이름은 readme.txt로 저장합니다.    This is a sample text.        project 폴더로 이동해 console을 통해 git init을 실행해 Git Repository를 생성합니다. 다음과 같은 메시지가 출력되는걸확인하실 수 있습니다.    Initialized empty Git repository in D:/MyProject/.git/            메시지에서 나온것 처럼 .git 폴더가 생성되고 그 안에 Git Repository가 생성됩니다. 또한 Repository에필요한 각종 Skeleton들도 같이 생성됩니다.        이 상태에서 git status를 실행합니다. 그러면 Git이 아직 추적하고 있지 않은 readme.txt가 존재한다고 알려줍니다.        Git Repository를 생성했지만 아직 어떠한 파일도 관리를 하고 있지 않습니다. 이제 Git이 파일을 관리하게하려면 Repository에 git add를 이용해 파일을 추가하고 git commit을 이용해 commit까지 진행해야 합니다.다음의 그림처럼 명령을 이용하여 Repository에 파일 추가, 확인, commit까지 진행합니다. ( -m option은 commit message를 작성하기 위해서사용합니다. )    이제 마지막으로 readme.txt 파일의 내용을 에디터를 이용해 적당히 수정한 후에 다시 git status를 실행시켜 보시면 됩니다. 그럼 Git은 해당 파일이 변경(Modified)됬다는 것을 인식해서 보여주게 됩니다. 변경된 내용을 적용해 Repository에 저장하려면 다시 git add를 이용해 해당 파일을 staging 한 후 git commit을 실행해야 합니다. Branch 생성그 다음에 알아볼 내용은 branch 입니다. branch는 기본 project에 영향이 가지 않는 상태에서 새로운 기능을 추가하거나기존 기능을 변경해야 하는 경우에 유용하게 사용할 수 있습니다. 필요에 의해 만들어지는 이런 각각의 branch들은 서로간의 영향을 받지 않습니다. 그렇기 때문에 여러 작업을 동시에 진행시킬 수 있습니다.( 이미지 출처 : https://rogerdudler.github.io/git-guide/index.ko.html )Repository를 처음 생성하게 되면 Git는 master라는 이름의 branch를 만들어 줍니다. 위에서 우리가 readme.txt 파일을Repository에 추가하고 내용을 변경해서 commit까지 진행했었는데 모두 이 master라는 branch에서 처리했던 겁니다.master가 아닌 다른 branch를 생성할 수 있습니다. 또한 “이제부터의 작업은 xxx branch에서 진행할꺼야!” 라는 식으로명령을 줄 수 있는데 이걸 checkout이라고 합니다. 즉, checkout은 특정 branch의 내용을 가져와서 Working directory를 설정하는 작업이라고 보시면 됩니다. 특정 branch에서 일어나지 않는 모든 작업은 당연히 master branch에서 일어나게 됩니다.현재 어떤 branch가 존재하는지 알아볼려면 git branch 명령을 이용하시면 됩니다. 만약 새로운 branch를 생성하고 싶으면 git branch branch_name형태로 branch이름을 명시하시면 새로운 branch가 생성됩니다.현재 작업중인 branch는 * 기호로 표시됩니다. 아래 그림은 새로운 branch를 생성하고 git checkout 명령을 이용하여 hotfixbranch를 Working directory에 가져온 것입니다. 지금부터 하는 작업은 모두 hotfix branch에서 발생하는 것이고 master branch와는무관하게 동작합니다.실제로 파일을 변경하거나 추가해서 hotfix branch에서 작업한 후 다시 master branch를 checkout해보시면 아까 했던 작업이 masterbranch에는 영향을 미치지 않는다는 것을 확인하실 수 있습니다. 이 부분은 개별적으로 실습해 보시길 바랍니다.참고로 모든 branch를 확인하기 위해서는 다음의 명령을 실행하시면 됩니다.  git branch -a Branch MergeMerge 작업은 현재 작업중인 branch에 다른 branch를 가져와서 병합하는 작업을 의미합니다. git merge branch_name을 이용하여현재 branch에 명시된 이름의 branch를 가져와 파일을 병합하게 됩니다.만약 두개의 branch에서 같은 파일의 같은 곳을 수정했을 경우 해당 파일을 병합할 때 당연히 문제가 발생하게 됩니다. 그냥 합쳐질 수가없기 때문이지요. conflict가 발생했다고 표현합니다. 이런 경우 충돌이 일어난 내용을 살펴보고 수동으로 해결해야 합니다.  Git은 병합이 실패했을 때 그 해결을 모두 사용자에게 일임합니다.그래서 수동으로 파일을 수정한 후 다시 commit작업을 진행해야 합니다. merge 작업은 Remote Repository 를 설명하는 부분에서 다시 한번 다뤄보기로 하겠습니다. .gitignore 파일project 폴더 안에서 굳이 추적할 필요가 없는 파일들도 존재합니다. 입출력 데이터파일이나 로그파일, 혹은 .class와 같은 파일들은굳이 Git을 이용해서 관리할 필요가 없습니다. 즉, 임시로 사용되거나 결과물로 생성되는 파일들이 이 범주에 들어갑니다.이런경우 .gitignore 파일을 이용해 추적 관리할 필요가 없는 파일을 배제시킬 수 있습니다. 그냥 만들어도 되지만 여기로 이동해 보시면 조금 쉽게 .gitignore 파일의 내용을 만들어 복사해서 사용하실 수 있습니다. Remote RepositoryGit은 혼자 사용할 수 도 있지만 기본적으로 다른 사람과 협업을 하기 위한 도구입니다. 협업 도구로서 Git의 가장 큰 유용함은 Remote Repository(원격 저장소)에 있습니다.이 Remote Repository는 우리가 따로 구축해서 사용할 수 있습니다. 또한 이런 Remote Repository를 서비스하는 회사도 굉장히 많이 있습니다. Git 기반의 Remote Repository 중 가장 대표적인 것이 바로 GitHub입니다.Remote Repository를 쉽게 생각하자면 로컬에서 작업한 Git Local Repository가 외부에 있는거라고 생각하시면 됩니다. GitHub는이런 Remote Repository를 전세계적으로 서비스하고 있고 굉장히 많은 사람들이 GitHub를 자신들이 수행하고 있는 project의 Remote Repository로 이용하고 있습니다.GitHub에 있는 이런 Remote Repository는 크게 public repository와 private repository로 구분됩니다. 말 그대로 public repository는 아무나 파일들을 열람할 수 있도록 공개되어 있는 repository이고private repository는 권한을 가진 사람들만 사용할 수 있는 repository입니다.GitHub는 Fork와 Pull Request라는 기능을 제공하고 있습니다. 정확히 말하자면 이 Fork와 Pull Request는 Git이 제공하는 것이아니라 GitHub가 제공하는 서비스 입니다.      Fork : 다른 사람의 Repository를 통째로 내 GitHub 계정으로 복사해 오는 기능입니다. 즉, GitHub 계정간 Repository를 서로복사해 갈 수 있는 기능이라고 보시면 됩니다.        Pull Request : 다른 사람의 Repository를 Fork한 후 그 내용을 수정한 다음 원본 Repository에 수정된 내용을 보내 병합을요청할 수 있는데 이 작업을 Pull Request라고 합니다. 아무나 Repository를 수정할 수 있는 권한을 주게 되면 Repository는 금방엉망이 될 테니 READ기능(Fork)만 제공하고 병합시에는 요청을 받아서 처리하도록 합니다.   GitHub에 Remote Repository 생성그럼 이제 GitHub에 계정을 생성하고 Remote Repository를 생성해 사용하는 방법에 대해서 알아보겠습니다.GitHub에 계정을 생성하고 새로운 Repository를 생성하는 버튼을 클릭하면 다음과 같은 화면을 보실 수 있습니다. Repository이름을 입력하고 간단한 설명을 입력합니다. Repository의 종류를 선택할 수 있는데 private은 비용을 지불해야 사용할 수 있습니다. 우리는 아까 만들어 놓은 Local Repository와 연결시키는 목적으로 사용할 것이기 때문에 README 파일을 만들지 않고Repository를 생성합니다.Repostiroy를 생성하면 다음과 같은 화면을 보실 수 있습니다. Repository에 현재 파일이 존재하지 않기 때문에이렇게 나오는 것이고 만약 특정 파일들이 저장되어 있으면 파일의 목록들이 보여지게 됩니다. Remote Repository 관리 명령어GitHub에 생성한 Remote Repository를 관리하기 위해서 Git은 몇몇개의 명령어를 제공합니다.  git clone : Remote Repository의 모든 내용을 Local Repository로 복사합니다.  git remote : Local Repository를 특정 Remote Repository와 연결시킬 때 사용합니다.  git push : Local Repository에 추가된 파일이나 변경 사항을 연결된 Remote Repository에 저장하기 위해서 사용합니다.  get fetch : Remote Repository와 Local Repository의 변경 사항이 다를 때 이를 비교 대조해서 충돌을 해결하고최신 데이터를 반영하기 위해서 사용합니다.  git pull : 연결된 Remote Repository의 최신 내용을 Local Repository로 가져오면서 merge합니다. git push와 반대의 개념이라고 보시면 되지만 merge할 때 문제가 발생했을 때 추적이 어렵습니다. 따라서 git pull을 이용하는 것 보다는 일단git fetch로 변경사항을 받고 이를 확인해서 코드를 수정한 후 Local Repository에 commit한 다음 git push로 최종 변경 사항을Remote Repository에 반영하는게 더 좋은 방법입니다. git clonegit clone은 Remote Repository에 있는 project를 내 컴퓨터로 가져올 때 사용합니다. 즉, GitHub에서 Local 환경으로 복사하는 작업입니다. 위에서 생성했던 MyProjectRemote란 GitHub Remote Repository를 Local로 clone해 보도록 하겠습니다.      먼저 Remote Repository의 주소를 복사합니다.        로컬 컴퓨터에서 프로젝트를 저장할 폴더를 생성한 후 git clone을 이용해 저장소를 복사합니다. D:/GitHub 폴더를 생성한 후 이 폴더 안에서 다음의 명령을 실행시킵니다.    git clone https://github.com/moon9342/MyProjectRemote.git정상적으로 clone이 진행되면 저장소 이름으로 폴더가 하나 생성되는것을 볼 수 있습니다. 당연히 이 폴더는 Remote Repository와 연결되어 있는 Local Repository가 됩니다.이해를 돕기 위해 순차적으로 생각해보면 다음과 같이 project가 진행될 수 있습니다.      협업을 책임지는 사람(PM)이 GitHub에 빈 Remote Repository를 생성합니다.        PM은 자신의 Local Repository에 project에 필요한 기본 구조와 여러가지 환경설정 그리고 개발한 필요한 기타 사항들을만들어서 저장합니다.        PM은 project의 뼈대가 담겨있는 이 Local Repository를 GitHub에 생성해 놓은 빈 Remote Repository와 연결합니다. 이때 git remote 명령을 이용하게 됩니다.        PM은 자신이 Local Repository에 가지고 있는 내용을 Remote Repository에 push 합니다.        이제 협업하는 사람 모두가 이 Remote Repository를 clone해서 로컬로 복사해 간 다음 자신이 해야 하는 작업을 진행합니다.  위와 같은 식으로 생각하면 git remote와 git clone의 차이점을 이해할 수 있습니다. git remoteGitHub에 빈 Remote Repository를 생성한 후 git remote를 이용하여 Local Repository와 연결할 수 있습니다.다음과 같은 명령을 이용합니다.  git remote add origin “Remote Repository URL”연결이 성공했는지를 다음의 명령어를 이용해서 확인해 볼 수 있습니다.  git remote -v git pushgit remote를 이용하여 Local Repository와 Remote Repository가 연결되었으면 이제 자신이 작업한 내용을Remote Repository에 upload를 할 수 있습니다.이 때 git push 명령을 이용하면 파일을 upload할 수 있는데 기본적으로 Remote Repository의 master branch에upload되게 됩니다. 따라서 만약 다른 branch의 내용을 upload하려 하면 다음과 같이 명령을 실행시켜야 합니다.  git push origin “local branch명”위의 명령에서 origin은 원격 저장소의 별칭입니다. git remote를 이용하여 Remote Repository를 연결할 때 이 origin이라는 별칭을 이용해서 원격 연결을 했었습니다.만약 origin 저장소에 Local의 모든 branch를 push하려면 다음과 같이 명령을 수행하시면 됩니다.  git push origin --allgit push가 진행될 때 Remote Repository에 같은 이름의 branch가 존재한다면 내용이 변경될 것이고 만약해당 branch가 존재하지 않는다면 새로운 branch를 Remote Repository에 생성하게 됩니다. 같은 이름의 branch가존재하지만 내역이 다르다면 당연히 push는 일어나지 않고 작업이 거부됩니다.간단한 예를 들자면 Local Repository의 master branch의 내용을 Remote Repository에 push하려면 다음과 같이실행하시면 됩니다.  git push origin master만약 Local Repository의 hotfix branch의 내용을 Remote Repository에 push하려면 다음과 같이 실행하시면 됩니다.  git push origin hotfix git fetch &amp; git pullRemote Repository를 이용하다 보면 다른 누군가가 먼저 commit할 경우가 있습니다. 이런 경우git은 당연히 파일의 내용이 서로 상이하기 때문에 push를 허용하지 않습니다.Remote Repository와 Local Repository를 적절히 서로 맞춰야 하며 이럴 때 사용하는 것이 git fetch 입니다.즉, fetch는 Remote Repository의 commit들을 Local Repository로 가져오는 역할을 하고 사용자는 Local Repository로 가져온 commit들을 자신의 작업과 적절히 병합하여 Remote Repository에 push해야 합니다.git pull은 Remote Repository의 정보를 가져오면서 자동으로 Local branch에 병합하는 명령어 입니다. 편하게 사용할 수 는 있지만 만약 conflict가 발생하면 내역 확인이 쉽지 않은 단점이 있습니다.End.",
        "url": "/git-github"
    }
    ,
    
    "typescript-class": {
        "title": "TypeScript 강좌(7) - Class",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Class기존의 JavaScript는 재사용 가능한 component를 만들기 위해 함수와 prototype에 기반한 상속을 이용했습니다. 하지만기존 객체지향에 익숙해 있는 개발자들에게는 상당히 생소한 개념이었죠. 그래서 ECMAScript 2015( ES6 )에서는 개발자들이 좀 더 쉽게 JavaScript Application을 구현할 수 있도록 전통적인 class 기반의 객체지향 개념을 도입했습니다.TypeScript 역시 이 class기반의 객체지향 기법을 이용해 Application을 개발할 수 있습니다.일단 ECMAScript 2015( ES6 )의 class는 다음과 같이 정의하고 사용할 수 있습니다.class Book {    constructor(btitle,bauthor) {        this.btitle = btitle;        this.bauthor = bauthor;    }    printInfo() {        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}let book = new Book('젊은 베르테르의 슬픔','괴테');book.printInfo();위의 코드는 data type의 정보를 포함하고 있지 않기 때문에 TypeScript로 변형하면 오류가 발생합니다.적절히 타입 정보를 포함해 코드를 수정하면 다음과 같습니다.class Book {    btitle: string;    bauthor: string;    constructor(btitle:string, bauthor:string) {        this.btitle = btitle;        this.bauthor = bauthor;    }    printInfo(): void {        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}let book:Book = new Book('젊은 베르테르의 슬픔','괴테');book.printInfo();위의 코드는 Java에서 우리가 익히 보아왔던 class의 형태입니다. 생성자를 표현하는 부분이 좀 생소하지만 쉽게이해할 수 있을 듯 합니다. Inheritance일반적인 객체지향언어의 Inheritance 개념 역시 TypeScript에도 사용할 수 있습니다. 다음의 코드를 보죠.class Book {    btitle: string;    bauthor: string;    // 상위 클래스의 생성자    constructor(btitle:string, bauthor:string) {        this.btitle = btitle;        this.bauthor = bauthor;    }    // 상위 클래스의 method    // 입력 인자가 있으면 사용하고 없으면 default 사용    printInfo(input:string = 'Initial'): void {        console.log(input);        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}// class의 상속class EBook extends Book {    btype: string;    constructor(btitle:string, bauthor:string, btype:string) {        // 상위 class 생성자 호출        super(btitle, bauthor);        this.btype = btype;    }    // method overriding    printInfo(): void {        // 상위 class의 method 호출        super.printInfo();        console.log(`제목: ${this.btitle},                      저자: ${this.bauthor},                     타입: ${this.btype}`);    }}// IS-A relationship에 의한 상위 class type 사용let book:Book = new EBook('젊은 베르테르의 슬픔','괴테',    'PDF');// dynamic binding에 의한 overriding method 호출.book.printInfo();기존 class를 확장하여 새로운 class를 정의하는 방법입니다. IS-A Relationship 역시 성립합니다. 그로 인한상위 타입으로 객체를 사용할 수 있습니다. 또한 위의 예에서 처럼 method overriding의 개념 역시 존재하고 dynamic binding 개념 역시 존재합니다. 물론 TypeScript에서는 공식적으로 저 용어를 사용하지는 않습니다.다만 우리가 Java언어에서 알고 있던 객체지향 개념이 그대로 TypeScript에도 일부 적용된다고 보시면 됩니다. Access ModifierTypeScript는 3가지 종류의 접근제어 연산자를 제공합니다. 우리에게 익숙한 public, protected, private 키워드로 제공되며 default값은 public입니다. 즉, Access Modifier를 명시하지 않으면 모두 public으로 간주됩니다.  public : 접근제한이 없습니다. class외부에서 자유롭게 접근이 가능합니다.  protected : class 외부에서 접근할 수 없습니다. 단, 상속받은 하위 class에서는 접근이 가능합니다.  privatre : class 외부에서 접근할 수 없습니다. 상속받은 하위 class에서도 접근이 불가능합니다.class Book {    protected btitle: string;    public constructor(btitle:string, private _bauthor:string) {        this.btitle = btitle;    }    public printInfo(): void {        console.log(`제목: ${this.btitle}, 저자: ${this._bauthor}`);    }    // private property인 _bauthor의 getter    get bauthor(): string {        return this._bauthor;    }    // private property인 _bauthor의 setter    set bauthor(value: string) {        this._bauthor = value;    }}class EBook extends Book {    private btype: string;    public constructor(btitle:string, bauthor:string, btype:string) {        super(btitle, bauthor);        this.btype = btype;    }    public printInfo(): void {        console.log(`제목: ${this.btitle},                      저자: ${this.bauthor},                     타입: ${this.btype}`);    }}let book:Book = new EBook('젊은 베르테르의 슬픔','괴테',    'PDF');book.printInfo();위의 예제에서는 다음의 코드를 주의해서 보아야 합니다. 생성자의 인자로 private _bauthor:string라고 선언된 부분이 보입니다.    protected btitle: string;    public constructor(btitle:string, private _bauthor:string) {        this.btitle = btitle;    }생성자에 인자를 명시할 때 access modifier를 같이 명시하면 위의 예처럼 명시적으로해당 property가 선언되어 사용할 수 있게 됩니다.일반적으로 private property의 이름은 앞에 _를 관용적으로 써주게 됩니다. 이렇게 사용하는 이유는관용적 coding convention 때문에 그렇습니다. ECMAScript에서는 개발자들이 private의 의미로 사용되는property에 일반적으로 _를 붙여서 사용했었습니다.또 다른 이유는 setter와 getter의 이름때문에 그렇습니다. 다음의 코드에서 보듯이 TypeScript에서 getter와 setter의 표현은 우리가 알고 있는 다른 언어의 getter, setter와 다릅니다. 그리고 이렇게선언된 getter와 setter가 어떻게 사용되는지도 유의해서 보시기 바랍니다.    // private property인 _bauthor의 getter    get bauthor(): string {        return this._bauthor;    }    // private property인 _bauthor의 setter    set bauthor(value: string) {        this._bauthor = value;    } Readonly Propertyclass의 property를 readonly로 지정할 수 있습니다. readonly로 지정되면 property가 선언될 때 혹은 생성자안에서반드시 초기화를 진행해야 합니다. 다음의 예제를 참고하시면 됩니다.class Book {    public readonly btitle: string;    constructor(btitle: string) {        this.btitle = btitle;    }}let book:Book = new Book('젊은 베르테르의 슬픔');book.btitle = '파우스트';   // 코드 에러다음의 예제처럼 생성자의 parameter를 readonly로 선언하면 따로 class의 property로 선언할 필요가 없습니다.class Book {    constructor(readonly btitle: string) {        this.btitle = btitle;    }}let book:Book = new Book('젊은 베르테르의 슬픔');console.log(book.btitle); Static Propertystatic 키워드 역시 사용할 수 있습니다. ECMAScript 2015에서는 static을 method에만 적용할 수 있었지만TypeScript는 property에도 적용할 수 있습니다. static property는 class의 이름으로 직접 access를 할 수 있습니다.class Book {    public btitle:string;    static count: number;    constructor(btitle: string) {        this.btitle = btitle;        Book.count++;    }}let book1:Book = new Book('젊은 베르테르의 슬픔');let book2:Book = new Book('파우스트');console.log(Book.count); Abstract Classabstract class는 하나이상의 abstract method를 가지고 있는 class를 의미합니다. method의 선언만을 가지고 있기때문에 직접적인 객체생성을 할 수 없고 상속을 이용해 하위 클래스에서 abstract method를 overriding해서 사용하게 됩니다.abstract class Book {    public btitle:string;    constructor(btitle: string) {        this.btitle = btitle;    }    abstract printInfo(): void;}class EBook extends Book {    printInfo(): void {        console.log(this.btitle);    }}let book:Book = new EBook('젊은 베르테르의 슬픔');book.printInfo(); interface의 의미로 class사용이 부분은 기존의 다른 언어와 다릅니다. class를 확장해서 interface를 정의할 수 있습니다. 다음의 코드를 참조하세요class Book {    btitle: string;}interface EBook extends Book {    bauthor: string;}let book:EBook = {    btitle: '파우스트',    bauthor: '괴테'};이번 포스트에서는 TypeScript의 class에 대해서 살펴보았습니다. 객체지향 언어의 class와 상당히 유사하면서도약간의 차이점이 있었습니다. 차이점 위주로 기억하시면 될 듯 합니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-class"
    }
    ,
    
    "front-end-ecosystem": {
        "title": "Front-End 발전 역사와 개발 생태계",
            "author": "javascript",
            "category": "",
            "content": "Introduction이번 포스트는 과거 JavaScript 탄생부터 시작해서 어떻게 발전해왔는지에 대한 내용과 현재 Front End 개발에 있어서 무엇을 알아야 하는 지에 대한 전반적인 기술 상황에 대해서 알아보겠습니다. JavaScript 탄생JavaScript라는 언어의 역사는 저의 다른 포스트에서도 볼 수 있지만 여기서도 간단하게 언급하고 넘어가겠습니다.JavaScript언어의 역사는 1995년 Netscape사의 Brendan Eich(브랜든 아이크)에 의해 개발된 Mocha라는 언어부터 시작됩니다.이 Mocha라는 언어는 “Prototype의 개념과 Functional Language(함수형 언어)의 특성을 가지고 Web에 동적으로 활용할 수 있는 언어를 만들어보자” 라는 취지로 2주일 이라는 굉장히 짧은 기간안에 만들어졌습니다.추후에 Mocha -&gt; LiveScript -&gt; JavaScript로 개명되었고 ECMA에 ECMA-262 기술규격으로 ECMAScript라는 이름으로 표준화를진행하게 됩니다. 이에 대응해 1996년 MicroSoft 측에서는 JScript라는 걸 만들어내서 자사의 IE 3안에 포함시켜 제공하기 시작했습니다.이런 JavaScript는 여러가지 문제점을 내포하고 있었는데 가장 큰 문제를 꼽자면  구현의 어려움  언어의 모호성  Cross Browsing의 한계정도를 들 수 있습니다. 즉, 사용자 입력값을 검사하는 용도, 사용자의 이벤트를 감지해서 처리하는 용도로는 사용할 수 있지만 언어 자체가 가지고 있는 근본적인 문제때문에 사용이 힘들었습니다. 구세주의 등장 - jQuery이 때 구세주가 등장합니다. 우리가 잘 알고 있는 jQuery library입니다.jQuery는 open source javascript library로 순수 javascript가 가지고 있었던 DOM처리의 어려움과 Cross Browsing에 대한 issue를해결하면서 JavaScript의 대표적 library로 사용되게 되었습니다. jQuery로 인해 JavaScript가 조금은 쓸만한 언어로 여기지면서사용되기 시작했습니다.그러면서 그냥 그냥 아주 소소하게 client web browser안에서 JavaScript 코드와 jQuery 코드가 이용되었던 거지요. 특별히 중요하지도 않은단위코드 위주로 사용이 되는 그런 수준이었습니다. 그러면서 우리 기억에도 “알면 좋고 몰라도 상관없는 언어”로 인식되었습니다.그렇게시간은 흘러갑니다.!!1997년 ECMAScript의 초판이 나오게 됩니다. ES1이라고 합니다. 그 후 1999년에 ES3가 나오게 됩니다. 여기까지 하고 한동안ECMAScript 표준은 쿨쿨 잠을 자게 됩니다. 다시 JavaScript에 날개를 달아보자 - HTML51999년 12월 W3C(World Wide Web Consortium)에서 하나의 발표를 합니다. 아시다시피 W3C는 HTML과 CSS의 표준을 관장하는 기구입니다. 이때까지 우리가 사용하는 HTML의 버전은 4.01버전이었습니다. W3C는 이 버전을 마지막으로 더 이상 HTML의 버전업은 없을 것이라고 공표하게 됩니다. 그때까지 잘 사용해왔던 HTML을 왜 버전업하지 하지 않겠다고 했을까요?여러가지 이유가 있지만 프로그래밍 언어의 측면에서 바라보면 HTML이란 언어는 다음과 같은 한계점이 있습니다.  정형성 : HTML언어는 정형성이 없기때문에 유지보수에 적합하지 않다.  확장성 : 정해진 Tag만 이용하기 때문에 언어자체에 대한 기능적 확장이 어렵다.W3C는 저 두가지 이유를 들어 HTML언어를 이대로 끌고 가기 보다는 좀 더 다른 수단을 강구해야 겠다고 판단합니다. W3C의 선택은바로 XML의 도입이었습니다. 즉, HTML이 가지는 두가지 문제점을 해결할 수 있는 XML을 도입해서 새로운 Web언어의 표준을끌고 나갈 생각이었습니다. 그 결과 2000년 들어오면서 HTML과 XML이 결합된 새로운 표준인 XHTML 1.0이 발표되게 됩니다.W3C의 이런 의도와는 다르게 몇몇개의 회사들이 모여서 조금 다른 접근을 모색합니다. XML을 도입하지 말고 순수하게 HTML을 기능을버전업시킬 수 있는 방법을 찾기 시작한 것이죠. 그래서 WHATWG(Web Hypertext Application Technology Working Group)이라는 Working Group이 만들어지고 이 안에서 기존의 HTML을 발전시킬 방법을 연구하게 됩니다. ( 사실 여기서 할 말이 많기 한데 자꾸 산으로 가는 느낌이라 적당히 짜르겠습니다. ) 이 WG에서 나온것이 바로 현재의 표준인 HTML5입니다. HTML을 이용해서 Web Application을 만들자는 취지입니다. 이 HTML5안에 Client Web Application을 작성할 수 있는 API가 포함되어 있는데 이게 JavaScript로되어 있습니다. 결국 HTML5가 issue화 되면서 JavaScript의 위상도 조금씩 더 올라가게 됩니다.그래서인지 쿨쿨 잠을자던 ECMAScript 개정판(ES5)이 2009년에 등장합니다. 참고로 4판(ES4)은 버려졌습니다. 이제 슬슬JavaScript에 대한 발전이 시작됩니다. JavaScript의 획기적 전환점 - Node.js2013년 Node.js가 출시됩니다. 아무리 HTML5라고 해도 이때까지의 JavaScript는 Browser안에서 동작하는 언어였습니다.우리가 알고 있는 Java, C#과 같은 언어가 될 수 없는 태생적 한계가 있는거죠. 이런 browser에 갇힌 JavaScript를browser 외부로 탈출하게끔 만들어준 일등공신이 바로 Node.js입니다. 결국 JavaScript로 다른 언어처럼 OS위에서 동작하는일반 application을 작성할 수 있는 길이 열린것이고 그에 따라 언어의 위상이 완전히 변했습니다.그에 발맞춰 ECMAScript도 빠르게 변화하기 시작했습니다. 2015년에 ECMAScript 2015(ES6)가 등장하면서 JavaScript 언어자체에아주 큰 변화들이 많이 생겼습니다. 현재 ECMAScript 2016(ES7)까지 나온 상태입니다. 조금 지나면 ES8이 표준화되어서 나오겠네요.거의 1년마다 새로운 배포판이 나올정도로 빠르게 변화하면서 언어적 측면에서 가지고 있던 많은 문제점들을 극복하려고 노력하고 있습니다.현재(2018년 1월) 대부분의 browser들은 ES6를 지원하고 있습니다. 여기에 접속해 보시면 특정 browser에 대해 각 ECMAScript의 버전 호환성을 보실 수 있습니다.  이제 IE는 고만쓰도록 해요. 제발….아직 완벽하게 Cross Browsing이 안되는데 어떻게 하느냐에 대한 문제는 Babel, TypeScript와 같은 transpiler를 이용해서 해결할 수 있습니다. Babel, TypeScript는 ES6(ES7) 문법으로 쓰여있는 JavaScript code를 ES5 형태의 JavaScript로 변환시켜주기 때문에 IE에서 ES6지원이 안됨에도 불구하고 ES5로 변환해서 사용할 수 있습니다. 변화의 속도가 너무 빠름그런데 문제는 기술의 발전 속도가 너무 빠르다는데 있습니다. 또한 알아야 할게 한두 가지가 아니구요. 과거 Back End에서 사용했던 프로그래밍 기술과 여러가지 개발 툴의 개념들이 다 Front End로 넘어왔기 때문입니다.너무 많은기술들이 빠르게 생기고 빠르게 사라지고 있습니다.사실 2-3년전에 자주 사용했던 JavaScript Library와 Framework들 중 많은 것들이 이미 다른 것으로 대체되었습니다. 그렇다고 손 놓고 있을 순 없으니 현재 상태에서 우리가 Front End 개발을 하기 위해 필수적으로 알아야 하는 것 몇가지만살펴보도록 하겠습니다. 이것정도는 알고 가자  Package Manager : NPM, Yarn외부 라이브러리를 사용할 경우 해당 라이브러리를 설치, 삭제, 의존성 관리등을 해야 하는데 이를 위한 도구가 몇몇 존재합니다. 그중 하나만 하자면 당연 npm입니다. Node Package Manager의 약자이고 Node.js를 살짝 맛보시면npm이 어떻게 동작하는지 아실 수 있습니다. 굳이 Node.js에 대해서 학습할 필요는 없습니다. 당연히 알면 좋지만요.  Transpiler : Babel, TypeScript( 이미지 출처 : http://news.softpedia.com/news )Cross Browsing을 위한 Transpiler입니다. 비교 대상은 아닙니다. 둘 다 알아둘 필요는 있지만 저는 TypeScript는 반드시 해야 한다고 생각합니다. 앞으로 TypeScript는 더 발전할 듯 보이거든요. 하지만 배우기 쉽지 않습니다. 언어적 측면을 파고 들면 내용이 꽤나 많습니다.다행히 TypeScript는 ECMAScript의 superset이니 ECMAScript 공부한다고 생각하시면 속 편합니다.또한 제 개인적인 생각과는 반대로 TypeScript언어의 단점도 분명히 존재합니다. 엄격한 type checking덕분에JavaScript가 가지는 프로그래밍의 유연함이 많이 떨어진다는 것이죠.  자동화 도구 : Grunt, Gulp빌드, 테스트, 배포등을 위한 자동화 도구입니다. 과거에는 Grunt를 많이 사용했지만 현재는 Gulp인듯 합니다. 시간 좀 지나면 Gulp도 Grunt와 마찬가지로 역사속으로 사라지게 되겠지만 지금은 Gulp가 대세입니다.  module bundler : webpack, rollup코드 재사용을 위한 모듈화 도구들과 bundler 역시 여러가지 있는데 요즘 많이 사용하는 건 webpack입니다.ES6 들어오면서 언어적 차원에서 Module을 지원하기 시작했고 이런 Module들을 하나로 모아 Packaing하는 작업이필요하게 되었습니다. 이를 위한 도구 역시 발전을 하고 있구요. 과거에는 Common.js, Require.js를 이용하여처리했다면 최근에는 webpack, rollup을 이용하여 처리합니다.  Framework &amp; Library : Angular, React, Vue.js우리의 목적은 사실 저 위의 3가지를 배우는 것입니다. 각기 나름대로의 장점과 특징들을 가지고 있습니다. 개인적으로는 블로그내에 저 세가지의 강좌를 개설하는게 2018년 상반기의 블로그 목표입니다. 대세는 Angular이지만 React의 성장세역시 가히 폭발적입니다. 아직까지(2018년 1월기준) Vue.js는 Angular와 React 만큼의 성장세는 보이지 않고 있지만 이 역시 어떻게 될지는모를일이죠 정리위에서 “이것정도는 알고가자”라고 했지만 그 내용을 전부 다 알고 있으면 상당한 경험과 실력을 가진Front End 개발자일 것입니다. 또 위에 포함을 안했지만  Git같은 것은 기본적으로 숙지해야 할 것이구요. 할게 너무 많네요천천히 하나씩 해보도록 하죠 머…그리고 “이것정도는 알고가자”에서 제가 강조한 것들은 제가 현재 사용하는 것들입니다.그것들이 더 좋다는 보장은 어디에도 없습니다. 자기 손에 익숙한게 최고입니다. ^^End.",
        "url": "/front-end-ecosystem"
    }
    ,
    
    "jekyll-travis-ci-public": {
        "title": "Jekyll 기반의 GitHub Page 생성(8)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Travis CI 활용(public Repository)CI ( Continuous Integration )의 개념에 대해서 잘 알지 못하시는 분은 여기를 클릭하셔서 간단하게 이해를 하고 오시면 됩니다.이 포스트에서는 Travis CI를 이용하여 Jekyll Source Folder안의 내용을 GitHub Repository에 commit했을 때 자동으로 GitHub Page에 블로그가 deploy되도록 하는 방법에 대해서 알아보겠습니다.일단은 사용하는 GitHub Repository는 모두 Public으로 되어 있다고 가정하고 진행합니다. 만약 Private Repository를 이용하실려면 좀 더 복잡한 처리와 돈이 들어갑니다. (Travis CI는 GitHub Public Repository에 대해서는 무료이지만 Private Repository에 대해서는 일정량의 금액을 지불해야 합니다.)그럼 천천히 한번 진행해 보도록 하죠 GitHub에 2개의 Repository 준비먼저 Jekyll Source Folder ( D:/blogmaker )에 대한 GitHub Repository를 준비합니다. Public으로 생성하셔야 합니다.저는 GitHubPageMaker라는 이름으로 Repository를 생성했습니다. 생성할 때 README.md 파일을 추가해서 생성하지 않습니다.  https://github.com/moon9342/GitHubPageMaker 형태로 생성되겠군요.그 다음은 GitHub Page에서 운영할 블로그에 대한 GitHub Repository를 준비합니다. 역시 마찬가지로 Public으로 생성하셔야 합니다.Repository의 이름은 형식이 정해져 있습니다. {GitHub ID}.github.io 로 Repository를 생성하셔야 합니다. 생성할 때 README.md 파일 하나 추가해서 생성합니다.  https://github.com/moon9342/moon9342.github.io 형태로 생성되겠네요. Local Git Repository 생성 및 Remote 연결GitHub에 원격 Repository가 생성되었으니 이번에는 로컬에 Repository를 생성합니다. D:/blogmaker 폴더에서 command 창을 열고다음을 입력합니다.  git initD:/blogmaker에 git Repository를 생성합니다. 이제 다음의 명령어를 이용해서 로컬 Repository에 파일을 추가하고 commit까지 진행합니다.  git add *  git commit -m “initial commit”자 이제 원격 Repository와 연결하는 작업을 수행합니다. 다음의 명령을 이용합니다.  git remote add origin https://github.com/moon9342/GitHubPageMaker.git현재의 로컬 Repository가 원격 Repository와 연결되었습니다. 연결상태를 확인하려면 다음과 같이입력하면 됩니다.  git remote -v Git Submodule 생성Jekyll Source Folder( D:/blogmaker )에 대한 Repository와 실제 블로그를 운영할 Repository를git submodule로 묶습니다. Submodule의 개념은 여기나 혹은 다른 블로그를 참조하세요.command 창에서 다음과 같이 입력합니다. ( command 창의 현재 경로는 D:/blogmaker 입니다.)  git submodule add https://github.com/moon9342/moon9342.github.io.git output현재 Repository의 하위에 output이라는 이름의 폴더가 만들어지고 해당 폴더는 moon9342.github.io Repository에 대한 로컬 git Repository가 됩니다. ( 내부적으로 git clone이 실행됩니다. )output이라는 이름은 다른 이름으로 변경하셔도 됩니다. 단 _config.yml에 있는 destination 속성의 값과 이 이름이 같아야 합니다.정상적으로 clone이 진행되어서 submodule이 생성되면 다음과 같이 입력합니다.  git submodule updategit은 submodule에 대한 삭제명령을 제공하지 않기 때문에 만약 기존의 submodule을 삭제하려면 다음과 같이 해야 합니다.  Repository 루트에 있는 .gitmodules 파일 수정  Repository 루트의 .git 폴더안의 config 파일 수정 ( [submodule “xxx”] 부분 수정)  git의 cache에서 submodule 삭제 ( git rm --cached module_path ) _config.yml 1차 수정Jekyll Source Folder( D:/blogmaker )에 있는 내용을 컴파일 하면 그 결과가 output 폴더에 들어가도록_config.yml을 수정합니다._config.yml의 destination 부분을 찾아 ./output/으로 수정합니다. Travis 사이트에 접속Travis 사이트에 접속해서 GitHub Repository에 대한 연결을 활성화 시킵니다.기본적으로 Public Repository만 사용할 수 있습니다. 만약 Private Repository를 사용하고 싶으면 별도의 비용을 지불해야 합니다. ( 비용이 좀 비싼편입니다. )  https://travis-ci.org =&gt; Public Repository를 위한 site입니다. GitHub 계정으로 로그인 합니다.  https://travis-ci.com =&gt; Private Repository를 위한 site입니다. GitHub 계정으로 로그인 합니다.그림에서와 같이 연동할 GitHub Repository를 선택해서 Enabled 시켜줍니다.잠깐 정리하자면, 연동된 GitHub Repository인 GitHubPageMaker에 push가 이루어지면 Travis CI가 .travis.yml 설정파일을찾아서 이를 이용해 특정 작업을 수행하게 됩니다. 당연히 GitHubPageMaker Repository에 .travis.yml 파일을 작성해서 넣어 놓아야합니다.우리는 이 .travis.yml과 Rakefile을 이용하여 output안에 있는 내용을 commit하고 push하게 될 것입니다. output은 GitHub Page와 연동되는 Repository이기 때문에 결국 Jekyll로 컴파일한 내용이 GitHub Page Repository로 들어가게 되는 겁니다. Token 생성Travis CI에서 다른 Repository로 push를 하기 위해서는 token이 필요합니다.GitHub에 접속해 Setting &gt; Developer settings &gt; Personal access tokens에 들어가서 Generate New Token을 클릭합니다.적당히 description을 작성하고 Select scopes 중 repo 선택하고 generate token을 클릭하면 새로운 token이 생성됩니다. 이 token을 바로 이용할 건 아니기 때문에 어딘가에 잘 저장해 둡니다.이 token값을 직접 Travis CI 설정파일( .travis.yml )에 직접 노출시키면 안되고 이 값을 암호화해서 사용해야 합니다.일단 command 창을 열어서 travis gem을 설치합니다.  gem install travis설치가 끝나면 다음의 명령을 이용해서 암호화를 진행합니다. 만약 로그인을 안했다는 메시지가 나오면 다음과 같이 로그인 후 진행하시면 됩니다. (ID/PW는 GitHub의 ID/PW를 이용합니다.)  travis login --pro  travis encrypt GITHUB_TOKEN=&lt;token&gt; -r &lt;repo-name&gt;여기서 &lt;token&gt;에는 아까 우리가 획득한 GitHub token을 넣어주시면 됩니다. &lt;repo-name&gt;부분에는 우리의Jekyll Source Folder에 대한 Repository이름을 주면 됩니다. 주의하실점은 {ID/RepoName} 형태로 사용하셔야 합니다. 저의 경우를 예로 들자면 다음과 같습니다.  travis encrypt GITHUB_TOKEN=123abc456xxx -r moon9342/GitHubPageMaker위의 과정을 거치면 암호화된 값을 얻을 수 있는데 이 값을 아래와 같이 .travis.yml안에 설정하시면 됩니다.env:  global:    secure: \"여기에 암호화된 값을 넣습니다.\"branches:  only:    - master 사용되는 파일 수정이제 _config.yml, .travis.yml, Rakefile 파일을 아래와 같이 적절하게 수정해야 합니다. Ruby언어로 작성된 script를 보는게 영 껄끄럽지만 어렵지 않는 내용이니 천천히 보시면 됩니다._config.yml 파일입니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 10# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Blog# 자신의 blog title.description: Development &amp; Technical Training# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: sunghoons-blog# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics:  # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]exclude: [vendor]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source: destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안으로 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.production_url:  https://moon9342.github.io/source_url:  https://github.com/moon9342/GitHubPageMaker/# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules는 포함시키자)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules.travis.yml 파일입니다.sudo: falselanguage: rubycache: bundlerrvm:- 2.4.2install:  # Install Jekyll and dependencies  - bundle installbefore_script:  - git config --global user.email &quot;moon9342@gmail.com&quot;  - git config --global user.name &quot;Moon Sung Hoon&quot;script: bundle exec rake site:deploy --quiet #--trace# Generate your secure token with the travis gem:# get Github token from your Travis CI profile page# gem install travis# GH_TOKEN from https://github.com/settings/tokens# travis encrypt &#39;GIT_NAME=&quot;YOUR_USERNAME&quot; GIT_EMAIL=&quot;YOUR_EMAIL&quot; GH_TOKEN=YOUR_TOKEN&#39;env:  global:    secure: &quot;xxxxxxxxxxxxxxxxxxxx&quot;branches:  only:    - masterRakefile 파일입니다.############################################################################### Modified version of jekyllrb Rakefile# https://github.com/jekyll/jekyll/blob/master/Rakefile##############################################################################require &#39;rake&#39;require &#39;date&#39;require &#39;yaml&#39;CONFIG = YAML.load(File.read(&#39;_config.yml&#39;))USERNAME = CONFIG[&quot;username&quot;]REPO = CONFIG[&quot;repo&quot;]SOURCE_BRANCH = CONFIG[&quot;branch&quot;]DESTINATION_BRANCH = &quot;master&quot;def check_destination  unless Dir.exist? CONFIG[&quot;destination&quot;]    sh &quot;git clone https://$GIT_NAME:$GITHUB_TOKEN@github.com/#{USERNAME}/#{REPO}.git #{CONFIG[&quot;destination&quot;]}&quot;  endendnamespace :site do  desc &quot;Generate the site&quot;  task :build do    check_destination    sh &quot;bundle exec jekyll build&quot;  end  desc &quot;Generate the site and serve locally&quot;  task :serve do    check_destination    sh &quot;bundle exec jekyll serve&quot;  end  desc &quot;Generate the site, serve locally and watch for changes&quot;  task :watch do    sh &quot;bundle exec jekyll serve --watch&quot;  end  desc &quot;Generate the site and push changes to remote origin&quot;  task :deploy do    # Detect pull request    if ENV[&#39;TRAVIS_PULL_REQUEST&#39;].to_s.to_i &gt; 0      puts &#39;Pull request detected. Not proceeding with deploy.&#39;      exit    end    # Configure git if this is run in Travis CI    if ENV[&quot;TRAVIS&quot;]      sh &quot;git config --global user.name $GIT_NAME&quot;      sh &quot;git config --global user.email $GIT_EMAIL&quot;      sh &quot;git config --global push.default simple&quot;    end    # Make sure destination folder exists as git repo    check_destination    sh &quot;git checkout #{SOURCE_BRANCH}&quot;    Dir.chdir(CONFIG[&quot;destination&quot;]) { sh &quot;git checkout #{DESTINATION_BRANCH}&quot; }    # Generate the site    sh &quot;bundle exec jekyll build&quot;    # Commit and push to github    sha = `git log`.match(/[a-z0-9]{40}/)[0]    Dir.chdir(CONFIG[&quot;destination&quot;]) do      # check if there is anything to add and commit, and pushes it      sh &quot;if [ -n &#39;$(git status)&#39; ]; then            git add --all .;            git commit -m &#39;Updating to #{USERNAME}/#{REPO}@#{sha}.&#39;;            git push https://$GITHUB_TOKEN@github.com/#{USERNAME}/#{USERNAME}.github.io.git #{DESTINATION_BRANCH} --quiet ;         fi&quot;      puts &quot;Pushed updated branch #{DESTINATION_BRANCH} to GitHub Pages&quot;    end  endend모든 설정이 끝났습니다. 이제 GitHub에 push작업을 해 보시면 Travis CI가 동작하면서 내부적으로 처리해서 결과를알려줍니다. 해보시면 아시겠지만 거의 스팸메일처럼 날라옵니다.Travis CI 사이트에 들어가면 CI Server가 어떻게 처리하는지를 실시간적으로 log를 출력해 보여주는데 그걸 보시면서 혹 문제가 있는 부분이 있으면 해결하시면 됩니다. Private Repository 사용우리는 두개의 Repository를 사용하고 있고 둘 다 Public으로 사용하고 있습니다. 당연한 말이지만이 중 중요한 것은 여러 설정과 실제 원본내용이 들어있는 Jekyll Source Folder에 대한 Repository인GitHubPageMaker Repository입니다. {GitHub ID}.github.io Repository는 Public으로 설정하고 Jekyll Source Folder는 Private으로 관리하고 싶은 경우는 위의 과정에서 약간만 손보시면 됩니다.  GitHub에서 해당 Repository를 Private으로 설정합니다.  travis-ci.com으로 접속하셔서 Private Repository에 대한 연결을 활성화 시킵니다.  획득한 token을 암호화 시키는 부분에서 다음과 같이 --pro 옵션을 추가합니다.  travis encrypt GITHUB_TOKEN=123abc456xxx -r moon9342/GitHubPageMaker --pro나머지 부분은 동일합니다. Travis CI를 이용할 경우 속도문제Travis CI를 돌려보면 알겠지만 내부적으로 bundle install을 매번 수행합니다. 이 간단한 것 하나 해결하는데2분가량의 시간이 걸리고 대부분의 시간이 설치시간입니다. 이 문제를 해결할 수 있는 방법 역시 있습니다.cache 처리인데요. 이 부분은 나중에 포스팅 할 예정입니다. 문제가 꼬리에 꼬리를 물면서 계속 튕겨 나오네요. 그러면서 배우는 거죠 머 ^^;일단 이런 문제가 있어요~ 라는 문제 제기만 하고 이번 글은 정리하도록 하겠습니다.End.",
        "url": "/jekyll-travis-ci-public"
    }
    ,
    
    "continuous-integration": {
        "title": "What is Continuous Integration?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionCI는 Continuous Integration의 약자로 우리나라 말로 굳이 번역하자면 “지속적인 통합” 정도가 되겠네요.여기서는 간단하게 Continuous Integration이 어떤 개념인지 살펴보도록 하겠습니다. CI(Continuous Integration)란 무엇인가?소프트웨에 개발은 다음과 같은 라이프 사이클을 가지고 있습니다.  계획 =&gt; 요구사항 분석 =&gt; 설계 =&gt; 코드화 =&gt; Build =&gt; Testing =&gt; Release =&gt; Deploywaterfall 방식으로 한 단계가 끝나면 다음 단계로 이동하기도 하지만 일반적으로는 프로젝트가진행되는 동안 이 안의 단계가 반복적으로 실행되게 됩니다.하지만 우리는 코드를 작성한 후 통합 Build작업과 통합 Test작업을 하지 않고 넘어가는 경우가 많습니다. 가장 큰 이유는 Build작업과 Test작업에 시간이 오래 걸리고 만약 중간에 문제가 발생하면 이걸 수정하는게 쉽지 않고 결국 또 시간을 잡아먹게 되기 때문이죠. 심한경우 프로젝트의 중반 이후에 개별적으로 작성한 코드를 통합 build하고 Test하는 경우도 있습니다. 이런 경우 소프트웨어 통합작업은 결국 산으로 올라가게 됩니다.Continuous Integration은 이런 문제점을 해결하기 위해 코드를 최대한 자주 통합하여 개발하는 소프트웨에 개발 방법론중의하나라고 볼 수 있습니다. 이런 CI를 도와주는 여러가지 툴들이 존재하는데 이를 이용하면 통합 시 필요한 여러가지 자잘한(?) 문제들을 자동화시켜서 최대한 빨리 오류를 발견하고 문제를 해결해 나갈 수 있습니다. 결과적으로는 상당히 품질이 좋은 소프트웨어를개발할 수 있게 되는 거지요.그림으로 표현하면 아래와 같이 단순하게 표현할 수 있겠네요.( 이미지 출처 : https://blog.snap-ci.com/categories/continuous-integration )사실 더 복잡하지만 위의 그림처럼 단순하게 바라보시면 될 듯 합니다. CI Server가 통합된 코드를 자동으로 Build-Test-Release-Deploy까지 진행하고 그 결과를 개발자나 다른 관련있는 사람에게 알려주게 됩니다.CI Server가 일련의 과정을 자동으로 처리해 줌으로써 개발자는 Business Logic 작성에 더 집중할 수 있고 오류에 대한 내용도 빨리수정을 할 수 있습니다. 일반적으로 Git과 같은 VCS(Version Control System)과 연계해서 사용하게 됩니다.현재 많이 사용되는 CI 제품들은 다음과 같습니다.      Jenkins : Java로 작성된 open source CI tool입니다. open source CI 진영에서는 압도적 사용자를 보유하고 있습니다. Java 개발자들에겐 진리입니다. 설치형이기 때문에 설정이 조금 복잡합니다.        Travis CI: Github와의 편한 연동 및 public repository에 대해서는 무료로 사용할 수 있다는 장점이 있습니다. 설정이 Jenkins만큼복잡하지 않고 Travis Server를 이용하여 동작시키는 것이기 때문에 편합니다. private repository에 대해서는 일정량의 비용을 지불해야합니다.        TEAMCITY, BAMBOO, GITLAB CI, CIRCLECI, CODESHIP 등등이 있습니다. 이놈들은 저도 써보질 않아서 할말이 없네요.  간단하게 CI의 개념에 대해서만 살펴보았습니다. Travis CI와 같은 것은 사용하기 그리 어렵지 않으니 한번 사용해 보시면 느낌이 확오실겁니다.End.",
        "url": "/continuous-integration"
    }
    ,
    
    "architecture-platform-terminology": {
        "title": "Library, Framework, Architecture, Platform",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionLibrary, Framework, Architecture, Platform은 우리가 너무나 많이 들어본 용어이고 그 의미도 대충 알고 있습니다. 하지만 명확하게 설명해봐!! 라고 한다면 주춤 주춤하게 만드는 용어이기도 합니다.이번 포스트는 저 위에 나열된 4개의 용어에 대한 간략한 정리입니다. Library가장 쉬운 개념입니다. 일반적으로 Library는 다른 프로그램에서 링크 되기 위해 사용되는 하나 이상의 function 혹은 class들의 집합이며 이들은 일반적으로 파일형태로 존재합니다.Library를 사용하는 가장 큰 목적은 코드의 재사용성을 높이기 위함이지요. 자주 사용되는 기능들은 매번 새롭게 작성하지 말고 function이나 class 형태로 만들어 놓고 필요할 때 그 기능을 쉽게 불러다가 사용하자는 개념입니다.      Library의 가장 간단한 예로는 jQuery가 있습니다. Front-End 작업을 할 때 DOM 구조에서 내가 원하는 Element를 빠르고 쉽게 찾아 DOM 에서 제거하고 싶을 때 jQuery Library를 이용하면 단 1줄에 해결할 수 있습니다. 순수 JavaScript로 작업하려면 많은 양의 복잡한 코드를 직접 작성해야 합니다.        Java에서 사용하는 여러 외부 class 역시 모두 Library입니다. Java에서 랜덤값을 얻고싶을 때 우리는 Random class를이용해 instance를 생성하고 method를 호출해서 간단하게 원하는 범위의 랜덤값을 도출할 수 있습니다. 만약 Library를이용하지 않고 랜덤값을 구할려면 역시나 복잡한 로직과 연산을 우리가 직접 구현해야 됩니다.        비슷한 예로 Java에서 JSON 데이터를 처리할 때 역시 특정 Library class를 이용하면 쉽게 처리할 수 있습니다. 가장 대표적인 Library는 Jackson이 아닐까 합니다. 이 Library class들을 이용하면 프로그램에서 JSON 데이터를 아주 쉽게 핸들링 할 수 있습니다.  이렇듯 Library는 프로그램을 작성할 때 필요한 단위 기능을 모아놓은 모듈이라고 볼 수 있습니다. PlatformPlatform은 “Software를 실행시킬 수 있는 실행환경(Runtime Environment)”을 의미합니다.예를 들어 보자면, 우리가 사용하는 모든 OS(Operation System)는 모두 Platform입니다. Windows Platform은windows 응용 프로그램을 실행시키기 위한 실행 환경이고 Linux Platform은 Linux 응용 프로그램을 실행시키기 위한실행 환경이란 말이지요.Java 배울 때 처음에 JVM(Java Virtual Machine)이란 걸 배우게 됩니다. 우리가 작성한 모든 Java 프로그램은 JVM위에서 동작하게 됩니다. 다시 말하면 JVM은 Platform입니다. Java 프로그램을 실행시켜 줄 수 있는 실행 환경이란 말이지요.개념적으로 본다면 우리가 사용하는 Web이라는 서비스 역시 Platform 범주에 들어가게 됩니다. 정확하게는 Web 이라는 서비스가 아닌Web Server와 Web Client(browser)로 구성되는 실행환경이 우리가 작성한 Front-End Web Application이 실행되는 Platform 이라볼 수 있습니다.Java의 예에서 알 수 있듯이 Platform은 Hierarchical 구조를 가질 수 있습니다. 제일 하단에 OS Platform이 있고 그 위에 JVM이실행되는 것이죠. 다시 JVM은 Java 프로그램을 실행시킬 수 있는 Platform이 되고 그 위에 사용자가 작성한 Java 프로그램이실행되는 것입니다. Architecture알고는 있지만 딱히 설명하라면 어버버하게 만드는 개념입니다. Architecture는 소프트웨어의 특징을 결정짓는 설계 구조입니다. 말이 좀 어렵습니다.Architecture는 다음과 같은 내용을 포함합니다.      소프트웨어의 주요 구성 요소에 대한 정의가 포함됩니다. 소프트웨어의 주요 구성 요소란 소프트웨어를 구성하고 있는 컴포넌트 혹은 모듈을 의미합니다. 어떤 기능의 컴포넌트들이 소프트웨어에 필요한지를 구상해서 구성 요소를 정의합니다.( View Component, Service Component, Database Component, Transaction component, Message Component 등등)        이런 소프트웨어 주요 구성 요소들 간에 어떤식의 구성이 이루어지고 있는지 정의합니다. 한 컴포넌트가 다른 컴포넌트와 어떤 관계로 연결되는지에 대한 정의를 지칭한다고 보시면 됩니다. 일반적으로 유지보수성을높이기 위해 Layered Model을 기반으로 컴포넌트간의 연결 관계를 정의합니다.        결국 소프트웨어의 주요 구성 요소들 간에 연관관계가 맺어지는데 이들 간의 상호 인터페이스는 어떻게 할지를 정의합니다. 어떤 값이 넘어가고 이 값을 받아서 결과값으로 어떤 값을 리턴해주는지에 대한 명세를 포함합니다.        소프트웨어의 주요 구성 요소가 하는 중요한 동작 방식을 정의합니다.  위와 같은 내용으로 Architecture를 이해하시면 됩니다. Architecture는 결국 소프트웨어의 주요 특징을 결정하기 때문에 개발에 미치는 영향이 아주 높은 상당히 중요한 부분이라 볼 수 있습니다.Architecture에 대해 한가지 더 기억하셔야 할 점은 Architecture는 구체적인 구현을 포함하지 않습니다. 즉, 어떤 프로그래밍 언어를 사용할 것인지, Library는 어떤것을 사용할 것인지, 개발 지원 프로그램은 어떤것들을 이용할 것인지에 대한 내용은 Architecture에는 포함되지 않습니다. 하지만 특수한 경우 Architecture안에 구체적인 표현이 포함 될 수는 있습니다. 하지만 본질적으로 Architecture는 기술적인 설계를 명시하는 것이지 구체적인 구현 방법은 포함하지 않습니다. FrameworkFramework은 소프트웨어 프로젝트가 개발 될 수 있는 뼈대 구조를 지칭합니다. 역시 말이 좀 어려운데요. 다음과 같은 사항을포함합니다.  소프트웨어 개발시 필요한 지원프로그램  Library (Framework은 Library를 포함하는 상위개념입니다.)  프로그래밍 언어  소프트웨어 구성 요소들을 연결시켜주고 동작시켜주는 소프트웨어(일반적으로 Container라고 합니다.)Framework은 소프트웨어 구성 요소들이 어떻게 동작하는지에 대한 규약이 정해져 있습니다. 이 규약대로프로그램은 진행이 될 것이고 프로그래머는 기능 구현에만 초점을 맞추어 빠르게 개발을 진행 시킬 수 있습니다.Framework 도입의 가장 큰 목적 중 하나는 바로 유지보수입니다. 정해진 규칙대로 프로그램이 동작하고 작성되어야 하다보니다른 사람이 프로그램을 분석하는데 시간이 오래 걸리지 않고 유지보수하는것도 상대적으로 쉽게 진행이 됩니다. Library를기반으로 하는 프로그램은 모든 로직을 개발자가 직접 구현하기 때문에 다른 개발자가 유지보수하기 쉽지 않은 것에 비해Framework은 이런 유지보수 측면에서 강점을 가질 수 있습니다.개발 시 기본 골격이 되는 프로그램 코드가 제공되는것이 일반적인데 이 또한 Framework의 특징이라고 할 수 있습니다.( Scaffolding 이라고 합니다. )Framework부분은 사실 더 써야 하는 사항이 많습니다. 하지만 차이점 위주로 살펴본 것이니 위의 내용 정도만이해해도 충분하지 않을까 합니다.End.",
        "url": "/architecture-platform-terminology"
    }
    ,
    
    "browser-detect-script": {
        "title": "클라이언트 Browser 확인방법",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction사이트에 접속한 Client Web Browser의 종류를 알아내는 방법입니다. Client Browser를 확인하기 위한 JavaScript code제 블로그는 Chrome 전용입니다. IE를 이용하면 화면이 보란듯이 깨지게됩니다. 그래서 접속한 client의 browser를 알아내서 만약 chrome이 아니면 안내를 해 줄 필요가 있습니다.  실제 업무에서는 당연히 cross browsing을 염두에 두고 작업을 해야되겠죠?다음과 같은 JavaScript 코드를 이용하시면 됩니다.var agent = navigator.userAgent.toLowerCase();if (agent.indexOf(\"chrome\") != -1) {        alert(\"Chrome browser\");}if (agent.indexOf(\"safari\") != -1) {        alert(\"Safari browser\");}if (agent.indexOf(\"firefox\") != -1) {    alert(\"FireFox browser\");}JavaScript의 navigator객체를 조사하면 browser의 종류를 판별할 수 있습니다. IE 10까지는 저 위의 방법으로 알아낼 수 있으나 Edge와 그 이후 버전은 이름이 또 바뀌어서 다른 식으로 판단해야 합니다. 전 IE는 관심밖이라… userAgent 객체의 값 확인위의 방법은 가장 간단한 방법 중 하나입니다. Mobile browser까지 생각한다면 경우의 수가 훨씬 더 많아지겠죠.특정 사이트와 Chrome 확장 프로그램을 이용하면 간단하게 어떤 browser로 접속했을 때 userAgent객체에 어떤데이터가 들어가는지 확인해 볼 수 있습니다.그럼 간단히 한번 해 볼까요?먼저 크롬 웹 스토어에 접속해서user-agent switcher로 검색합니다. 확장 프로그램이 검색되는데 다음 그림과 같은 것을 설치합니다. (전 이미 설치되어 있습니다.)확장 프로그램이 설치되면 Chrome browser 우측 상단에 안경 모양의 아이콘이 보이실 겁니다. 그걸 누르면 다른 browser로 switching할 수 있습니다.자 이제 링크로 접속해 보시면 userAgent 객체의 값을보실 수 있습니다. user-agent switcher를 이용하여 다른 browser로 바꾸어서 접속하면 browser마다 userAgent값이 바뀌는 것을확인할 수 있습니다.아래 그림은 iPhone6로 browser를 switch한 후 사이트에 접속한 결과 화면입니다.추가적으로 해당 구현에 대한 소스코드까지 프로그래밍 언어별로 제공하고 있으니 필요하면 다운로드 받아서 사용하면 될 듯 싶습니다.여하간 제 블로그는 Chrome 전용이기 때문에 제가 사용하는 Jasper2 theme의 head.html에 저 위의 코드를적당히 수정해서 이용중입니다. 언제까지 이런 cross browsing issue에 시달려야하는지 안타깝습니다. ㅎㅎEnd.",
        "url": "/browser-detect-script"
    }
    ,
    
    "css-fontawesome-list": {
        "title": "Font Awesome Icon List",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction블로그나 사이트 작성 시 icon 이미지들이 많이 필요하게 되는데 이 아이콘을 마치 폰트처럼 사용할 수 있도록서비스를 제공하는 곳이 있습니다. Font Awesome이라는 곳인데 이 곳에서 제공하는 icon 리스트입니다. Font Awesome블로그나 사이트 작성 시 icon 이미지들이 많이 필요하게 됩니다. 과거에는 이미지를 찾아서 수정해서 쓰는 형식으로이용하였으나 근래에는 icon들을 font와 비슷하게 만들어서 마치 font처럼 icon을 사용할 수 있도록 제공하고 있습니다.이런 icon font는 Vector 이미지이기 때문에 크기에 상관없이 항상 선명한 화질을 보장받을 수 있고 font처럼 사용되다 보니 색상도 자유롭게 변경할 수 있다는 장점이 있습니다.이런 특징을 가지는 icon font를 제공하는 대표적인 사이트 중 하나가 바로 Font Awesome 입니다. Font Awesome의 폰트는 GPL 라이선스입니다. 사용방법자 그럼 우리 블로그에 어떻게 사용하면 되는지 한번 알아보도록 하죠제일 먼저 할일은 제공된 CDN을 이용해 style에 대한 링크를 걸어줍니다. &lt;head&gt; tag안에 명시하면 되겠죠? 제공된 CDN은 다음과 같습니다.&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"&gt;이제 적절한 style을 만들고 우리가 적용할 곳에 해당 style을 설정하면 됩니다. 아래의 style은 Font Awesome을 사용하기 위한 일반적인 예제 style입니다. 적절히 수정해서 사용하시면 됩니다..element {    position: relative;} .element:before {    content: \"\\f000\";    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    text-decoration: inherit;        color: #000;    font-size: 18px;    padding-right: 0.5em;    position: absolute;    top: 10px;    left: 0;} 아이콘 리스트위쪽 css의 content property에 명시하게 될 아이콘의 value값 입니다.만약 태그로 표현하고자 한다면 다음과 같은 형식을 이용합니다.&lt;i class=\"fa fa-glass\"&gt;&lt;/i&gt; fa-glass\"\\f000\" fa-music\"\\f001\" fa-search\"\\f002\" fa-envelope-o\"\\f003\" fa-heart\"\\f004\" fa-star\"\\f005\" fa-star-o\"\\f006\" fa-user\"\\f007\" fa-film\"\\f008\" fa-th-large\"\\f009\" fa-th\"\\f00a\" fa-th-list\"\\f00b\" fa-check\"\\f00c\" fa-times\"\\f00d\" fa-search-plus\"\\f00e\" fa-search-minus\"\\f010\" fa-power-off\"\\f011\" fa-signal\"\\f012\" fa-cog\"\\f013\" fa-trash-o\"\\f014\" fa-home\"\\f015\" fa-file-o\"\\f016\" fa-clock-o\"\\f017\" fa-road\"\\f018\" fa-download\"\\f019\" fa-arrow-circle-o-down\"\\f01a\" fa-arrow-circle-o-up\"\\f01b\" fa-inbox\"\\f01c\" fa-play-circle-o\"\\f01d\" fa-repeat\"\\f01e\" fa-refresh\"\\f021\" fa-list-alt\"\\f022\" fa-lock\"\\f023\" fa-flag\"\\f024\" fa-headphones\"\\f025\" fa-volume-off\"\\f026\" fa-volume-down\"\\f027\" fa-volume-up\"\\f028\" fa-qrcode\"\\f029\" fa-barcode\"\\f02a\" fa-tag\"\\f02b\" fa-tags\"\\f02c\" fa-book\"\\f02d\" fa-bookmark\"\\f02e\" fa-print\"\\f02f\" fa-camera\"\\f030\" fa-font\"\\f031\" fa-bold\"\\f032\" fa-italic\"\\f033\" fa-text-height\"\\f034\" fa-text-width\"\\f035\" fa-align-left\"\\f036\" fa-align-center\"\\f037\" fa-align-right\"\\f038\" fa-align-justify\"\\f039\" fa-list\"\\f03a\" fa-outdent\"\\f03b\" fa-indent\"\\f03c\" fa-video-camera\"\\f03d\" fa-picture-o\"\\f03e\" fa-pencil\"\\f040\" fa-map-marker\"\\f041\" fa-adjust\"\\f042\" fa-tint\"\\f043\" fa-pencil-square-o\"\\f044\" fa-share-square-o\"\\f045\" fa-check-square-o\"\\f046\" fa-arrows\"\\f047\" fa-step-backward\"\\f048\" fa-fast-backward\"\\f049\" fa-backward\"\\f04a\" fa-play\"\\f04b\" fa-pause\"\\f04c\" fa-stop\"\\f04d\" fa-forward\"\\f04e\" fa-fast-forward\"\\f050\" fa-step-forward\"\\f051\" fa-eject\"\\f052\" fa-chevron-left\"\\f053\" fa-chevron-right\"\\f054\" fa-plus-circle\"\\f055\" fa-minus-circle\"\\f056\" fa-times-circle\"\\f057\" fa-check-circle\"\\f058\" fa-question-circle\"\\f059\" fa-info-circle\"\\f05a\" fa-crosshairs\"\\f05b\" fa-times-circle-o\"\\f05c\" fa-check-circle-o\"\\f05d\" fa-ban\"\\f05e\" fa-arrow-left\"\\f060\" fa-arrow-right\"\\f061\" fa-arrow-up\"\\f062\" fa-arrow-down\"\\f063\" fa-share\"\\f064\" fa-expand\"\\f065\" fa-compress\"\\f066\" fa-plus\"\\f067\" fa-minus\"\\f068\" fa-asterisk\"\\f069\" fa-exclamation-circle\"\\f06a\" fa-gift\"\\f06b\" fa-leaf\"\\f06c\" fa-fire\"\\f06d\" fa-eye\"\\f06e\" fa-eye-slash\"\\f070\" fa-exclamation-triangle\"\\f071\" fa-plane\"\\f072\" fa-calendar\"\\f073\" fa-random\"\\f074\" fa-comment\"\\f075\" fa-magnet\"\\f076\" fa-chevron-up\"\\f077\" fa-chevron-down\"\\f078\" fa-retweet\"\\f079\" fa-shopping-cart\"\\f07a\" fa-folder\"\\f07b\" fa-folder-open\"\\f07c\" fa-arrows-v\"\\f07d\" fa-arrows-h\"\\f07e\" fa-bar-chart\"\\f080\" fa-twitter-square\"\\f081\" fa-facebook-square\"\\f082\" fa-camera-retro\"\\f083\" fa-key\"\\f084\" fa-cogs\"\\f085\" fa-comments\"\\f086\" fa-thumbs-o-up\"\\f087\" fa-thumbs-o-down\"\\f088\" fa-star-half\"\\f089\" fa-heart-o\"\\f08a\" fa-sign-out\"\\f08b\" fa-linkedin-square\"\\f08c\" fa-thumb-tack\"\\f08d\" fa-external-link\"\\f08e\" fa-sign-in\"\\f090\" fa-trophy\"\\f091\" fa-github-square\"\\f092\" fa-upload\"\\f093\" fa-lemon-o\"\\f094\" fa-phone\"\\f095\" fa-square-o\"\\f096\" fa-bookmark-o\"\\f097\" fa-phone-square\"\\f098\" fa-twitter\"\\f099\" fa-facebook\"\\f09a\" fa-github\"\\f09b\" fa-unlock\"\\f09c\" fa-credit-card\"\\f09d\" fa-rss\"\\f09e\" fa-hdd-o\"\\f0a0\" fa-bullhorn\"\\f0a1\" fa-bell\"\\f0f3\" fa-certificate\"\\f0a3\" fa-hand-o-right\"\\f0a4\" fa-hand-o-left\"\\f0a5\" fa-hand-o-up\"\\f0a6\" fa-hand-o-down\"\\f0a7\" fa-arrow-circle-left\"\\f0a8\" fa-arrow-circle-right\"\\f0a9\" fa-arrow-circle-up\"\\f0aa\" fa-arrow-circle-down\"\\f0ab\" fa-globe\"\\f0ac\" fa-wrench\"\\f0ad\" fa-tasks\"\\f0ae\" fa-filter\"\\f0b0\" fa-briefcase\"\\f0b1\" fa-arrows-alt\"\\f0b2\" fa-users\"\\f0c0\" fa-link\"\\f0c1\" fa-cloud\"\\f0c2\" fa-flask\"\\f0c3\" fa-scissors\"\\f0c4\" fa-files-o\"\\f0c5\" fa-paperclip\"\\f0c6\" fa-floppy-o\"\\f0c7\" fa-square\"\\f0c8\" fa-bars\"\\f0c9\" fa-list-ul\"\\f0ca\" fa-list-ol\"\\f0cb\" fa-strikethrough\"\\f0cc\" fa-underline\"\\f0cd\" fa-table\"\\f0ce\" fa-magic\"\\f0d0\" fa-truck\"\\f0d1\" fa-pinterest\"\\f0d2\" fa-pinterest-square\"\\f0d3\" fa-google-plus-square\"\\f0d4\" fa-google-plus\"\\f0d5\" fa-money\"\\f0d6\" fa-caret-down\"\\f0d7\" fa-caret-up\"\\f0d8\" fa-caret-left\"\\f0d9\" fa-caret-right\"\\f0da\" fa-columns\"\\f0db\" fa-sort\"\\f0dc\" fa-sort-desc\"\\f0dd\" fa-sort-asc\"\\f0de\" fa-envelope\"\\f0e0\" fa-linkedin\"\\f0e1\" fa-undo\"\\f0e2\" fa-gavel\"\\f0e3\" fa-tachometer\"\\f0e4\" fa-comment-o\"\\f0e5\" fa-comments-o\"\\f0e6\" fa-bolt\"\\f0e7\" fa-sitemap\"\\f0e8\" fa-umbrella\"\\f0e9\" fa-clipboard\"\\f0ea\" fa-lightbulb-o\"\\f0eb\" fa-exchange\"\\f0ec\" fa-cloud-download\"\\f0ed\" fa-cloud-upload\"\\f0ee\" fa-user-md\"\\f0f0\" fa-stethoscope\"\\f0f1\" fa-suitcase\"\\f0f2\" fa-bell-o\"\\f0a2\" fa-coffee\"\\f0f4\" fa-cutlery\"\\f0f5\" fa-file-text-o\"\\f0f6\" fa-building-o\"\\f0f7\" fa-hospital-o\"\\f0f8\" fa-ambulance\"\\f0f9\" fa-medkit\"\\f0fa\" fa-fighter-jet\"\\f0fb\" fa-beer\"\\f0fc\" fa-h-square\"\\f0fd\" fa-plus-square\"\\f0fe\" fa-angle-double-left\"\\f100\" fa-angle-double-right\"\\f101\" fa-angle-double-up\"\\f102\" fa-angle-double-down\"\\f103\" fa-angle-left\"\\f104\" fa-angle-right\"\\f105\" fa-angle-up\"\\f106\" fa-angle-down\"\\f107\" fa-desktop\"\\f108\" fa-laptop\"\\f109\" fa-tablet\"\\f10a\" fa-mobile\"\\f10b\" fa-circle-o\"\\f10c\" fa-quote-left\"\\f10d\" fa-quote-right\"\\f10e\" fa-spinner\"\\f110\" fa-circle\"\\f111\" fa-reply\"\\f112\" fa-github-alt\"\\f113\" fa-folder-o\"\\f114\" fa-folder-open-o\"\\f115\" fa-smile-o\"\\f118\" fa-frown-o\"\\f119\" fa-meh-o\"\\f11a\" fa-gamepad\"\\f11b\" fa-keyboard-o\"\\f11c\" fa-flag-o\"\\f11d\" fa-flag-checkered\"\\f11e\" fa-terminal\"\\f120\" fa-code\"\\f121\" fa-reply-all\"\\f122\" fa-star-half-o\"\\f123\" fa-location-arrow\"\\f124\" fa-crop\"\\f125\" fa-code-fork\"\\f126\" fa-chain-broken\"\\f127\" fa-question\"\\f128\" fa-info\"\\f129\" fa-exclamation\"\\f12a\" fa-superscript\"\\f12b\" fa-subscript\"\\f12c\" fa-eraser\"\\f12d\" fa-puzzle-piece\"\\f12e\" fa-microphone\"\\f130\" fa-microphone-slash\"\\f131\" fa-shield\"\\f132\" fa-calendar-o\"\\f133\" fa-fire-extinguisher\"\\f134\" fa-rocket\"\\f135\" fa-maxcdn\"\\f136\" fa-chevron-circle-left\"\\f137\" fa-chevron-circle-right\"\\f138\" fa-chevron-circle-up\"\\f139\" fa-chevron-circle-down\"\\f13a\" fa-html5\"\\f13b\" fa-css3\"\\f13c\" fa-anchor\"\\f13d\" fa-unlock-alt\"\\f13e\" fa-bullseye\"\\f140\" fa-ellipsis-h\"\\f141\" fa-ellipsis-v\"\\f142\" fa-rss-square\"\\f143\" fa-play-circle\"\\f144\" fa-ticket\"\\f145\" fa-minus-square\"\\f146\" fa-minus-square-o\"\\f147\" fa-level-up\"\\f148\" fa-level-down\"\\f149\" fa-check-square\"\\f14a\" fa-pencil-square\"\\f14b\" fa-external-link-square\"\\f14c\" fa-share-square\"\\f14d\" fa-compass\"\\f14e\" fa-caret-square-o-down\"\\f150\" fa-caret-square-o-up\"\\f151\" fa-caret-square-o-right\"\\f152\" fa-eur\"\\f153\" fa-gbp\"\\f154\" fa-usd\"\\f155\" fa-inr\"\\f156\" fa-jpy\"\\f157\" fa-rub\"\\f158\" fa-krw\"\\f159\" fa-btc\"\\f15a\" fa-file\"\\f15b\" fa-file-text\"\\f15c\" fa-sort-alpha-asc\"\\f15d\" fa-sort-alpha-desc\"\\f15e\" fa-sort-amount-asc\"\\f160\" fa-sort-amount-desc\"\\f161\" fa-sort-numeric-asc\"\\f162\" fa-sort-numeric-desc\"\\f163\" fa-thumbs-up\"\\f164\" fa-thumbs-down\"\\f165\" fa-youtube-square\"\\f166\" fa-youtube\"\\f167\" fa-xing\"\\f168\" fa-xing-square\"\\f169\" fa-youtube-play\"\\f16a\" fa-dropbox\"\\f16b\" fa-stack-overflow\"\\f16c\" fa-instagram\"\\f16d\" fa-flickr\"\\f16e\" fa-adn\"\\f170\" fa-bitbucket\"\\f171\" fa-bitbucket-square\"\\f172\" fa-tumblr\"\\f173\" fa-tumblr-square\"\\f174\" fa-long-arrow-down\"\\f175\" fa-long-arrow-up\"\\f176\" fa-long-arrow-left\"\\f177\" fa-long-arrow-right\"\\f178\" fa-apple\"\\f179\" fa-windows\"\\f17a\" fa-android\"\\f17b\" fa-linux\"\\f17c\" fa-dribbble\"\\f17d\" fa-skype\"\\f17e\" fa-foursquare\"\\f180\" fa-trello\"\\f181\" fa-female\"\\f182\" fa-male\"\\f183\" fa-gratipay\"\\f184\" fa-sun-o\"\\f185\" fa-moon-o\"\\f186\" fa-archive\"\\f187\" fa-bug\"\\f188\" fa-vk\"\\f189\" fa-weibo\"\\f18a\" fa-renren\"\\f18b\" fa-pagelines\"\\f18c\" fa-stack-exchange\"\\f18d\" fa-arrow-circle-o-right\"\\f18e\" fa-arrow-circle-o-left\"\\f190\" fa-caret-square-o-left\"\\f191\" fa-dot-circle-o\"\\f192\" fa-wheelchair\"\\f193\" fa-vimeo-square\"\\f194\" fa-try\"\\f195\" fa-plus-square-o\"\\f196\" fa-space-shuttle\"\\f197\" fa-slack\"\\f198\" fa-envelope-square\"\\f199\" fa-wordpress\"\\f19a\" fa-openid\"\\f19b\" fa-university\"\\f19c\" fa-graduation-cap\"\\f19d\" fa-yahoo\"\\f19e\" fa-google\"\\f1a0\" fa-reddit\"\\f1a1\" fa-reddit-square\"\\f1a2\" fa-stumbleupon-circle\"\\f1a3\" fa-stumbleupon\"\\f1a4\" fa-delicious\"\\f1a5\" fa-digg\"\\f1a6\" fa-pied-piper\"\\f1a7\" fa-pied-piper-alt\"\\f1a8\" fa-drupal\"\\f1a9\" fa-joomla\"\\f1aa\" fa-language\"\\f1ab\" fa-fax\"\\f1ac\" fa-building\"\\f1ad\" fa-child\"\\f1ae\" fa-paw\"\\f1b0\" fa-spoon\"\\f1b1\" fa-cube\"\\f1b2\" fa-cubes\"\\f1b3\" fa-behance\"\\f1b4\" fa-behance-square\"\\f1b5\" fa-steam\"\\f1b6\" fa-steam-square\"\\f1b7\" fa-recycle\"\\f1b8\" fa-car\"\\f1b9\" fa-taxi\"\\f1ba\" fa-tree\"\\f1bb\" fa-spotify\"\\f1bc\" fa-deviantart\"\\f1bd\" fa-soundcloud\"\\f1be\" fa-database\"\\f1c0\" fa-file-pdf-o\"\\f1c1\" fa-file-word-o\"\\f1c2\" fa-file-excel-o\"\\f1c3\" fa-file-powerpoint-o\"\\f1c4\" fa-file-image-o\"\\f1c5\" fa-file-archive-o\"\\f1c6\" fa-file-audio-o\"\\f1c7\" fa-file-video-o\"\\f1c8\" fa-file-code-o\"\\f1c9\" fa-vine\"\\f1ca\" fa-codepen\"\\f1cb\" fa-jsfiddle\"\\f1cc\" fa-life-ring\"\\f1cd\" fa-circle-o-notch\"\\f1ce\" fa-rebel\"\\f1d0\" fa-empire\"\\f1d1\" fa-git-square\"\\f1d2\" fa-git\"\\f1d3\" fa-hacker-news\"\\f1d4\" fa-tencent-weibo\"\\f1d5\" fa-qq\"\\f1d6\" fa-weixin\"\\f1d7\" fa-paper-plane\"\\f1d8\" fa-paper-plane-o\"\\f1d9\" fa-history\"\\f1da\" fa-circle-thin\"\\f1db\" fa-header\"\\f1dc\" fa-paragraph\"\\f1dd\" fa-sliders\"\\f1de\" fa-share-alt\"\\f1e0\" fa-share-alt-square\"\\f1e1\" fa-bomb\"\\f1e2\" fa-futbol-o\"\\f1e3\" fa-tty\"\\f1e4\" fa-binoculars\"\\f1e5\" fa-plug\"\\f1e6\" fa-slideshare\"\\f1e7\" fa-twitch\"\\f1e8\" fa-yelp\"\\f1e9\" fa-newspaper-o\"\\f1ea\" fa-wifi\"\\f1eb\" fa-calculator\"\\f1ec\" fa-paypal\"\\f1ed\" fa-google-wallet\"\\f1ee\" fa-cc-visa\"\\f1f0\" fa-cc-mastercard\"\\f1f1\" fa-cc-discover\"\\f1f2\" fa-cc-amex\"\\f1f3\" fa-cc-paypal\"\\f1f4\" fa-cc-stripe\"\\f1f5\" fa-bell-slash\"\\f1f6\" fa-bell-slash-o\"\\f1f7\" fa-trash\"\\f1f8\" fa-copyright\"\\f1f9\" fa-at\"\\f1fa\" fa-eyedropper\"\\f1fb\" fa-paint-brush\"\\f1fc\" fa-birthday-cake\"\\f1fd\" fa-area-chart\"\\f1fe\" fa-pie-chart\"\\f200\" fa-line-chart\"\\f201\" fa-lastfm\"\\f202\" fa-lastfm-square\"\\f203\" fa-toggle-off\"\\f204\" fa-toggle-on\"\\f205\" fa-bicycle\"\\f206\" fa-bus\"\\f207\" fa-ioxhost\"\\f208\" fa-angellist\"\\f209\" fa-cc\"\\f20a\" fa-ils\"\\f20b\" fa-meanpath\"\\f20c\" fa-buysellads\"\\f20d\" fa-connectdevelop\"\\f20e\" fa-dashcube\"\\f210\" fa-forumbee\"\\f211\" fa-leanpub\"\\f212\" fa-sellsy\"\\f213\" fa-shirtsinbulk\"\\f214\" fa-simplybuilt\"\\f215\" fa-skyatlas\"\\f216\" fa-cart-plus\"\\f217\" fa-cart-arrow-down\"\\f218\" fa-diamond\"\\f219\" fa-ship\"\\f21a\" fa-user-secret\"\\f21b\" fa-motorcycle\"\\f21c\" fa-street-view\"\\f21d\" fa-heartbeat\"\\f21e\" fa-venus\"\\f221\" fa-mars\"\\f222\" fa-mercury\"\\f223\" fa-transgender\"\\f224\" fa-transgender-alt\"\\f225\" fa-venus-double\"\\f226\" fa-mars-double\"\\f227\" fa-venus-mars\"\\f228\" fa-mars-stroke\"\\f229\" fa-mars-stroke-v\"\\f22a\" fa-mars-stroke-h\"\\f22b\" fa-neuter\"\\f22c\" fa-genderless\"\\f22d\" fa-facebook-official\"\\f230\" fa-pinterest-p\"\\f231\" fa-whatsapp\"\\f232\" fa-server\"\\f233\" fa-user-plus\"\\f234\" fa-user-times\"\\f235\" fa-bed\"\\f236\" fa-viacoin\"\\f237\" fa-train\"\\f238\" fa-subway\"\\f239\" fa-medium\"\\f23a\" fa-y-combinator\"\\f23b\" fa-optin-monster\"\\f23c\" fa-opencart\"\\f23d\" fa-expeditedssl\"\\f23e\" fa-battery-full\"\\f240\" fa-battery-three-quarters\"\\f241\" fa-battery-half\"\\f242\" fa-battery-quarter\"\\f243\" fa-battery-empty\"\\f244\" fa-mouse-pointer\"\\f245\" fa-i-cursor\"\\f246\" fa-object-group\"\\f247\" fa-object-ungroup\"\\f248\" fa-sticky-note\"\\f249\" fa-sticky-note-o\"\\f24a\" fa-cc-jcb\"\\f24b\" fa-cc-diners-club\"\\f24c\" fa-clone\"\\f24d\" fa-balance-scale\"\\f24e\" fa-hourglass-o\"\\f250\" fa-hourglass-start\"\\f251\" fa-hourglass-half\"\\f252\" fa-hourglass-end\"\\f253\" fa-hourglass\"\\f254\" fa-hand-rock-o\"\\f255\" fa-hand-paper-o\"\\f256\" fa-hand-scissors-o\"\\f257\" fa-hand-lizard-o\"\\f258\" fa-hand-spock-o\"\\f259\" fa-hand-pointer-o\"\\f25a\" fa-hand-peace-o\"\\f25b\" fa-trademark\"\\f25c\" fa-registered\"\\f25d\" fa-creative-commons\"\\f25e\" fa-gg\"\\f260\" fa-gg-circle\"\\f261\" fa-tripadvisor\"\\f262\" fa-odnoklassniki\"\\f263\" fa-odnoklassniki-square\"\\f264\" fa-get-pocket\"\\f265\" fa-wikipedia-w\"\\f266\" fa-safari\"\\f267\" fa-chrome\"\\f268\" fa-firefox\"\\f269\" fa-opera\"\\f26a\" fa-internet-explorer\"\\f26b\" fa-television\"\\f26c\" fa-contao\"\\f26d\" fa-500px\"\\f26e\" fa-amazon\"\\f270\" fa-calendar-plus-o\"\\f271\" fa-calendar-minus-o\"\\f272\" fa-calendar-times-o\"\\f273\" fa-calendar-check-o\"\\f274\" fa-industry\"\\f275\" fa-map-pin\"\\f276\" fa-map-signs\"\\f277\" fa-map-o\"\\f278\" fa-map\"\\f279\" fa-commenting\"\\f27a\" fa-commenting-o\"\\f27b\" fa-houzz\"\\f27c\" fa-vimeo\"\\f27d\" fa-black-tie\"\\f27e\" fa-fonticons\"\\f280\"",
        "url": "/css-fontawesome-list"
    }
    ,
    
    "jekyll-gist": {
        "title": "Jekyll 기반의 GitHub Page 생성(7)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 GitHub Gist 활용GitHub의 Gist에 대해서 잘 알지 못하시는 분은 여기를 클릭하셔서 간단하게 Gist에 대한 이해를 하고 오시면 됩니다.그럼 설치부터 천천히 알아보도록 하죠.먼저 gist를 사용할 수 있도록 gem을 설치해야 합니다. 아래와 같이 command 창에서 명령어를 입력합니다.  gem install jekyll-gistgem 설치가 끝나면 _config.yml을 수정해야 합니다.아래의 코드는 저의 _config.yml입니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 10# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Blog# 자신의 blog title.description: Development &amp; Technical Training# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: sunghoons-blog# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics:  # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]exclude: [vendor]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source: destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안으로 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.production_url:  https://moon9342.github.io/source_url:  https://github.com/moon9342/GitHubPageMaker/# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules는 포함시키자)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules위의 코드는 gist를 이용하여 불러온 코드입니다.중간쯤에plugins: [jekyll-paginate, jekyll-feed, jekyll-gist]부분처럼 설치한 jekyll-gist를추가시킵니다.그리고 포스트를 하나 생성해서 다음과 같은 구문을 이용하여 gist를 불러오면 됩니다.gist를 불러올 때 JavaScript 링크를 붙였넣는것이 아닙니다. 만약 불러올 링크가 아래와 같으면&lt;script src=\"https://gist.github.com/moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e.js\"&gt;&lt;/script&gt;여기에서moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e부분만 이용합니다. 즉, 아래와 같이 불러오시면 됩니다.{% gist moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e %} 오류 해결한방에 된다면 좋겠지만 잘 안될 수 있습니다.가장 많이 나는 오류는 SSL_connect 오류입니다. Windows 10 사용자들은 다음과 같은 오류가 높은 확률로 발생합니다.  SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed에러 메시지를 보니 그냥 해결할 수 있는 종류가 아닌 듯 보입니다. Stack Overflow 사이트에서 찾아보면 몇가지 해결 방안을 발견할 수 있습니다.command 창을 열고 다음과 같이 하나하나 실행 하시면 됩니다.  gem update --system  gem install rubygems-update  update_rubygems위의 과정은 RubyGem을 최신으로 upgrade 시키는 작업입니다.그런 다음 링크를 클릭해서 파일 하나를 다운로드 받습니다. 이 파일은 .pem 파일로 certificate 역할을 하는 파일입니다.파일을 다운로드해서 적절한 위치에 복사합니다. (원하는 폴더에 저장해놓으면 됩니다.)저는 D:/myRuby 폴더를 생성하고 이 안에 해당 파일을 복사해 넣었습니다. 파일이름은 cacert.pem이라고 했습니다.이제 시스템 환경변수를 하나 생성합니다. 환경변수 이름은 SSL_CERT_FILE로 하셔야 하며 환경변수의 값으로파일에 대한 절대경로를 넣어줍니다. 저같은 경우는 D:/myRuby/cacert.pem로 설정해야 겠네요.여기까지 진행했으면 command 창을 다시 열어서(환경변수가 변경되었으니 다시 열어야죠!) 블로그를 다시 build 하시면 됩니다.SSL_connect 문제에 대한 보다 자세한 설명은 링크에서 확인하실 수 있습니다.위와 같이 해서 Code Snippet을 원하는 곳에 붙여 사용할 수 있습니다. gist에서 제공하는default theme가 맘에 안드시면 다음의 CUSTOMIZING GITHUB GISTS를 방문해 보세요. 조금만 살펴보시면 원하는 style로 gist를 사용하실 수 있습니다.End.",
        "url": "/jekyll-gist"
    }
    ,
    
    "github-gist": {
        "title": "What is GitHub Gist?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionCode Snippet을 관리하기 위한 도구입니다. 블로그로 IT 관련 포스팅을 하는 사람들에게는 굉장히 유용한 도구로사용이 됩니다. Gist는 우리나라말로 “지스트”라고 발음하며 GitHub에서 서비스 하고 있습니다.만일 Gist에 대해서는 알고 있고 jekyll기반의 GitHub Page에서 사용하는 방법에 대해서 알고 싶으신 분은 여기를 참조하세요! Code Snippet 관리IT 개발관련 블로그를 운영하다보면 여러 코드조각들을 블로그에 같이 올리게됩니다. 어떤 경우는 말 그대로 완성되지 않은“코드조각” 형태의 코드를 올리기도 하고 어떤 경우는 완성된 형태의 코드를 올리기도 합니다.텍스트 형태로 그냥 포스팅을 하면 보기가 너무 좋지 않으니 일반적으로 Syntax Highlighter를 많이 이용하게 됩니다. 다양한 종류의 Syntax Highlighter가 있고 이를 이용하면 보기 좋게 코드들을 블로그에 올릴 수 있습니다.설명을 하기 위한 코드조각들은 일반적으로 수정이나 공유의 빈도가 상대적으로 적기 때문에 그냥 Rouge와 같은Syntax Highlighter를 이용하여 올리면 편합니다. 하지만 완성된 코드를 포스팅하는 경우 추후에 기능의 보완이라든지오류에 대한 수정같은 이슈가 생길 수 있고 이렇게 변경된 코드는 다른 사람과 공유할 때 문제가 발생할 수 밖에 없습니다.하나의 완성된 코드를 블로그 여기저기에서 가져다가 쓰는 경우 역시 마찬가지의 이슈가 발생할 수 있겠죠.결국 “YouTube에 동영상을 올리고 블로그에 삽입하는 것처럼 이런 코드조각들도 그렇게 관리하고 공유하면 편하겠다” 라고 사람들이 생각하게 되고 이를 위한 온라인 서비스도 여러 개 생기게 되었는데 그 중 하나가 GitHub에서 제공하는 Gist입니다.결론적으로 Gist는 Code Snippet을 관리하고 공유하도록 도와주는 서비스라고 생각하시면 됩니다. 사용방법사용방법은 상당히 간단합니다. 일단 GitHub에 로그인해서 노란색 영역을 클릭하시면다음과 같은 화면을 보실 수 있습니다.New gist 메뉴를 선택하면 Code Snippet을 생성할 수 있는 화면으로 전환됩니다.코드 내용을 입력하고 public 혹은 secret 형태로 gist를 생성합니다.생성이 되면 아마 다음과 같은 화면을 보실 수 있을텐데 이렇게 작성된 gist를 블로그에올리려면 Embed라고 되어있는 JavaScript link code를 가져다가 블로그에 삽입하면 됩니다.실제로 한번 작업해 보시면 자신이 작성한 Code Snippet을 블로그에 쉽게 포함 시킬 수있으실 겁니다.저는 Jekyll기반의 GitHub Page에서 블로그를 운영하고 있기 때문에 조금 다른 방식을 이용합니다.Liquid template을 이용해서 블로그에 포함시키는 방법을 이용합니다.이 방식에 대해서는 여기를 참조하세요!End.",
        "url": "/github-gist"
    }
    ,
    
    "i18n-l10n": {
        "title": "What is i18n, l10n?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction국제화와 지역화 작업을 의미하는 i18n과 l10n에 대해서 알아보도록 하겠습니다. i18n, l10ni18n은 internationalization(국제화)를 표현한 것입니다. 첫글자인 i와 마지막 글자인 n사이에 18개의 글자가 있다고해서 저렇게 표현한 겁니다. 아마 IT쪽에 관심이 있는 사람이라면 i18n이 어떤 약자인지는 몰랐어도 국제화라는걸 알고는 있었으리라생각됩니다.l10n역시 마찬가지로 localization(현지화)를 표현한 것입니다. 첫글자인 l과 마지막 글자인 n사이에 10개의 글자가 있다라는 것이겠죠?일반적으로 우리가 작성한 프로그램을 다른 언어로 출시할때는 당연히 해당 언어로 현지화를 진행해야 합니다. 내용의 번역부터 시작해서각종 단위(통화단위, 도량형 단위, 숫자의 표현, 날짜표현 양식 등)의 변환등을 의미하겠죠. 하지만 현지화의 가장 중요한 점은 타겟문화에 맞도록 컨텐츠를 조절하는 것입니다. 이게 힘든 작업이죠. 개발자에게 맡기면 산으로 갑니다. (^^)여하간 이런 현지화를 다른 여러 타겟(여러 나라)를 대상으로 우리의 프로그램을 조정하는 작업이 바로 i18n support라고 불리는 국제화작업이라고 보시면 될 듯 합니다.그냥 그렇다구요.i18n 작업을 할 때 주의해야 할 점에 대해서는 다른 훌륭한 포스트들을 참조해주세요~ 사실 저도작업 경험이 딱 한번 있습니다. (하고 싶지 않아요.. 할 생각도 없구요)End.",
        "url": "/i18n-l10n"
    }
    ,
    
    "typescript-interface": {
        "title": "TypeScript 강좌(6) - Interface",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Interfaceinterface는 우리가 알고 있는 Java의 interface와 문법적으로 유사합니다. 하지만 객체지향에서 말하는 interface와는의미적으로 좀 차이가 있습니다. 그 부분은 예제 중간중간에 살펴보기로 하고 지금은 TypeScript의 interface 에 대해서만 살펴보도록 하겠습니다.TypeScript에서 interface는 새로운 데이터 타입을 만드는 추상 데이터 타입(abstract data type)으로 사용이 되며일반 변수, 함수, 클래스의 type check를 위해 사용됩니다. interface 이용하여 타입을 선언하면 interface안에 명시된 property의 선언과 method의 구현이 강제되기 때문에 프로그래밍의 일관성을 확보할 수 있습니다.참고로 ES6는 interface를 지원하지 않습니다. TypeScript만 지원합니다. 그렇기 때문에 interface를 컴파일 한 결과물을 보면 interface의 내용은 나타나지 않게됩니다. Basic Exam그럼 간단한 예를 통해 알아보도록 하겠습니다.interface IBook {    bookName: string;    bookAuthor: string;}let myBook: IBook;myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};console.log(myBook);해당 .ts 파일을 컴파일 한 결과 .js 파일을 살펴보면 다음과 같습니다.\"use strict\";var myBook;myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};console.log(myBook);위에서 언급한 대로 interface에 대한 내용은 포함되어 있지 않습니다. TypeScript의 interface는 type check를 위한용도로 사용되게 됩니다. Parameter Type Check비슷한 용도로 함수의 인자를 넘길 때 인자의 type으로 interface를 이용할 수 있습니다. 아래의 예를 한번 살펴보죠.interface IBook {    bookName: string;    bookAuthor: string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);}let myBook: IBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};printBookInfo(myBook);굳이 설명할 것도 없는거 같습니다. printBookInfo()의 인자로 interface type의 객체가 전달되어사용된 것이죠.여기까지는 별 문제 없이 이해할 수 있습니다. 이제 그 다음이 살짝 이상합니다. Duck Typing아래의 코드에서 문법 오류가 일어날까요?interface IBook {    bookName: string;    bookAuthor: string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);}let myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\",    bookPrice: 3000};printBookInfo(myBook);원래 예상대로라면 이 코드는 문제가 있는 것이 맞습니다. myBook이라는 객체는 IBook interface type으로 지정되지 않고 parameter로 전달이 되었거든요. 하지만 이 코드는 에러없이 컴파일이 진행됩니다.왜 이런 현상이 발생할까요?TypeScript의 중요한 원칙 중 하나는 가지고 있는 값들의 형태를 가지고 type-checking을 수행한다는 것입니다. 말이 좀 어렵네요. 풀어서 설명하자면 TypeScript에서 type-checking은 선언된 타입만을 비교하는것이 아니라 실제 이용될 수 있는 형태의 값들을 가지고 있느냐 그렇지 않느냐를 가지고 한다는 의미입니다.위의 예제에서 myBook 객체는 비록 IBook interface type은 아니지만 IBook interface type을 모두 커버할 수 있는 값들의 형태를가지고 있습니다. 이런 경우 myBook 객체는 IBook interface 타입으로 간주한다는 말이지요.이런걸 동적 typing의 한 종류인 duck typing이라고 합니다. TypeScript는 duck typing을 지원하는 언어입니다. 일반적으로말하자면 class의 상속이나 interface의 구현으로 타입을 구분하는 것이 아니라 객체가 특정 타입에 걸맞는 property와 method를 가지고 있으면 해당 type으로 간주한다는 의미로 받아들이시면 됩니다.해서 저 위의 코드는 에러없이 사용할 수 있습니다. Optional PropertiesTypeScript interface의 모든 property와 method는 구현하는 클래스 혹은 구현 객체에서 기본적으로 모두 재정의되어야 합니다. 하지만 Optional Property( property 중 ? 가 붙어있는 property를 의미합니다. )를 이용하면 해당 property는 재정의하지 않아도 상관없습니다. 즉, 선택적으로 구현여부를 결정할 수 있는 property가 optional property입니다.아래의 예를 가지고 살펴보겠습니다.interface IBook {    bookName: string;    bookAuthor: string;    bookISBN?: string;   // Optional Property    getName(): string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);    console.log(paramBook.getName());}let myBook: IBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\",    getName: function() {       return this.bookName;    }};printBookInfo(myBook); Readonly Propertiesreadonly keyword를 이용해 객체가 처음 생성되는 시점에만 property들을 수정가능하도록 설정할 수 있습니다.한번 값이 세팅되면 그 후에는 수정할 수 없게됩니다.interface Point {    readonly x: number;    y: number;}let p1: Point = { x: 10, y: 20 };p1.x = 100;    // 오류 발생TypeScript는 또 ReadonlyArray&lt;T&gt; 형태의 Array를 지원합니다. 이름에서 의미하는 것처럼 생성된 후에는Array를 변경할 수 없습니다.let arr: number[] = [1, 2, 3, 4];let roArray: ReadonlyArray&lt;number&gt; = arr;roArray[0] = 100;   // 코드 에러roArray.push(100);  // 코드 에러arr = roArray;             // 코드 에러arr = roArray as number[]; // 가능위의 코드도 쉽게 이해할 수 있습니다. 마지막 코드 정도만 주의하면 될 듯 합니다.이렇게 readonly property는 const와 비슷한 역할을 하게됩니다. 단 const는 변수의 선언에사용되며 readonly는 property 지정에 사용된다는 점만 기억하시면 됩니다. Function Typesinterface는 function의 type을 지정하는데 사용할 수 있습니다. 이 경우 parameter의 리스트와리턴타입만을 가지고 있는 함수의 선언과 비슷한 형태를 가지게 됩니다. 아래의 예를 보죠.interface myInterface {    (myName: string, myAge: number): void;}let myFunc: myInterface = function(myName:string, myAge:number): void {    console.log(`이름 : ${myName}, 나이 : ${myAge}`);};myFunc(\"홍길동\",30); Indexable TypesJavaScript의 객체를 사용하기 위해서는 일반적으로 \".\" operator를 이용합니다. 일반적인 객체지향언어에서객체를 사용하는 방식이죠. JavaScript는 추가적으로 객체를 사용하는 방법으로 배열방식을 이용할 수 있습니다.다음과 같이 사용합니다.아래의 코드는 JavaScript 코드입니다.let obj = {    myName: '홍길동',    myAddress: '서울'};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}위의 코드는 문법에러가 발생하지 않고 결과도 잘 출력이 됩니다. obj 객체에 접근할 때[ ] 형태를 이용해서 key값에 접근해서 value값을 출력하는 간단한 예제입니다.하지만 이 코드를 TypeScript로 작성하면 코드에러가 발생합니다. 해당 파일에 대한 확장자만.js에서 .ts로 변경해보면 obj[keys[i]에서 다음과 같은 에러가 발생하는 것을 볼 수 있습니다.Element implicitly has an 'any' type because type '{ myName: string; myAddress: string; }' has no index signature.쉽게 말하면 index signature를 이용하지 않았기 때문에 property에 접근할 때 어떤 타입인지를 확인할 수 없어서 묵시적으로 any 타입을 이용하게 된다는 의미입니다. 하지만 우리는 TypeScriptcompiler 옵션 중 noImplicitAny 속성을 true로 해 놓았기 때문에 문제가 발생하는 것입니다.(noImplicitAny: true가 default로 설정됩니다.)해결하기 위해서는 컴파일러 옵션을 수정하던지 아니면 interface를 이용하여 index signature를 설정해 type을명시적으로 알려주면 됩니다.컴파일러 옵션을 수정하는 방법은 tsconfig.json 설정에서 \"noImplicitAny\": false 옵션을 추가하시면 됩니다. 하지만 좋지 않습니다. any 타입은 특별한 이유가 있지 않는 한 가능한 사용하지 않는게 좋고 명시적으로 타입을 지정해서 사용하셔야 합니다.좀 더 좋은 해결책은 interface로 index signature를 설정해서 사용하는 것입니다. 이걸 Indexable Type이라고 합니다.아래의 코드처럼 interface를 이용해 index signature를 설정합니다.interface IObj {    [idx: string]: string;}let obj: IObj = {    myName: '홍길동',    myAddress: '서울'};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}추가적으로 union type을 이용한 다음의 코드도 살펴보시면 됩니다.interface IObj {    [idx: string]: string | number;    [index: number]: string | number;    myName: string;    myAddress: string;    myAge: number}let obj: IObj = {    myName: '홍길동',    myAddress: '서울',    myAge: 30};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}마지막으로 앞에서 나온 readonly property를 이용하면 ReadonlyArray처럼 사용할 수 있습니다.interface ReadonlyStringArray {    readonly [index: number]: string;}let myArr: ReadonlyStringArray = [\"홍길동\", \"강감찬\"];myArr[2] = \"이순신\"; // 코드 오류( readonly ) Class Typesinterface의 가장 일반적인 사용법은 Java나 C#언어처럼 class의 구현을 명시적으로 강제하는 것입니다.아직 class에 대해서는 배우지 않았지만 Java같은 객체지향 언어를 해 보신 분이라면 쉽게 이해하실거라 생각됩니다.interface IPerson {    [idx: string]: string | number | Function;    myName: string;    myAddress: string;    myAge: number;    printInfo(obj:IPerson): void;}class Person implements IPerson {    [index: string]: string | number | Function;    myName: string;    myAddress: string;    myAge: number;    constructor(name:string, address:string, age:number) {        this.myName = name;        this.myAddress = address;        this.myAge = age;    }        printInfo(obj: IPerson): void {        Object.keys(obj).forEach(t =&gt; console.log(obj[t]));    }}const obj = new Person(\"홍길동\", \"서울\", 30);obj.printInfo(obj);위와 같은 일반적인 경우가 사실은 대부분입니다. ^^; 여기에 추가적인 몇가지만 살펴보겠습니다. 이전 강좌에서 일급함수(first class function)개념에 대해서 언급했었는데기억하시나요? 한마디로 요약하자면 “JavaScript는 함수를 값으로 취급한다” 입니다. 그래서 함수를변수에 저장하거나 함수를 다른 함수의 인자로 넘기거나 함수의 리턴값으로 함수를 활용할 수 있는 것이지요.그래서 다음의 JavaScript코드는 정상적으로 동작합니다.const PersonFactory = {    getInstance: function(construct,name,age) {        return new construct(name,age);    }};class Person {    constructor(name, age) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();위의 코드에서 Person 생성자를 PersonFactory.getInstance 함수의 인자로 넘겨서사용했습니다. JavaScript에서는 문제없이 잘 동작합니다. 하지만 이 코드를 그대로TypeScript에서 작성하면 코드에러가 발생합니다.일단 타입지정부터 엉망이니 좀 수정해서 보면 TypeScript코드는 다음과 같게 됩니다.const PersonFactory = {    getInstance: function(construct:any,name:string,age:number) {        return new construct(name,age);    }};class Person {    myName: string;    myAge: number;    constructor(name:string, age:number) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();데이터 타입을 적절하게 지정해서 일단 코드 오류는 제거했습니다. 그런데 문제가 하나 있습니다.const PersonFactory = {    getInstance: function(construct:any,name:string,age:number) {        return new construct(name,age);    }};위의 코드에서 생성자를 인자로 받아올 때 타입을 어떻게 지정해야 할지 몰라 일단 모든 타입에 대응되는any로 설정했습니다. any로 설정하면 문제없지만 우리는 any를 사용하지 않습니다. 좀 심하게 표현하자면 any를사용할꺼면 굳이 TypeScript를 할 필요가 없습니다. 여하간 이 any를 없애고 정확한 타입을 명시하려 합니다. 그런데 어떤 타입을 써야하나요? any대신 만만한 Function을 이용해 보면 다음과 같은 오류를 보실 수 있습니다.Cannot use 'new' with an expression whose type lacks a call or construct signatureconstruct signature 없이 new를 사용할 수 없답니다. 그럼 이 construct signature를 어떻게 만들어야 할까요?저 위에서는 index signature라는 걸 interface를 이용해서 선언하고 사용했습니다. 기억하시죠? 이와 비슷합니다.interface를 이용해 생성자의 signature를 지정해 줄 수 있습니다. 다음과 같이 사용합니다.interface IPersonConstructor {    new (n:string, a:number): Person;}const PersonFactory = {    getInstance: function(construct:IPersonConstructor,                          name:string,                          age:number) {        return new construct(name,age);    }};class Person {    myName: string;    myAge: number;    constructor(name:string, age:number) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();이렇게 사용하는 interface를 constructor interface 라고 표현하기도 합니다. 중요한 것은interface로 constructor의 타입을 지정해 줄 수 있다는 것이고 construct signature라는 표현으로interface내에 정의해서 사용합니다. interface의 확장하나의 interface는 다른 interface로 부터 상속받아서 확장될 수 있습니다. Java와 유사합니다. 다음의 코드로이해하시면 됩니다.interface Shape {    color: string;}interface Square extends Shape {    sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;let square = &lt;Square&gt;{}; 에서 &lt;Square&gt; 부분이 어떤것인지 기억하시나요? 그렇습니다. Type assertions이죠.위의 코드는 크게 어렵지 않을 듯 보입니다. 하지만 Java와 다른점이 있습니다. 동시에 여러 interface로 부터 상속을받을 수 있다는 것이죠. 하지만 여기서 상속이라는 표현은 맞지 않습니다. 상속은 객체지향 언어에서 나오는 특성입니다.여기서는 단지 interface의 확장일 뿐입니다.interface Shape {    color: string;}interface PenStroke {    penWidth: number;}interface Square extends Shape, PenStroke {    sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0;interface는 type check를 위해 사용되기 때문에 interface로는 객체를 생성할 수 없습니다.일단 이 정도만 알아두어도 될 듯 보입니다. 내용이 생각보다 많은데 생각보다 많이 어렵지는 않습니다. 단지 헷갈릴 뿐이죠 ^^여러번 정독하면서 쓰임새를 알아두고 실제 코드에서 활용하면서 익히셔야 합니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-interface"
    }
    ,
    
    "javascript-babel": {
        "title": "Babel을 사용해보자",
            "author": "javascript",
            "category": "",
            "content": "Introduction아무 생각없이 Babel을 쓰고 있지만 예전부터 궁금했던 Babel이란 이름이 내가 알고 있는 그 바벨탑의 바벨인가? 라는 의문에 이름의 근원을 찾아보고 이왕 찾아본 김에 Babel의 간단한 사용법 정도만 정리해 보도록 하겠습니다.( 도데체 이런게 왜 궁금한건대? ) Babel이란 이름의 기원결론적으로 Babel Official HomePage 에서는 이름에 대한 근원을 찾을수는 없었습니다. 어딘가에 숨어있는지는 모르겠지만요. 여하간 Babel은 성경 영어로 구약성서 창세기에 그 근원을 두고 있습니다.( 왠지 산으로 가는 느낌입니다. )노아의 홍수 이후로 인간은 다시 번성하기 시작했고 그 당시에는 전 세계의 언어가 하나였다고 합니다. 하나님은 인간들에게흩어져 살 것을 명하셨지만, 사람들은 하나님의 말씀에 불순종하여 Shinar 라는 곳에 모여 살았답니다. 그리고 그들은자신들을 위해 하나의 도시를 건설하고 하늘에까지 닿는 높은 탑도 같이 세워 자신들의 이름을 높이고 흩어지지 않겠다는 의미로하나의 높은 탑을 건설하게 되었는데 이게 그 Babel(바벨탑)이랍니다.하지만 인간들의 그러한 동기를 아시는 하나님께서 그들이 탑을 세우지 못하고 전 세계로 흩어지게끔 그들의 언어를 여러개로나누셔서 서로간의 의사소통이 되지 않도록 하셨답니다. 서로 말이 통하지 않자 탑 공사는 중단되고 결국 언어가 맞는 사람끼리 뿔뿔히흩어져 살게되었다라는 이야기지요.그래서 Babel의 사전적 의미는 “와글와글”, “바벨탑”, “거대한 탑” 의 의미를 가지게 되었다고 합니다. Babel의 목적Babel은 JavaScript transpiler입니다. 공식 홈에는 compiler라고 표현했지만 사실 compiler보다는 transpiler라는 용어가더 맞지 않나 싶습니다. 여하간 Babel의 입력은 JavaScript이고 출력 역시 JavaScript입니다.잘 알다시피 ES5 표준은 2009년도에 표준화되었습니다. 그리고 한동안 변경이 없다가 2015년에 ES6가 표준화가 됩니다.현재 시점은 ES7 이 최신표준이지만 아직까지 ES6가 대세라고 볼 수 있습니다. 이 ES6에 들어와서는 여러가지 획기적인변화가 생기게 되었습니다.변화된 내용 중 대표적인 것들은 다음과 같습니다.  class  arrow function  template string  generator  destructuring  let &amp; const문제는 이런 최신의 문법들로 쓰여진 JavaScript 코드를 런타임 환경인 browser가 인식하고 실행할 수 있는냐는 것입니다. browser는 최신 ECMAScript 문법을 다 지원하지 못하거든요. 특히 구형 browser나 IE같은 경우는 그 정도가 심합니다.하지만 생산성과 유지보수성등의 이유로 코드자체는 ECMAScript 최신버전으로 구현하는게 당연히 좋습니다. 즉, 구현과 실행환경과의 버전차이가 생기게 됩니다. Babel은  ECMAScript 6,7 으로 작성된 코드를 browser가 인식할 수 잇는 문법(ES5)으로변환시켜주는 transpiler입니다.한가지 주의해야 할 점은 Babel을 사용한다고 해서 모든 최신의 JavaScript함수를 다 사용할 수 있는건 아닙니다. Babel은문법만 변환시켜 주는 역할만 할 뿐입니다. 따라서 프로그램이 처음에 시작될 때 browser에서 지원하지 않는 함수를 검사해 처리해주는작업이 이루어져야 하고 이 부분은 babel-ployfill이 runtime에 담당하게 됩니다. ( 이 기능을 사용하기 위해서는 추가적인 설정이 필요합니다. ) Babel의 사용자 그럼 실제 사용하는 예를 알아보도록 하겠습니다.Babel역시 다른 node module과 마찬가지로 npm으로 설치하면 됩니다.npm install --save-dev babel-cli babel-preset-es2015package.json에 다음과 같이 npm script 작성{  ...  ...  \"scripts\": {    \"build\": \"babel babelTest.js -d lib\",    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"  },  ...  ...}ES6로 다음과 같은 코드 작성하고 babelTest.js로 저장합니다.let [a,,b] = [1,2,3];let myName = \"홍길동\";console.log(`Hello ${myName}`);class Student {    constructor(sName) {        this.sName = sName;    }}let stu = new Student(\"Moon\");console.log(stu.sName);다음과 같이 .babelrc 파일을 작성합니다.{  \"presets\": [    \"es2015\"  ]}다음과 같이 npm script를 실행시켜 lib폴더에 생성된 컴파일된 결과 파일을 확인합니다.npm run build결과로 생성된 ES5 파일의 내용\"use strict\";function _classCallCheck(instance, Constructor) {     if (!(instance instanceof Constructor)) {         throw new TypeError(\"Cannot call a class as a function\");     } }var _ref = [1, 2, 3],    a = _ref[0],    b = _ref[2];var myName = \"홍길동\";console.log(\"Hello \" + myName);var Student = function Student(sName) {    _classCallCheck(this, Student);    this.sName = sName;};var stu = new Student(\"Moon\");console.log(stu.sName);여기서는 Babel이 어떤 역할을 하고 어떻게 사용하는 것인지에 대해서 간단하게 알아보았습니다.이 포스트의 내용은 Babel Official Home Page을 참조했습니다.조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!End.",
        "url": "/javascript-babel"
    }
    ,
    
    "javascript-use-strict": {
        "title": "JavaScript의 strict mode란 무엇인가?",
            "author": "javascript",
            "category": "",
            "content": "Introduction\"use strict\"는 ES5에서 새롭게 나온 directive입니다. 실제 수행 문장이 아니라 literal expression이기 때문에 이전 버전의 JavaScript에서는 무시됩니다.일반적으로 JavaScript 코드 최 상단에 이 “use strict”가 위치하는데 이 의미에 대해서 간단하게 정리해 봤습니다. “use strict”를 써야하는 이유“use strict”의 목적은 우리의 코드가 strict mode로 실행되게끔 지시하는 것입니다. 여기서 말하는 strict mode란 프로그램 실행 시 예외를 발생시킬 만한 몇가지 특이한 동작을 수행할 수 없도록 엄격한 제한이 걸려있는 실행 context를 지칭합니다. 즉, 일반적으로 동작하는 코드를 “use strict”를 이용하면 에러가 발생할 수 있다는 말이지요.“use strict”는 함수별로 따로 지정할 수 있습니다. 즉, 함수내부에 “use strict”를 선언하면해당 함수는 strict mode로 실행되게 됩니다.몇가지 예를 들어보죠.\"use strict\";x = 100;        // x가 선언되지 않았기 때문에 error 발생console.log(x);x = 3.14;       // strict mode가 아니기 때문에 에러 아님.function myFunction() {    \"use strict\";    y = 3.14;   // y가 선언되지 않았기 때문에 에러 발생}myFunction();\"use strict\";var x = 3.14;delete x;   // strict mode에서는 delete를 사용할 수 없다.   \"use strict\";var public = 1500;   // strict mode에서는 키워드로 변수명을 쓸수 없다.그 외의 예로는 함수의 매개변수의 리스트에서 중복된 부분이 있을 때 오류를 발생시키고 동일한 라이브러리를 중복해서로딩하는 경우 에러를 발생시킵니다. (예를 들면, jQuery library 중복로딩 )결론적으로 잠재적인 오류가 발생할 수 있는 여지를 막아주도록 코드에 대한 문법 사항을 엄걱하게 지키도록 하는directive정도로 인식하시면 될 듯 합니다.  결론은 고민하지 말고 무조건 써야된다!! 입니다. ^^이 포스트의 내용은 w3schools.com을 참조했습니다.조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!End.",
        "url": "/javascript-use-strict"
    }
    ,
    
    "typescript-destructuring": {
        "title": "TypeScript 강좌(5) - Destructuring",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Destructuring이번 포스트의 내용은 Destructuring 입니다. Destructuring은 ECMAScript 2015 문법인데 TypeScript에서도 지원합니다.  아래의 예제를 정상적으로 실행해보실려면 tsconfig.json에서 compilerOptions의 target 속성을es6로 해 주셔야 합니다.일반적으로 Destructuring Assignment(비구조할당)라고 하는데 쉽게 말하자면 배열의 요소나 객체의 속성을 배열 literal 혹은 객체 literal과 유사한 형태의 문법을 이용하여변수에 할당하는 기법입니다. 잘 알아두면 코드를 좀 더 쉽게 작성할 수 있습니다. Array Destructuring다음과 같이 배열이 있을 경우 각 배열의 원소값을 가지는 변수를 만들려고 합니다. 아마도 코드는 다음처럼 써야 할 듯 보입니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let first: string = myArr[0];let second: string = myArr[1];let third: string = myArr[2];console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력console.log(third);     // \"Moon\" 출력이 코드를 Destructuring Assignment(비구조할당)를 이용하면 다음과 같이 표현할 수 있습니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let [first, second, third] = myArr;console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력console.log(third);     // \"Moon\" 출력위의 코드에서 [first, second, third] 형태를 Destructuring Array(비구조배열)이라고 합니다.즉, let [first, second, third] 구문은 변수 선언과 동시에 Destructuring Array(비구조배열)을 생성한 것입니다.만약 Destructuring Array(비구조배열)에 data type을 지정하고 싶은경우는 다음과 같이 하시면 됩니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let [first, second, third]: string[] = myArr;간단한 응용을 보도록 하죠. 두개의 변수에 대한 swap처리입니다. 기본적으로는 임시변수가 있어야 두 변수의 값을 swap처리할 수 있지만 Destructuring Assignment를 이용하면 보다 간단하게 할 수 있습니다.let myArr: string[] = [\"Hello\", \"World\"];let [first, second] = myArr;console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력[second, first] = [first, second];   // swap 처리console.log(first);     // \"World\" 출력console.log(second);    // \"Hello\" 출력이런 방식은 함수에 parameter를 전달할 때도 사용할 수 있습니다.function myFunc([x, y]: [number, number]): void {    console.log(`x의 값은 ${x}`);    console.log(`y의 값은 ${y}`);}myFunc([10,20]);나머지 몇몇 응용에 대해서 알아보겟습니다. ...을 이용하면 다음과 같은 형태로 서브배열을생성할 수 있습니다.let myArr: number[] = [1, 2, 3, 4];let [first, ...others] = myArr;console.log(first);    // 1 출력console.log(others);   // [2, 3, 4] 출력 ( 서브배열 )다음과 같은 형태로 Destructuring Array를 이용할 수 있습니다.let myArr: number[] = [1, 2, 3, 4];let [first] = myArr;let [,second, ,fourth] = myArr;console.log(first);     // 1 출력console.log(second);    // 2 출력console.log(fourth);    // 4 출력 Object Destructuring이번에는 객체를 비구조할당을 통해 이용해 보도록 하겠습니다.let obj = {    key1 : \"Hello World\",    key2 : 100,    key3 : \"TypeScript\"};let { key1:a, key2:b } = obj;console.log(a);    // Hello World 출력console.log(b);    // 100 출력새로운 변수 a와 b가 생성되고 obj.key1의 값의 key1:a에 의해서 a 변수에 대입됩니다.마찬가지로 obj.key2의 값이 key2:b에 매칭되서 b 변수에 값이 할당되는 것이구요. obj.key3는 당연히 무시됩니다.변수를 선언할 때 [ ]가 아닌 { }를 이용한다는 것에 주의하셔야 합니다.만약 객체의 Key( 위의 예제에서는 key1, key2, key3 )가 비구조 객체에 쓰이는 변수의 이름과 동일하다면간소화된 형태로 이용할 수 있습니다. 아래의 예처럼 말이죠.let obj = {    key1 : \"Hello World\",    key2 : 100,    key3 : \"TypeScript\"};let { key1, key2 } = obj;console.log(key1);    // Hello World 출력console.log(key2);    // 100 출력그러면 다음과 같이 표현할 수 도 있겠네요.let { a, b } = { a: \"Hello World\", b: 100 };console.log(a);    // Hello World 출력console.log(b);    // 100 출력조금 헷갈리긴 하지만 익숙해지면 할 만 합니다. ^^;아까 위에서 나왔던 ...을 기억하시나요? 배열의 나머지를 가지고 서브배열을 생성할 때 사용했었습니다. Object Destructuring에서도 ...을 이용할 수 있습니다. 아래의 코드를 살펴보도록 하죠.let obj = {    myName: \"홍길동\",    myAddress: \"서울\",    myAge: 30};let { myName, ...otherInfo} = obj;console.log(`이름은 : ${myName}`);console.log(`나이는 : ${otherInfo.myAge}`);객체의 property의 이름을 다른 것으로 바꿀 수 있습니다. 아래의 코드를 보시죠let obj = {    a: \"홍길동\",    b: \"서울\",    c: 30};let { a:myName, b:myAddress } = obj;console.log(`이름은 : ${myName}`);     // 홍길동 출력console.log(`주소는 : ${myAddress}`);  // 서울 출력위의 코드에서 주의해야 할 점은 a:myName, b:myAddress에서 :의 의미가 data type을 지정하는 것으로 사용된 것이 아니라는 것입니다. 만약 데이터 타입을 지정해서 사용하려면 다음과 같이 사용하셔야 합니다.let obj = {    a: \"홍길동\",    b: \"서울\",    c: 30};let { a:myName, b:myAddress }: {a:string, b:string} = obj;console.log(`이름은 : ${myName}`);     // 홍길동 출력console.log(`주소는 : ${myAddress}`);  // 서울 출력점점 복잡해 지는군요. 한가지 주의해야 할 점은 ECMAScript 2015(ES6)에서의 Destructuring과 TypeScript의Destructuring이 완벽하게 똑같지는 않다는 것입니다.이번에 살펴볼 것은 default 값입니다. Destructuring하려는 속성이 존재하지 않을 때를 대비해서 default값을지정할 수 있습니다. 아래의 예를 보시죠.let obj: {myName:string, myAge?:number} = {    myName : \"홍길동\",};let { myName:uNmae, myAge:uAge = 30 } = obj;console.log(uNmae);  // 홍길동console.log(uAge);   // 30위의 예에서 myAge?:number 부분의 ?의 의미는 해당 property가 있을 수도 있고 없을 수도 있다는것을 의미합니다.myAge:uAge = 30 부분이 default value를 사용한 부분입니다. 어디에 쓰면 좋을까요?간단하게 Destructuring이 무엇인지를 살펴보았는데 그럼 도데체 이걸 어디에 써 먹어야 할까요?이런식의 응용이 가능하구나 하는 정도로 가볍게 보시면 될 듯 합니다.첫번째로 생각할 수 있는 응용은 ECMAScript 2015에서 제공되는 Iteration Protocol과의 연계사용입니다.아주 쉽게 생각하면 Map사용에 응용할 수 있다 정도로 보시면 됩니다. Map 자료구조는 key와 value의 쌍으로데이터를 저장하는 구조이고 다음과 같은 형태로 Destructuring과 함께 이용할 수 있습니다.let map = new Map();map.set(\"myName\",\"홍길동\");map.set(\"myAddress\",\"서울\");map.set(\"myAge\",30);for(let [key, value] of map) {    console.log(`${key} 의 값은 ${value} 입니다.`);}for(let [key] of map ) {    // 모든 key 값만을 출력할 수 있습니다.    console.log(`${key}`);}for(let [,value] of map ) {    // 모든 value 값만을 출력할 수 있습니다.    console.log(`${value}`);}두번째는 함수의 리턴값에 응용하는 것입니다. 리턴값이 두개 이상 필요할 때 우리는 배열형태나 객체형태로 리턴을 받게 되는데 Destructuring을 이용하면 편합니다.다음은 배열을 리턴받는 경우입니다.function myFunc(): string[] {    let arr: string[] = [];    // 로직처리 ...    arr[0] = \"첫번째 결과값\";    arr[1] = \"두번째 결과값\";    return arr;}let [result1, result2] = myFunc();console.log(result1);console.log(result2);다음은 객체를 리턴받는 경우입니다.function myFunc(): {result1:string, result2?:number} {    let obj = {        result1 : \"\",        result2 : 0    };    // 로직처리 ...    obj.result1 = \"첫번째 결과값\";    obj.result2 = 100;    return obj;}let {result1:first, result2:second} = myFunc();console.log(first);console.log(second);꼭 사용해야 할 필요는 없지만 알아두면 편하고 좋은 Destructuring에 대해서 알아보았습니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-destructuring"
    }
    ,
    
    "typescript-variable": {
        "title": "TypeScript 강좌(4) - 변수 선언",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Variable Declarations이번 포스트에서는 var, let, const에 대해서 알아보겠습니다. let은 var과 유사하지만 var이가지고 있는 우리에게 익숙치 않은 몇가지 사항들을 피하도록 도와줍니다. const는 이름에서 의미하다시피 변수에재할당을 금지하는 목적으로 사용하는 것이구요.결론을 미리 말하자면 TypeScript는 let과 const를 이용합니다.먼저 var에 대해서 알아보고 그 다음에 let, const에 대해서 알아보도록 하겠습니다. var코드로 설명하자면 다음과 같이 변수를 선언할 수 있습니다.var myVar = 100;당연한 말이지만 함수내에서도 선언할 수 있습니다.function myFunc() {    var message = \"Hello World\";    return message}JavaScript는 함수안에 다른 함수를 선언할 수 있습니다. 그러한 경우 내부 함수가 외부 함수가 가지고 있는변수를 참조할 수 있습니다. 또한 JavaScript는 1급 함수(first-class function)를 지원합니다. 쉽게 말하면JavaScript의 함수는 값의 의미로 사용될 수 있다는 것입니다. 함수가 값의 역할을 하다보니 다음과 같은 형태의코드가 가능합니다.  함수를 변수에 저장.  함수를 다른 함수의 인자로 전달.  함수를 다른 함수의 리턴값으로 사용.위와 같은 형태의 함수를 이용할 때는 함수의 이름이 특별히 필요하지 않기 때문에 이런 함수는 특별히 이름을 명시하지 않고 사용합니다.이런 함수를 우리는 익명함수( Anonymous function )라고 하죠. 다른 표현으로는 람다( Lambda )라고도 합니다.( 사실 Lambda에 대한 내용은 조금 더 파고 들어야 합니다. 나중에 다른 포스트에서 정리해볼께요 )위의 내용으로 간단한 예를 들자면 아래와 같습니다.function outerFunc() {    var a = 100;    return function() {        var b = a + 100;        return b;    }}var myFunc = outerFunc();console.log(myFunc());    // 200 출력사실 위의 예제는 좀 이상합니다. 아니 많이 이상하죠.다음과 같은var myFunc = outerFunc();코드에서 outerFunc()함수는 수행이 종료되었기때문에 그 안에 선언된 변수 a는 사실 사용할 수 없어야 합니다. 우리가 익히 알고 있는 다른 프로그래밍 언어의 변수 scope 개념으로 본다면 말이죠.하지만 JavaScript의 var 변수 scope는 좀 다릅니다. outerFunc() 함수의 호출이 끝났음에도 불구하고 a 변수값이 유지됩니다. 즉, outerFunc()에 대한 참조가 남아있는 한 메모리에 계속 유지하게 되는 구조입니다.( outerFunc() 함수가 실행중인 상태로 간주한다는 의미이기도 합니다. ) 그렇기 때문에 위에서 myFunc()를 호출했을 때 a 변수를 이용할 수 있는 것입니다.조금 다른 예제를 살펴보겠습니다.function myFunc(init) {    if (init) {        var x = 10;    }    return x;}console.log(myFunc(true));  // 10 출력위의 코드는 JavaScript 코드입니다. var 변수는 if block 안에서 선언되었음에도 불구하고 block 외부에서도 사용이 가능합니다. 위에서 언급했듯이 JavaScript의 var 변수 scope가 좀 독특해서 그렇습니다. var로 선언된 변수는 block에 상관없이 function 내에서 사용이 가능합니다.  이런 특성을 var은 function-scoping을 가진다 라고 표현합니다.var에 대해서 마지막 하나만 더 살펴보고 정리하겠습니다.다음과 같은 setTimeout을 이용한 코드가 있을 때 실행결과가 어떻게 출력될까요?for (var i = 0; i &lt; 10; i++) {    setTimeout(        function() { console.log(i); },        1000    );}   결과는 다음과 같이 출력됩니다.10101010101010101010JavaScript를 알고 있는 사람들에게는 꽤나 익숙한 코드형태이자 결과일겁니다. setTimeout은 두번째 인자로 들어가는시간을 delay로 첫번째 인자의 함수를 호출해 주는 역할을 하는 함수입니다. (내부 Thread로 동작하겠죠)for문은 순식간에 수행될 것이고 1초뒤에 다음 코드가function() { console.log(i); }10번 호출되게 됩니다. 이 때 i변수는상위 for문의 scope를 참조하게 되므로 실제 console.log(i)가 수행될 때 i값을 참조하면 10이라는 값을 가지고 있을테니화면에 10이 10번 출력되게 됩니다.그러면 0부터 9까지 순차적으로 출력하려면 어떻게 해야 할까요? 이 작업을 수행하기 위해 IIFE을 이용합니다.  IIFE는 Immediately Invoked Function Expression을 의미합니다.코드를 아래와 같이 수정합니다.for (var i = 0; i &lt; 10; i++) {    (function(tmp) {        setTimeout(            function() { console.log(tmp); },            1000        );    })(i);}즉시 실행되는 함수 표현법(IIFE)를 이용하여 새로운 function scope를 생성해서 i값을 capture하는 방식으로 처리하면 될 듯 합니다.이 부분을 정확히 이해하기 위해서는 free variable, scope chain, Closure에 대한 이해가 있어야 합니다. 너무 이야기가산으로 가니 이 부분은 JavaScript 관련 포스트에서 따로 정리해 보도록 하겠습니다. let위에서 언급한 var의 모호성을 let을 이용해 해결할 수 있습니다. 변수를 선언할 때 단순히 var대신 let을 이용하면됩니다.let myVar: string = \"Hello World!!\";let은 우리에게 친숙한 block-scoping을 가집니다. ( lexical-scoping 이라고도 합니다. )function myFunc(input: boolean) {        let a = 100;    if (input) {        let b = a + 1;   // a에 접근이 가능합니다.        return b;    }    return b;            // 코드 에러( b에 접근할 수 없습니다. )}let의 또 다른 특징은 변수의 중복 선언이 안된다는 것입니다. 사실 프로그래밍 언어에서는 거의 당연시 여겨지는 것이지만var는 중복선언이 가능합니다. 다음과 같이 말이죠.function f() {        var x;    var x;          // JavaScript의 var은 같은 변수를 중복선언할 수 있습니다.         if (true) {        var x;    }}자 그럼 아까 var로 선언했을 때 이상하게 동작했던 setTimeout을 이번에는 let을 이용해서처리하면 어떻게 될까요?for (let i = 0; i &lt; 10; i++) {    setTimeout(        function() { console.log(i); },        1000    );}  0123456789var로 선언했을 때와 다른 결과를 볼 수 있습니다.  결론적으로 let은 우리가 익히 알던 (다른 언어의) 변수 특징을 가지는 변수를 선언하기 위한 keyword라고 생각하시면 됩니다. const변수를 선언하기 위한 또 다른 방법은 const를 이용하는 것입니다. 하지만 const로 선언된 변수에는재 할당(re-assign)이 불가능 합니다. 아래의 예처럼 말이죠.const myName: string = \"홍길동\";myName = \"강감찬\";   // 코드 에러const를 사용할 때 한가지만 주의하시면 됩니다. 만약 const 변수가 객체를 지칭하게 되면 다른 객체로 reference를바꾸지는 못하지만 현재 reference하고 있는 객체의 속성에 대해서는 값을 변경할 수 있습니다.아래의 예처럼 말이죠.const count: number = 100;const myProfile = {    myName: \"홍길동\",    myAddress: \"서울\",    myCount: count};myProfile = {                  // 코드 에러 ( re-assign 안됨 )    myName: \"강감찬\",    myAddress: \"인천\",};                   myProfile.myName = \"강감찬\";   // 가능myProfile.myAddress = \"인천\";myProfile.myCount = 10;변수 선언에 대한 keyword에 대해서는 이정도 알아두시면 될 듯 보입니다. 다음 주제는 Destructuring(디스트럭쳐링)입니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-variable"
    }
    ,
    
    "typescript-datatype-2": {
        "title": "TypeScript 강좌(3) - Data Type(Part 2)",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Data Type  any  void  null &amp; undefined  never  type assertions이전 포스트에서 기본적인 data type을 알아보았으니 이번에는 조금 더 색다른 data type을 살펴보도록 하겠습니다. anyApplication을 작성하는 시점을 기준으로 할 때 어떤 변수의 data type을 결정할 수 없는 경우가 아주 간혹 있습니다.가장 쉬운 예로 3rd party library를 이용해 dynamic content를 로딩해 저장하는 변수를 생각하시면 됩니다.즉, 동적으로 로딩되는 데이터의 타입이 runtime에 결정되므로 컴파일 타임에 data type을 지정할 수 없는 경우입니다.(하지만 사실 우리는 대부분 데이터 타입을 정해놓고 구현을 진행하긴 합니다. ^^)이런 경우 “어떠한 data type도 될 수 있다”라는 의미로 any data type을 이용할 수 있습니다.data type에 구애받지 않고 쉽게 코드를 작성할 수 있도록 만들어주지만 위에서 언급한 특정 목적을 제외하고는당연히 사용하지 않는것이 좋습니다.아래의 코드를 살펴보죠.let myVar: any = 100;myVar = \"Hello World!!\"; // 가능myVar = true;            // 가능 배열의 data type으로 any를 이용하여 서로 다른 data type으로 배열을 이용하는게 가능해집니다.아래의 코드처럼 말이죠.let myArr: any[] = [100, \"Hello\", true]; void어디서 많이 본 것입니다. 일반적으로 void는 함수가 리턴값이 없을 때 함수의 리턴 type으로 이용합니다. 아래의 코드를 보시죠.function myFunc(name: string) : void {    console.log(`Hello, ${name}!!`);}myFunc(\"Moon\");일반 변수를 만약 void로 선언하면 어떻게 될까요? 변수를 void type으로 선언하면 해당 변수에는 null 혹은 undefined만 assign이 가능합니다. 이렇게 사용할 일이 과연 있을까 싶네요.let myVar: void;myVar = 100;       // 불가능(코드 에러)myVar = \"Hello\";   // 불가능(코드 에러)myVar = null;      // 가능myVar = undefined; // 가능  여기서 주의해야 할 점은 tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": false option을설정해야 한다는 것입니다. null &amp; undefinedTypeScript에서 null과 undefined는 값이자 하나의 data type입니다. 그렇기 때문에 다음과 같이 사용해야 합니다.let myNull: null = null;let myUndefined: undefined = undefined;하지만 null과 undefined는 다른 모든 type의 subtype입니다. 쉽게 말하면 다른 모든 type에 null과 undefined 값을 assign할 수 있다는 말입니다.여기서 주의해야 할 점은 만약 --strictNullChecks flag를 이용해 .ts파일을 컴파일 할 경우 null과 undefined는 void 혹은자신의 data type에만 assign될 수 있게됩니다.(tsconfig.json파일안에서 \"strictNullChecks\": true로 설정한 경우를 의미 )  tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": false option 적용한 경우let myName: string = \"홍길동\";let myVoid: void;let myNull: null;let myUndefined: undefined;myName = null;            // 가능myName = undefined;       // 가능myVoid = null;            // 가능myVoid = undefined;       // 가능myNull = null;            // 가능myNull = undefined;       // 가능myUndefined = null;       // 가능myUndefined = undefined;  // 가능  tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": true option 적용한 경우let myName: string = \"홍길동\";let myVoid: void;let myNull: null;let myUndefined: undefined;myName = null;            // 불가능myName = undefined;       // 불가능myVoid = null;            // 불가능myVoid = undefined;       // 가능myNull = null;            // 가능myNull = undefined;       // 불가능myUndefined = null;       // 불가능myUndefined = undefined;  // 가능 nevernever type은 일반적으로 함수의 리턴 타입으로 사용됩니다. 만약 함수의 리턴 type으로 never가 사용되면 해당함수는 항상 exception을 발생시키던가 혹은 절대 return되지 않는다는 것을 의미합니다. 절대 return되지 않는다는것은 무한 loop에 빠지는 것등을 의미합니다.코드상으로 이해하자면 다음과 같은 경우입니다.function error(message: string): never {    throw new Error(message);}error(\"Something Wrong!!\");function infiniteLoop(): never {    while (true) {            }} Type assertionsType assertions는 컴파일러에게 “이 타입 사용이 맞아!!”라는 의미를 전달하는 것입니다. Type assertions은 type casting과 같은 의미로 사용되지만 실제 특별한 체크작업이나 데이터 재구조화 작업이 발생하지 않습니다.TypeScript는 프로그래머가 특정한 type check를 진행했다고 가정한 후 컴파일을 진행합니다.( TypeScript가 따로 검증하지 않는다는 거죠. )Type assertions을 하는 방법은 2가지가 있습니다. angle-bracket syntax(&lt;&gt;)를 이용하는 방법과 as syntax를이용하는 방법입니다. 아래의 코드를 보죠.let myVar: any = \"Hello World\";let myVarCount: number = (&lt;string&gt;myVar).length;myVarCount = (myVar as string).length;console.log((&lt;number&gt;myVar).toFixed());  // runtime errorany data type과 함께 사용되는 경우가 많으며 데이터 타입을 한정지어서 사용할 수 있도록 도와주는 역할을 합니다.여기까지가 TypeScript의 기본 data type입니다. 다음 포스트는 변수를 선언하기 위한 키워드인 var, let, const에 대해서 알아보도록 하겠습니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-datatype-2"
    }
    ,
    
    "typescript-datatype-1": {
        "title": "TypeScript 강좌(2) - Data Type(Part 1)",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Data Type  boolean  number  string  Array  Tuple  enum프로그래밍 언어를 배울 때 가장 먼저 학습하는 부분이 바로 Data Type입니다. 이전에도 언급했듯이TypeScript는 JavaScript의 superset이기 때문에 JavaScript의 data type을 그대로 이용합니다. 거기에추가적인 데이터 타입이 더 존재합니다.그럼 하나하나 예를 들면서 보도록 하죠. boolean우리가 알고있는 boolean type입니다. true와 false keyword를 사용할 수 있습니다.TypeScript에서는 변수선언시 var을 사용하지 않습니다. var는 전통적으로 javascript의 변수를 선언하기 위한 keyword로 사용되고 있지만몇가지 우리를 힘들게 하는 특징이 있습니다. 이부분은 나중에 다시 포스팅하기로 하겠습니다.여하간 TypeScript에서는 var대신 const와 let을 이용합니다. 다음과 같이 boolean type의 변수를 선언할수 있습니다.let myVar: boolean = false;WebStorm에서는 다음그림처럼 확인하시면 편합니다. 왼쪽창에는 .ts파일, 오른쪽 창에는 변환된 .js파일을열어서 .ts가 어떻게 .js로 변환되는지를 확인해보세요.JavaScript에는 생성자 함수라는게 있습니다. 원래 JavaScript는 객체지향언어가 아닙니다. Prototype기반의 함수형 언어입니다.그래서 JavaScript 초기버전에는 class가 도입되지 않았습니다. class는 ECMAScript 2015(ES6)에 도입되었습니다. class가 도입되기 이전에는 함수를 이용해서 객체를 생성하는 생성자 함수라는걸 사용했습니다. 지금도 역시 사용하고 있구요. 우리가 알고있는 new Date(); 이런게 다 생성자 함수를 이용한 객체의 생성입니다.그 중 특수한 생성자 함수들이 있습니다. 바로 primitive type에 대한 생성자 함수들 입니다. 이런것들을 우리는 흔히 Wrapper라고 부릅니다. JavaScript에도 Wrapper Object가 존재합니다. Boolean과 같은 생성자 함수를 이용해서 object를 만들면 우리는 그걸 primitive wrapper object라고 하는거지요.let myVar: boolean = false;let myBooleanVar: Boolean = new Boolean(true);   이제 아래의 코드를 살펴보죠.let myVar: boolean = false;let myBooleanVar: Boolean = new Boolean(true);console.log(myVar.valueOf());console.log(myBooleanVar.valueOf());위와 같은 코드는 좀 이상합니다. myVar는 primitive type임에도 불구하고 method를 호출했습니다.그럼에도 이상없이 실행이 잘 됩니다. 그 이유는 자동형변환이 일어나기 때문입니다. autoboxing이라고 하죠.let myVar: boolean = new Boolean(true);    // 코드 에러console.log(myVar.valueOf());위의 코드는 에러입니다. boolean type의 변수에 Boolean wrapper object를 assign할 수 없다는 오류가 발생합니다.혼용해서 사용하는건 좋지 않습니다. JavaScript할 때야 그냥 막(?) 했지만 TypeScript는 data type을 정확히 명시하는습관을 들이셔야 합니다.  결론적으로 booelan / Boolean 이 존재하는군요. 하나는 primitive data type이고 다른 하나는 primitive wrapper object를만들기 위한 생성자 함수입니다. data type 용도로 사용할 경우는 boolean을 이용하셔야 합니다.(나머지 data type에 대해서도동일합니다. - 권장사항) numberTypeScript는 정수와 실수를 구분하지 않습니다. 모두 다 실수( floating point values )입니다. data type으로는number를 사용합니다. 대응되는 wrapper 생성자 함수는 Number가 되겠네요.기본적인 10진수, 16진수에 더해 ECMAScript 2015에서 2진수, 8진수의 사용도 추가되었습니다.let decimal: number = 6;     let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;console.log(octal.valueOf()); string문자열을 지칭합니다. 기본적으로 double quotes (\") 와 single quotes (') 둘 다 이용할 수 있습니다. 일반적으로는single quotes (')를 이용합니다. 대응되는 wrapper 생성자 함수는 String 입니다.한가지 더 기억해야 할 것이 있는데 template string이라는 걸 사용할 수 있습니다. backquote ( ` ) 를 이용하여여러줄에 걸쳐 문자열을 입력할 수 있고 ${ expr } 형태로 embedded expression을 사용할 수 있습니다.let myStr: string = \"Hello\";let myNumber: number = 100;let myTemplateString = `this isasampleText =&gt; ${ myNumber + 100 }myStr : ${ myStr }`;console.log(myTemplateString);실행결과는 다음과 같습니다.this isasampleText =&gt; 200myStr : Hello ArrayTypeScript는 JavaScript와 마찬가지로 Array를 지원합니다. 배열은 primitive data type이 아닌 객체입니다.배열은 두가지 방식으로 사용할 수 있습니다. 일반적인 방식은 다음과 같습니다.let myArr: string[] = [\"Hello\", \"Hi\", \"안녕하세요\"];console.log(myArr);또 다른 방식은 Array Interface와 generic을 이용하는 방법입니다. 자세한 설명은 다른 포스트에서 진행합니다. 여기서는 어떻게 배열을 선언하고 사용하는지만 보시면 됩니다.let myNumArr: Array&lt;number&gt; = [1, 2, 3, 4];console.log(myNumArr); TupleTuple은 배열입니다. 특수한 형태의 배열로 인식하시면 됩니다. 배열의 각 원소에 대해 각기 다른 data type을 허용합니다.다음과 같은 코드를 가지고 이해해보죠let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능myTuple = [\"Hello\", \"World\"]; // 에러위의 코드의 제일 마지막 문장인myTuple = [\"Hello\", \"World\"];코드는 Tuple의 type선언에 맞지 않기때문에 Error가 발생합니다.다음의 코드를 살펴보죠let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능console.log(myTuple[0]);  // \"Hello\" 출력console.log(myTuple[1]);  // 100 출력console.log(myTuple[2]);  // undefined 출력위에서 언급했듯이 배열로 사용합니다. 2칸짜리 배열을 만들고 첫번째 칸에는 string, 두번째 칸에는 number를 data type으로가지는 배열입니다.JavaScript의 배열은 크기를 동적으로 늘릴 수 있습니다. 3번째 칸( myTuple[2] )에 데이터를 입력해 보겠습니다.let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능myTuple[2] = \"World\"; // 가능myTuple[2] = 200;     // 가능myTuple[2] = true;    // 불가능( 코드 에러 )3번째 칸에 string과 number는 assign이 되는것을 확인할 수 있습니다. 하지만 boolean은 들어가지 않는군요.정리하자면 현재 사용할 수 있는 index를 넘어가는 곳에 데이터를 입력할 때는 Tuple선언에서 사용한 data type의union type을 이용합니다. 쉽게 말하면 string 혹은 number가 되어야 한다는 말입니다. enumenum을 이용할 수 있습니다. C#의 enum과 동일합니다. 숫자 대신 친숙한 이름으로 설정하기 위해서 이용합니다.다음의 코드를 이용해서 살펴보죠enum Color { Red, Green, Blue }let myColor: Color = Color.Red;console.log(myColor);   // 0 출력별다른 설명이 필요없습니다. 이번에는 다음의 코드를 보죠enum Color { Red = 1, Green, Blue = 4 }let myColor: Color = Color.Green;console.log(myColor);   // 2 출력myColor = Color.Blue;console.log(myColor);   // 4 출력Color.Red의 값을 1로 설정하면 그 다음 원소들은 당연히 1부터 1씩 증가합니다. Color.Blue는 4로 명시적으로 지정했네요.아래의 예제는 좀 특이합니다. string 변수에 enum을 대입한 후 결과를 출력합니다.enum Color { Red = 1, Green, Blue }let myColorStr: string = Color.Green;  // 코드 에러( 문자열에 숫자대입 안됨 )let myColor: string = Color[3];        // 가능( 배열로 처리 - index에 주의 )console.log(myColor);                  // \"Blue\" 출력위의 코드에서let myColorStr: string = Color.Green;코드는 에러가 발생합니다. 문자열 type에 숫자를 넣으려 했기 때문이죠.또한 enum은 배열형태로 사용이 가능한 데 이런 경우 해당 문자열을 바로 이용할 수 있습니다.여기까지는 아마 우리가 알고있던 JavaScript와 거의 동일하니 이해하는데 어려움은 없을 듯 보입니다.나머지 data type은 다음 포스트에서 이어가도록 하죠.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-datatype-1"
    }
    ,
    
    "typescript-introduction": {
        "title": "TypeScript 강좌(1) - Introduction",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript 개요 및 WebStorm 개발환경 설정TypeScript는 Microsoft에서 개발하여 2012년에 발표한 오픈 소스 프로그래밍 언어입니다. 대규모 JavaScript application 개발을 목적으로 만들어졌습니다.TypeScript의 특징은 다음과 같습니다.  TypeScript는 JavaScript의 Superset입니다. TypeScript는 JavaScript의 모든 기능을 포함하고 그 외 추가적인 기능들을 가지고 있습니다.  TypeScript는 컴파일 언어이지만 컴파일 결과가 machine code가 아닌 JavaScript 코드가 나옵니다.( 이런 프로그래밍을 메타프로그래밍 이라고 하죠. ) 그렇기 때문에 compile 대신에 transpile 이라고도 합니다.  TypeScript는 compile 시점에 type checking이 일어나는 정적 타입 언어입니다. TypeScript 개발환경 설정여기서는 Node.js를 이용하여 npm(Node Package Manager)을 설치하고 이 npm을 이용해 TypeScript를 설치하고 사용하는 방법에 대해서 알아보겠습니다.먼저 Node.js사이트에 접속해 LTS 버전이나 최신버전 둘 중 하나를 선택해다운로드 합니다. (어떤것을 설치해도 상관없습니다.)저는 LTS 버전으로 다운로드 했습니다. 다운로드가 끝나면 기본 형태로 설치를 진행합니다. 설치가 끝나면C:/Program Files/nodejs 폴더가 만들어지게 됩니다.이제 command 창을 열어서 다음과 같이 명령어를 실행해봅니다.  npmnpm(Node Package Manager)이 정상적으로 동작하면 이제 npm을 이용해 typescript를 설치할 수 있습니다.설치는 local mode와 global mode로 설치가 가능합니다. 여기서는 편의상 global mode로 설치합니다.(일반적으로는 local mode를 선호합니다.)command 창에서 다음과 같이 명령어를 이용해 typescript를 global로 설치합니다.  npm install -g typescripttypescript 2.6.2가 설치되었습니다.  global mode로 설치하면 windows 시스템을 기준으로 $USER_HOME/AppData/Roaming/npm/node_modules에 설치됩니다.이제 사용할 IDE(Integrated Development Environment)를 설치합니다. 여기서는 WebStorm(유료)을 이용합니다.Visual Studio Code(무료)를 사용하셔도 됩니다. WebStorm은 유료이지만 30일 trial을 사용할 수 있고 Student license로1년간 무료로 사용할 수 도 있습니다.JetBrains사이트로 접속한 후 WebStorm을 다운로드 받습니다.다운로드가 완료되면 기본형태로 설치합니다. 설치가 끝나면 프로젝트를 생성할 수 있는 화면이 나오게 되는데 폴더 하나를 생성해서 프로젝트를 생성합니다. (폴더명이 프로젝트명이됩니다.) 저는 D:/TypeScriptTestApp 폴더를 생성하면서 프로젝트를 하나 만들었습니다.이제 WebStorm 설정을 해야 합니다.  Files - Settings - Languages &amp; Frameworks - TypeScript 를 선택하면 아래와 같은 화면을 볼 수 있습니다.사실 WebStorm에 TypeScript가 bundle되어 들어있기 때문에 TypeScript를 따로 설치 안해도 됩니다. 하지만 어떻게 설치하는지는 알아둘 필요는 있으니 한번 설치해 본거죠. 그리고 아래의 그림처럼 Compiler 옵션부분을check합니다.컴파일을 할 때 tsconfig.json을 참조해 compile option을 설정한다고 해 놓았습니다. 우리는 아직 tsconfig.json이 없으니 하나 생성해 줍니다. WebStorm의 하단에 있는 Terminal을 클릭해서 Terminal창을 열고 다음을 입력합니다.  tsc --init프로젝트를 살펴보면 tsconfig.json이 생성되어 있는것을 볼 수 있고 안에 무언가가 많이 들어있는것을 확인할 수 있습니다.compiler option에 대해서는 다른 포스트에서 알아보기로 하고 이제 간단한 ts 파일(typescript file)을 하나 생성합니다.이름을 hello.ts라고 하죠.다음과 같은 코드를 입력합니다.class Greeting {    greeting: string;    constructor(message: string) {        this.greeting = message;    }    sayHello() {        return \"Hello \" + this.greeting;    }}let tmp = new Greeting(\"World!!\");console.log(tmp.sayHello());내가 알고있던 javascript가 아니라서 당황스럽지요? 별로 어렵지 않습니다. 객체지향 언어를 알고 있으면더욱 더 쉽게 접근할 수 있습니다. 여하간 이렇게 코딩을 하고 저장하면 자동적으로 컴파일을 진행하고 그 결과파일(.js)을 생성해 줍니다.마지막으로 coding convention을 지정할 수 있는 tslint를 설치하도록 하겠습니다. 반드시 설치해야하는건 아니지만발생할 수 있는 오류를 미리 감지하고 coding convention을 맞추기 위해서 사용하는 것이 일반적입니다.WebStorm에서 다시 터미널을 열고 다음과 같이 입력하여 tslint를 설치합니다. 역시 global mode로 설치합니다.  npm install -g tslint그리고 다시 설정으로 들어갑니다.  Files - Settings - Languages &amp; Frameworks - TypeScript - TSLint 를 선택하면 아래와 같은 화면을 볼 수 있습니다.Enable를 check합니다. tslint.json을 찾아서 Cofiguration file로 이용한다는 군요.tslint.json 파일이 있어야 하니 Terminal을 열어서 다음과 같이 입력해서 tslint.json도 생성해 줍니다.  tslint --init이제 우리가 작성한 hello.ts 파일을 다시 열어보면 여러가지 알수없는(?) 빨간색들이 산재해 있는것을 보실 수 있습니다.에러는 아니지만 tslint에 의해서 coding convention에 위배되는 것들입니다.적절하게 수정해야 합니다. 설정해야 하는 것이들 많이 있지만 연습삼아 한가지만 설정하겠습니다. console에 대한 tslint 오류를 없애보도록 하죠.수정한 tslint.json파일은 다음과 같습니다.{    \"defaultSeverity\": \"error\",    \"extends\": [        \"tslint:recommended\"    ],    \"jsRules\": {},    \"rules\": {        \"no-console\": false    },    \"rulesDirectory\": []}오류를 수정한 최종 hello.ts파일은 다음과 같습니다.class Greeting {    private greeting: string;    constructor(message: string) {        this.greeting = message;    }    public sayHello() {        return \"Hello \" + this.greeting;    }}let tmp = new Greeting(\"World!!\");console.log(tmp.sayHello());여기까지해서 TypeScript를 학습하기 위한 기본적인 환경설정을 잡으시면 됩니다.  tslint는 실 개발시에는 필요하지만 처음 TypeScript를 공부할 때는 끄고 하시는게 정신건강에 이로울 수 있습니다.사실 쓸데없는 coding convention도 많거든요.End.",
        "url": "/typescript-introduction"
    }
    ,
    
    "what-is-metaprogramming": {
        "title": "What is Meta Programming?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction특정 형태의 코드를 작성한 후 컴파일하면 그 코드가 의미하는 다른언어의 코드( Java나 C++ )가 생성되는 프로그래밍을 지칭합니다. 메타프로그래밍 이란?메타프로그래밍( template metaprogramming )이라고 불리는 프로그래밍 기법은 template을 기반으로 compiler에게 다른 언어의 프로그램 코드를 생성하도록 하는 방식을 지칭합니다. 결과물이 machine code가 아닌다른 프로그래밍언어로 전환되는 것이기 때문에 compiler라는 용어대신에 transpiler라는 표현을 쓰기도 합니다. 장점과 단점이런 Meta Programming은 다음과 같은 장점과 단점을 가지고 있습니다.Advantage  컴파일 타임에 최적화가 이루어지고 결과적으로 실행 시 수행속도가 빨라질 수 있습니다.  일반화 프로그래밍( Generic Programming )이 가능합니다. 프로그래머는 처리할 구조와 데이터에 집중하고 컴파일러에 의해 특정 언어로 변환이 되는 구조이기 때문입니다.  결과로 도출되는 언어가 갖지 못하는 여러가지 개념들을 template에 정의해서 작성하고 이를결과언어로 적절하게 표현하여 기능상의 확장을 손쉽게 가져올 수 있습니다.Disadvantage  일반적으로 Template Metaprogramming은 또 다른 형식으로 프로그래밍 하기 때문에코드 자체가 더 난해합니다. 즉, Readability에 문제가 있습니다.  compiler에 의해서 새로운 코드가 생성되는 구조이기 때문에 compiler에 대한 의존도가 상당히 높습니다. 따라서 이식성의 문제가 발생할 여지를 가지고 있습니다.End.",
        "url": "/what-is-metaprogramming"
    }
    ,
    
    "what-is-yaml": {
        "title": "What is YAML?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionYAML은 JSON이나 XML처럼 데이터를 표현하는 하나의 양식입니다. 처음에는 좀 다른 의미였지만 현재는데이터를 표현하는 목적으로 사용됩니다. YAML 이란?YAML은 데이터를 사람이 쉽게 읽을 수 있는 형태로 표현하는데 사용되는 데이터 직렬화 양식입니다.데이터 직렬화(Data Serialization)란 구조화된 데이터를 특정 format으로 변환하는 개념입니다.단, 변환된 format은 본래 구조화된 데이터로 복구될 수 있어야 하고 변환된 format 형태로 공유 혹은 저장되는 것을 허용해야 합니다.YAML과 마찬가지로 우리가 자주 사용하는 XML이나 JSON 역시 데이터 직렬화 양식입니다.YAML 이라는 이름은 원래 Yet Another Markup Language(또 다른 마크업 언어)의 약어였으나 YAML의 실제 사용이마크업이 아닌 데이터 중심으로 사용되기 시작하자 YAML Ain’t Markup Language(YAML은 마크업 언어가 아니다)라는재귀적인 이름으로 변경되었습니다.우리나라 말로는 야믈 이라고 발음합니다.일반적으로 Ruby나 Python 개발자는 property파일로 많이 이용하고 있지만 C#이나 Java 개발자에게는 좀 생소합니다.Spring Boot도 현재 YAML을 지원하고 있습니다.일단 YAML은 property 형태로 어떻게 사용된다라는 식으로만 알고 있어도 충분할 듯 싶습니다. 혹시 나중에 YAML을본격적으로 사용하게 되는 날이 오면 그 때 조금 더 자세히 알아보도록 하겠습니다.(그런데 사실.. 그런날은 올거 같지 않습니다.)End.",
        "url": "/what_is_yaml"
    }
    ,
    
    "kramdown-image-resize": {
        "title": "GitHub Page에서 Image Resize 방법",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introductionkramdown에서 image를 표현할 때 resize하는 방법입니다.기본 markdown에서 이미지를 사용하는 방법은 다음과 같습니다.![이미지 텍스트](https://github.com/favicon.ico)GitHub Page는 현재 markdown engine으로 kramdown을 사용할 수 있습니다. kramdown에서는다음의 문법으로 이미지를 원하는 사이즈로 resizing 할 수 있습니다.![이미지 텍스트](https://github.com/favicon.ico){: height=\"100px\" width=\"100px\"}조금 더 일반화 시켜서 말하자면 {: height=\"100px\" width=\"100px\"} 부분은 Tag로 변환될 때 특정 속성을 붙이는 역할을 합니다. 만약 {: class=\"myStyle\" }이라고 했다면만들어지는 Tag에 class=\"myStyle\"이라는 속성이 붙게됩니다.End.",
        "url": "/kramdown-image-resize"
    }
    ,
    
    "jekyll-sitemap": {
        "title": "Jekyll 기반의 GitHub Page 생성(6)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Google Search Console 활용이번에는 우리의 GitHub Page를 Google 검색엔진에 노출시켜 작성한 글이 다른 사람에게 쉽게 노출되도록 처리해 보겠습니다. 이 작업을 하지 않으면 작성된 글이 웹에 노출될 확률이 현저하게 떨어집니다.Google이 제공하는 Google Search Console을 이용하여 내 GitHub Page의 domain을 등록시키고 sitemap.xml을생성해 Google Search Console에 제출하면 됩니다. sitemap.xml을 등록해 두면 Google 검색 크롤러가 주기적으로페이지를 크롤링하여 indexing하게 됩니다.그럼 간단히 시작해 보겠습니다.  먼저 D:/blogmaker 폴더 아래에 robots.txt 파일을 생성합니다.정확히 말하면 GitHub Page의 root밑에 robots.txt가 존재하면 됩니다.User-agent: *Allow: /Sitemap: https://moon9342.github.io/sitemap.xmlGitHub Page를 이용하기 때문에 모든 검색엔진을 다 설정했습니다. 만약 특정 위치가 크롤링이 되지 않게끔설정하려면 다음과 같이 처리하면 됩니다.User-agent: *Allow: /User-agent: *Disallow: /privateData/Sitemap: https://moon9342.github.io/sitemap.xmlrobots.txt에 대한 조금 더 자세한 설명을 보실려면 여기를 클릭하세요.그런다음 sitemap.xml을 작성해야 합니다. sitemap.xml 역시 GitHub Page의 root밑에 존재해야 하며추후에 Google Search Console에 제출해야 합니다.  D:/blogmaker 폴더 아래에 sitemap.xml 파일을 생성합니다.다음과 같은 형태로 작성합니다.---layout: null---&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd&quot;        xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;    {% for post in site.posts %}    &lt;url&gt;        &lt;loc&gt;{{ site.url }}{{ post.url }}.html&lt;/loc&gt;        {% if post.lastmod == null %}        &lt;lastmod&gt;{{ post.date | date_to_xmlschema }}&lt;/lastmod&gt;        {% else %}        &lt;lastmod&gt;{{ post.lastmod | date_to_xmlschema }}&lt;/lastmod&gt;        {% endif %}        {% if post.sitemap.changefreq == null %}        &lt;changefreq&gt;weekly&lt;/changefreq&gt;        {% else %}        &lt;changefreq&gt;{{ post.sitemap.changefreq }}&lt;/changefreq&gt;        {% endif %}        {% if post.sitemap.priority == null %}        &lt;priority&gt;0.5&lt;/priority&gt;        {% else %}        &lt;priority&gt;{{ post.sitemap.priority }}&lt;/priority&gt;        {% endif %}    &lt;/url&gt;    {% endfor %}&lt;/urlset&gt;작성이 끝났으면 이제 Google Search Console에 접속합니다. 아래 처럼 자신의 Github page url을 입력합니다.정상적으로 등록되면 아래와 같은 화면을 보실 수 있습니다.왼쪽 메뉴의 크롤링 - Sitemaps를 선택해 sitemap.xml을 추가합니다. 먼저 테스트를 진행한 다음 이상이 없으면 sitemap.xml 파일을 추가합니다. 정상적으로 처리되면 다음과 같은 화면을 보실 수 있습니다.  추후에 site:moon9342.github.io을 브라우져 주소창에 넣고 접속하면 현재 indexing이 어떻게 되어 있나를 확인할 수 있습니다.End.",
        "url": "/jekyll-sitemap"
    }
    ,
    
    "jekyll-search": {
        "title": "Jekyll 기반의 GitHub Page 생성(5)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 lunr.js를 이용한 Search 기능 추가Jekyll은 정적 사이트 generator이기 때문에 검색 기능이 따로 없습니다. 여러가지 방법을 동원해서 만들 수 있긴 하지만 최종적으로 2가지 방법이 적당할 듯 보입니다.하나는 Google Custom Search를 이용하여 블로그내 검색 기능을 추가하는 것입니다. 쉽고 편하게 검색 기능을 붙이수는 있으나 다음과 같은 단점이 있습니다.  광고가 뜬다 ( 참을 수 있습니다. )  style을 조절하기가 쉽지 않다. ( 참기 힘듭니다. 안 예뻐요! )Google Custom Search는 일단 제외하고 조금 찾아보니 lunr.js를 이용하면 검색 기능을 어렵지 않게 붙일 수 있을 듯 보였습니다. lunr.js는 client side full-text search engine입니다. 검색 기능을 붙이는 방식은 아래의두 사이트를 참고 하였습니다.  Jekyll search using lunr.js  한글 검색 패치Jasper2 theme가 가지고 있는 subscribe 화면을 수정해서 search 기능을 구현해 보겠습니다.Jasper2 theme는 subscribe 기능을 위한 링크를 가지고 있습니다.해당 링크를 누르면 다음과 같은 그림을 볼 수 있습니다.흠.. 새로운 포스트가 등록될 때마다 메일로 전송해주는 것이군요. 당연히 외부 기능을 제공받아야 사용할 수 있습니다.Jasper2 theme는 말 그대로 theme입니다. 모양만 제공해 주는것이지요.저는 이 화면을 검색 화면으로 대체해서 사용했습니다.먼저 _includes/site-nav.html파일을 열어 블로그 안에서 표현되는 Subscribe라는 글자를 Search로 변경합니다.&lt;div class=\"site-nav-right\"&gt;        &lt;div class=\"social-links\"&gt;            {% if site.facebook %}                &lt;a class=\"social-link social-link-fb\"                    href=\"https://facebook.com/{{ site.facebook }}\"                    target=\"_blank\"                    rel=\"noopener\"&gt;{% include facebook.html %}&lt;/a&gt;            {% endif %}            {% if site.twitter %}                &lt;a class=\"social-link social-link-tw\"                    href=\"https://twitter.com/{{ site.twitter }}\"                    target=\"_blank\"                    rel=\"noopener\"&gt;{% include twitter.html %}&lt;/a&gt;            {% endif %}        &lt;/div&gt;        {% if site.subscribers %}            &lt;a class=\"subscribe-button\" href=\"#subscribe\"&gt;Search&lt;/a&gt;        {% endif %}    &lt;/div&gt;맨 아래쪽&lt;a class=\"subscribe-button\" href=\"#subscribe\"&gt;Search&lt;/a&gt;라고 보이는 부분을 수정했습니다.(단순히 Subscribe라는 글자를 Search로 변경했습니다.)그 다음은 화면을 검색 페이지에 맞게 수정하는 것입니다._layouts/default.html을 열어서 검색 화면으로 수정합니다.{% if site.subscribers %}        &lt;div id=\"subscribe\" class=\"subscribe-overlay\"&gt;            &lt;a class=\"subscribe-overlay-close\" href=\"#\"&gt;&lt;/a&gt;            &lt;div class=\"subscribe-overlay-content\"&gt;                {% if site.logo %}                    &lt;img class=\"subscribe-overlay-logo\"                          src=\"{{ site.baseurl }}{{ site.logo }}\"                          alt=\"{{ site.title }}\" /&gt;                {% endif %}                &lt;h1 class=\"subscribe-overlay-title\"&gt;Search {{ site.title }}&lt;/h1&gt;                &lt;p class=\"subscribe-overlay-description\"&gt;                lunr.js를 이용한 posts 검색 &lt;/p&gt;                {% include subscribe-form.html placeholder=\"keyword\" %}            &lt;/div&gt;        &lt;/div&gt;{% endif %}그 다음으로 _includes/subscribe-form.html을 열어서 수정했습니다.코드는 아래와 같습니다.&lt;span id=\"searchform\" method=\"post\" action=\"/subscribe/\" class=\"\"&gt;    &lt;input class=\"confirm\" type=\"hidden\" name=\"confirm\"  /&gt;    &lt;input class=\"location\" type=\"hidden\" name=\"location\"  /&gt;    &lt;input class=\"referrer\" type=\"hidden\" name=\"referrer\"  /&gt;    &lt;div class=\"form-group\"&gt;        &lt;input class=\"subscribe-email\" onkeyup=\"myFunc()\"                id=\"searchtext\" type=\"text\" name=\"searchtext\"                 placeholder=\"Search...\" /&gt;    &lt;/div&gt;    &lt;script type=\"text/javascript\"&gt;        function myFunc() {            if(event.keyCode == 13) {                var url = encodeURIComponent($(\"#searchtext\").val());                location.href = \"/search.html?query=\" + url;            }        }    &lt;/script&gt;&lt;/span&gt;기존 코드를 수정한것이기 때문에 불필요한 코드도 좀 들어가 있습니다. 중요한 내용은입력상자에서 검색어를 입력하고 enter를 누르면 search.html페이지로 이동하면서검색 결과가 search.html에 출력된다는 정도입니다.이제 검색 결과가 표현될 D:/blogmaker/search.html을 생성해서 다음과 같은 코드를 삽입합니다.---layout: pagecurrent: searchtitle: Search Resultnavigation: truelogo:class: page-templatesubclass: &#39;post page&#39;---&lt;form action=&quot;/search&quot; method=&quot;get&quot; hidden=&quot;hidden&quot;&gt;    &lt;label for=&quot;search-box&quot;&gt;&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;search-box&quot; name=&quot;query&quot;&gt;&lt;/form&gt;&lt;ul class=&quot;mylist&quot; id=&quot;search-results&quot;&gt;&lt;/ul&gt;&lt;script&gt;    window.store = {    {% for post in site.posts %}    &quot;{{ post.url | slugify }}&quot;: {        &quot;title&quot;: &quot;{{ post.title | xml_escape }}&quot;,            &quot;author&quot;: &quot;{{ post.author | xml_escape }}&quot;,            &quot;category&quot;: &quot;{{ post.category | xml_escape }}&quot;,            &quot;content&quot;: {{ post.content | strip_html | strip_newlines | jsonify }},        &quot;url&quot;: &quot;{{ post.url | xml_escape }}&quot;    }    {% unless forloop.last %},{% endunless %}    {% endfor %}    };&lt;/script&gt;&lt;script src=&quot;assets/js/lunr.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/search.js&quot;&gt;&lt;/script&gt;이제 마지막 단계만 남았습니다. 사용되는 lunr.js와 search.js를 assets/js 폴더 안에 복사해 주어야 합니다.lunr.js는 https://lunrjs.com/에서 받으실 수 있습니다. CDN을 이용하셔도 됩니다.search.js는 다음과 같은 코드로 작성합니다.(function() {    function displaySearchResults(results, store) {        var searchResults = document.getElementById(&#39;search-results&#39;);        if (results.length) { // Are there any results?            var appendString = &#39;&#39;;            for (var i = 0; i &lt; results.length; i++) {  // Iterate over the results                var item = store[results[i].ref];                appendString += &#39;&lt;li&gt;&lt;a href=&quot;&#39; + item.url + &#39;&quot;&gt;&lt;h6&gt;&#39; + item.title + &#39;&lt;/h6&gt;&lt;/a&gt;&#39;;                appendString += &#39;&lt;p&gt;&#39; + item.content.substring(0, 150) + &#39;...&lt;/p&gt;&lt;/li&gt;&#39;;            }            searchResults.innerHTML = appendString;        } else {            searchResults.innerHTML = &#39;&lt;li&gt;검색 결과가 없습니다.&lt;/li&gt;&#39;;        }    }    function getQueryVariable(variable) {        var query = window.location.search.substring(1);        var vars = query.split(&#39;&amp;&#39;);        for (var i = 0; i &lt; vars.length; i++) {            var pair = vars[i].split(&#39;=&#39;);            if (pair[0] === variable) {                return decodeURIComponent(pair[1].replace(/\\+/g, &#39;%20&#39;));            }        }    }    function trimmerEnKo(token) {        return token            .replace(/^[^\\w가-힣]+/, &#39;&#39;)            .replace(/[^\\w가-힣]+$/, &#39;&#39;);    };    var searchTerm = getQueryVariable(&#39;query&#39;);    if (searchTerm) {        document.getElementById(&#39;search-box&#39;).setAttribute(&quot;value&quot;, searchTerm);        // Initalize lunr with the fields it will be searching on. I&#39;ve given title        // a boost of 10 to indicate matches on this field are more important.        var idx = lunr(function () {            this.pipeline.reset();            this.pipeline.add(                trimmerEnKo,                lunr.stopWordFilter,                lunr.stemmer            );            this.field(&#39;id&#39;);            this.field(&#39;title&#39;, { boost: 10 });            this.field(&#39;author&#39;);            this.field(&#39;category&#39;);            this.field(&#39;content&#39;);        });        for (var key in window.store) { // Add the data to lunr            idx.add({                &#39;id&#39;: key,                &#39;title&#39;: window.store[key].title,                &#39;author&#39;: window.store[key].author,                &#39;category&#39;: window.store[key].category,                &#39;content&#39;: window.store[key].content            });            var results = idx.search(searchTerm); // Get lunr to perform a search            displaySearchResults(results, window.store); // We&#39;ll write this in the next section        }    }})();잘 동작하는지 한번 실행시켜보겠습니다.검색 결과 화면에 대한 css는 취향에 맞게 설정해 사용하면 됩니다.!!End.",
        "url": "/jekyll-search"
    }
    ,
    
    "jekyll-rouge": {
        "title": "Jekyll 기반의 GitHub Page 생성(4)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 rouge를 이용한 syntax highlightingrouge는 pure-ruby syntax highlighter입니다. 이를 이용하면 블로그에 코드를 붙여넣을 때 간단하게 syntax highlighting 기능을 이용할 수 있습니다.Jekyll은 syntax highlighting을 위해 Pygments도 지원했었는데 Jekyll 3(2016년 02월)부터 Pygments를지원하지 않습니다._config.yml 설정 파일에 다음과 같이 설정한 부분이 있습니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가......._config.yml에 설정은 잡아놨는데 실제 설치는 아직 안했습니다. gem을 이용하여 rouge를 설치합니다.command 창을 열어서 다음과 같이 입력합니다.  gem install rougerouge는 특정 style을 가진 css파일을 생성하기 위한 command-line tool을 가지고 있습니다. rougify명령을 이용하면 우리가 원하는 스타일의 css 파일을 생성할 수 있습니다.일단 다음의 명령어로 어떤 스타일을 사용할 수 있는지 확인합니다.  rougify help style아래 부분에 available themes가 보이는 군요. 여기에서 맘에 드는거 하나를 선택해서 style.css를 생성할 수 있습니다.제가 사용하고 있는 theme는 monokai.sublime 입니다.이제 다음과 같은 명령어로 원하는 theme로 css 파일을 생성합니다.  rougify style monokai.sublime &gt; assets/css/syntax.css자 이제 D:/blogmaker/assets/css/syntax.css 파일이 생성되었습니다. 이 css파일에 대한 링크를 post에서 사용할 수 있도록 _layouts/default.html에 추가해야 합니다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- Document Settings --&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;    &lt;!-- Base Meta --&gt;    ...    ...       &lt;!-- 웹 폰트 설정 --&gt;    &lt;link rel=\"stylesheet\"           href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;    &lt;!-- syntax.css --&gt;    &lt;link rel=\"stylesheet\" href=\"/assets/built/syntax.css\"&gt;새로운 css 파일이 생성되었으니 gulp를 이용해 css task를 실행시켜야 합니다. 그래야 minified된 css파일이생성이 되서 블로그에서 이용할 수 있을 테니까요.이제 준비가 끝났습니다. 포스트에서 글 작성할 때 다음과 같은 code block을 이용하게 됩니다.code block에 대해 사용하는 언어를 명시해 주면 그에 맞춰 문법 강조를 하게 됩니다. ~~~javascriptfunction syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}~~~위의 코드에 대한 결과입니다.function syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}End.",
        "url": "/jekyll-rouge"
    }
    ,
    
    "jekyll-font": {
        "title": "Jekyll 기반의 GitHub Page 생성(3)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 웹 폰트 설정블로그를 운영할 때 가장 신경써야 하는 부분 중 하나는 readability입니다. Jasper2는 영문일 경우 상당히 가독성이 좋은데한글을 사용하니 폰트때문에 가독성이 확 떨어지더군요. 그래서 폰트를 좀 바꾸어봤습니다.당연한 말이지만 이 부분은 “이게 정답이다” 라는게 아닙니다.  전 이렇게 바꾸었어요~ 하는 부분이지요.하지만 대부분의 Jekyll theme가 비슷한 구조를 가지고 있기 때문에 다른 theme를 사용하실 때 비슷하게 적용하실 수 있을듯 합니다.먼저 사용할 웹 폰트를 물색해야 합니다. 구글에서 찾아보면 원하시는 웹 폰트를 쉽게 찾을 수 있습니다.만만한 나눔고딕 폰트를 이용해 보겠습니다.&lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;나눔고딕 폰트에 대한 링크입니다.이제 _layout/default.html 파일을 열어서 해당 폰트 링크를 넣어줍니다. 다음과 비슷하게 되겠네요.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- Document Settings --&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;    &lt;!-- Base Meta --&gt;    ...    ...    &lt;!-- 웹 폰트 설정 --&gt;    &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;이제 css파일을 수정해서 특정 class에 대한 font-family에 나눔고딕 폰트를 추가해 주면 되겠네요.Jasper2에서 일반적인 포스트는 모두 .post-full-content css class의 영향을 받습니다.다른 theme를 이용하시는 분은 포스트들이 어떤 css class에 영향을 받는지를 확인하셔서 그 class를 찾아 수정하시면 됩니다.assets/css/screen.css 파일을 열어서 .post-full-content 부분을 찾아 다음과 같이 수정합니다.Georgia는 영문폰트이기 때문에 영문은 일단 이 폰트를 먼저 이용하게 되고 한글 부분은 Nanum Gothic을 사용하게 됩니다..post-full-content {    position: relative;    margin: 0 auto;    padding: 70px 100px 0;    min-height: 230px;    font-family: Georgia, 'Nanum Gothic', serif;    font-size: 2.2rem;    line-height: 1.6em;    background: #fff;}css가 변경되었으니 gulp를 이용하여 css task를 수행합니다. Jasper2 theme는 gulp에 대한 설정을 포함하고 있습니다. NPM(Node Package Manager)를 이용해gulp를 설치하고 gulpfile.js 파일을 이용해 css task를 수행하면 결과적으로 assets/built 폴더에 수정된 내용으로 minified된 css파일이 생성되게 됩니다.이제 다시 bundle exec jekyll serve을 수행하면 새로 만들어진 css를 이용하여 블로그가 생성될 것이고 한글로 쓴 내용의 폰트가 나눔고딕으로 변경되는 것을 볼 수 있습니다.End.",
        "url": "/jekyll-font"
    }
    ,
    
    "jekyll-struct": {
        "title": "Jekyll 기반의 GitHub Page 생성(2)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Github Page Publishing이전 포스트에서 로컬 서버를 실행시켜 Jasper2 theme를 이용한 블로그가 실행되는 것 까지 확인을 했습니다.Jasper2나 혹은 다른 theme를 사용하실 때도 이제부터가 문제입니다. 자신의 입맛에 맞도록 theme를 수정해야 하는데이게 쉬운일이 아닙니다. 개발쪽에 있으신 분들은 쉽게 접근하실 수 있지만 그렇지 않은 경우 상당히 난해합니다.“그냥 Tistory 쓰고말지” 라는 말이 나올정도로요.사실 GitHub Page에서 블로그를 운영하는 사람들 중 많은 사람이 Front-End 개발이 가능한 사람들 입니다.Jekyll은 정적 사이트 생성기 입니다. Liquid template을 기반으로 markdown형식의 텍스트파일을 HTML로 변환해주는 변환 도구라고 보시면 됩니다.이전 포스트에서 Jasper2 theme를 압축해제한 폴더를 기억하시나요? D:/blogmaker 였습니다. 이 폴더가 Jekyll Source Folder가 됩니다.이 Jekyll Source Folder 안의 _post라는 폴더에 우리가 작성하려는 글을 markdown 형식으로 작성합니다. 그런 후 bundle exec jekyll serve 명령을 이용하면 build시키면 저장된 글에 대해 컴파일이 진행되고 결과물이 destination 폴더에 생성됩니다.GitHub Page에 올려 사용하는 실제적인 블로그가 바로 이 destination 폴더 안에 있는 내용입니다. 따라서 Git을 이용하여 변환된 결과물(destination 폴더안의 내용)을 GitHub Page와 연동되는 GitHub Repository에 push해 주어야 합니다.그럼 천천히 진행해 보겠습니다.위에서 언급했듯이 D:/blogmaker가 우리의 Jekyll Source Folder입니다.설정된 대로 컴파일 과정을 거치면 destination 폴더에 결과물을 저장하게 됩니다. Jekyll은 설정파일로 YAML 파일을 이용합니다. YAML에 대한 설명은 YAML이란 링크에 간단히 정리되어 있습니다.이 설정에 대한 파일이 바로 _config.yml입니다. 블로그 생성에 대한 전체 환경 세팅을 담당하는 파일이라고 생각하시면 됩니다.  D:/blogmaker폴더안에서 _config.yml을 찾아 해당내용을 자신에 맞게 수정해서 사용해야 합니다.아래는 _config.yml에 대한 내용과 그 설명입니다. 주석이 달린 부분을 중심으로 보시면 됩니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 10# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Blog# 자신의 blog title.description: Development &amp; Technical Training# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: sunghoons-blog# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics:  # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]exclude: [vendor]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source: destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안으로 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.production_url:  https://moon9342.github.io/source_url:  https://github.com/moon9342/GitHubPageMaker/# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules는 포함시키자)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules위의 설정파일에 destination: ./output/으로 설정되어 있기 때문에 command 창에서 “bundle exec jekyll serve”명령을 수행하면 D:/blogmaker/output/ 폴더가 생성되고 여기에 컴파일된 결과파일들이 저장되게 됩니다.결과파일을 D:/blogmaker ( Jekyll Source Folder )밑의 output folder로 지정한 이유는 나중에 Travis-CI와연동하기 위해서 입니다. ( git submodule로 처리하기 위함입니다. )Travis-CI를 이용하지 않고 그냥 수동으로 결과파일을 자신의 GitHub Page에 올리려면 설정파일에 destination: ../[GitHubPage]/과 같은 형식으로 설정하시면 됩니다.설정 후 “bundle exec jekyll serve” 명령을 수행하면D:/[GitHubPage]/라는 폴더가 생성되고 여기에 컴파일된 결과파일들이 저장되게 됩니다.Jekyll build 작업을 할 때 한가지 주의해야 할 점이 있습니다.기본적으로 Jekyll build는 development 세팅으로 진행됩니다. 만약 실제 GitHub Page에 Publishing할목적으로 build하는 것이라면 JEKYLL_ENV 환경변수의 값을 production으로 설정한 후 build를 진행해야 합니다. (참고링크)  위의 작업을 하지 않으면 정상적으로 URL이 생성되지 않습니다. localhost로 세팅됩니다.Travis-CI에 대한 설정은 다른 포스트에서 살펴보기로 하고 여기서는 수동으로 결과 파일을 GitHub Repository (GitHub Page에 대한 Repository)에 올리는 것으로 설명합니다.( destination: ../[GitHubPage]/ 으로 설정되어 있다고 가정 )이제 D:/[GitHubPage]/파일안의 내용을 GitHub Page에 Publishing하시면 됩니다.  먼저 GitHub에 접속해서 새로운 Repository를 생성합니다. 주의할 점은Repository의 이름을 (자신의 github id).github.io로 지정해야 합니다.  Git을 이용하여 방금 만든 D:/[GitHubPage]/ 안의 내용을 Repository에 push합니다.정상적으로 push가 진행되었다면 이제 https://(자신의 github id).github.io로 접속해서 블로그가 잘 개설이 되었는지 확인합니다.이 포스트에서는 Git과 GitHub에 대한 기본적인 사용법에 대해서는 다루지 않습니다. 해당 부분은 저의 다른 포스트나혹은 여기를 이용하여 살펴보시면될 듯 합니다.GitHub Page에 블로그가 잘 개설되었나요? 블로그가 잘 개설되었다면 이제 메뉴를 원하는 형식으로 바꾸고 새로운 내용의 post도 작성해서 블로그에 올리시면 됩니다. _posts 폴더에 기존에 있는 .md file을 복사해서새로운 내용을 만들고 포스팅 작업을 해 보세요.End.",
        "url": "/jekyll-struct"
    }
    ,
    
    "jekyll-start": {
        "title": "Jekyll 기반의 GitHub Page 생성(1)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 환경설정Jekyll을 이용해 GitHub Page에 기본적인 블로그를 생성하는 방법은 여러 다른 블로그나 사이트에 자세하게 나와 있으니 저는 제가 사용하는 Jasper2 theme를 이용하여 GitHub Page에 블로그를 개설하고 사용하는 방법에 대해서 알아보겠습니다. (Windows 10환경으로 진행합니다.)  Windows 환경은 조금 까다롭습니다. Ruby 때문에 그렇습니다. 먼저 컴퓨터의 계정 ID가 한글로 되어 있으면 여러 문제가 발생합니다.한글계정이라면 먼저 계정부터 영문으로 바꾸고 시작해야 합니다.아래의 그림처럼 컴퓨터의 계정이 영문으로 되어있는지 확인합니다.제일 먼저 해야하는 작업은 Ruby를 설치하는 것입니다.Ruby는 RubyInstaller for Windows 에서 받으시면 됩니다.사용할 버전은 2.2.6입니다. 다른 버전 사용할 경우 문제가 발생할 여지가 있습니다. 파란색 박스로 되어 있는 링크를 눌러파일을 받으시면 됩니다.다운로드 받은 Ruby를 설치합니다.  아래 그림과 같이 기본 경로(C:/Ruby22-x64)에 PATH 환경변수 설정만 추가해서 설치합니다.Ruby 설치가 끝나면 DevKit을 설치해야 합니다. DevKit을 설치하지 않으면 Jekyll 설치할 때 Error가 발생합니다.Ruby의 DevKit은 마찬가지로 RubyInstaller for Windows 에서 받으시면 됩니다. 파란색 박스로 되어 있는 링크를 눌러 파일을 다운로드 합니다. ( 64bit기준 )다운로드받은 파일을 실행하고 압축이 풀릴 폴더를 지정합니다. C:/RubyDevKit으로 지정합니다. (다른 경로를 사용해도 무방합니다.)따로 설치파일이 존재하는게 아니기 때문에 command 창을 열어서 초기화 및 설치작업을 진행합니다.  ruby dk.rb init  ruby dk.rb install이제 bundler를 설치합니다. bundler는 Ruby application 개발을 위한 일관된 환경을 제공합니다. 단편적 기능 중 하나는Ruby application이 사용하는 gem의 dependency를 관리하는 것입니다. 우리는 나중에 이 bundler를 이용하여 Jekyll을사용할 것이기 때문에 설치해야 합니다.  gem install bundler기본적인 준비과정은 끝났습니다.그 다음 과정은 우리가 사용할 Theme인 Jasper2를 다운받아서 원하는 폴더에 압축을 풀어줍니다. D:/blogmaker에 다음과 같은 형태로 압축을 풀어 저장했습니다.  여기서 주의해야 할 점은 폴더 이름에 공백이 포함되어 있으면 나중에 css빌드할 때 문제가 발생합니다. 즉, D:/blogmaker처럼 폴더는 소문자로 공백없이 생성합니다.command 창을 열어서 해당 폴더(D:/blogmaker)에서 다음과 같이 실행합니다.  bundle exec jekyll serve먼가 수행될거라는 기대와는 달리 다음과 같은 에러가 발생합니다.  Could not find gem ‘jekyll (~&gt; 3.6.2) x64-mingw32’ in any of the gem sources listed in your Gemfile. Run bundle install to install missing gems.command 창에서 다음의 명령을 차례로 실행해 필요한 gem을 설치합니다.  gem cleanup  bundle install이제 다시 아래와 같은 명령을 이용하여 실행시킵니다.  bundle exec jekyll serveJekyll은 template처리를 위해 Liquid template 언어를 사용합니다. template 처리를 거쳐 결과 파일이특정 폴더에 저장되고 로컬 웹 서버가 실행되어서 서비스해 주기 때문에 로컬에서 블로그를 확인해 볼 수 있습니다.build 과정을 거쳐 로컬 웹서버를 이용하여 웹 서비스까지 실행시켜주는 명령이라고 생각하시면 됩니다.아래와 같은 메시지가 출력되면서 로컬 웹 서버가 4000번 포트로 기동되고 http://localhost:4000/jasper2로 접속하면 테마페이지를 보실 수 있습니다.  일단 로컬에서 화면을 띄웠습니다. 이제 각 메뉴를 원하는 내용으로 바꾸고 이미지를 내 입맛에 맞게 수정하고 기타 등등의 기능들을 추가하면 될 듯 보입니다.End.",
        "url": "/jekyll-start"
    }
    ,
    
    "javascript-history": {
        "title": "JavaScript History",
            "author": "javascript",
            "category": "",
            "content": "Introduction아마도 JavaScript, ECMAScript, TypeScript라는 용어를 많이 들어봤을 텐데 정확하게 어떤 차이가 있는지이번 포스트에서 간단하게 정리를 해 보겠습니다. JavaScript과거부터 Web 작업을 해 오신 분들은 아시겠지만 JavaScript의 과거 인식은 “알면 좋고 몰라도 상관없는 딱 그 수준의 언어” 였습니다. 하지만 개발 방법론이 진화하면서 JavaScript기반의 Library나 Framework의 필요성이 증대되고 그에 따라JavaScript라는 언어의 위상도 상당히 올라갔습니다. ( HTML5와 Node.js의 역할이 지대했지요. )JavaScript라는 언어의 전신은 1995년 Netscape사에서 Brendan Eich가 Mocha라는 이름으로 만들어낸 스크립트 언어입니다. 개발을 완료하고 후에 LiveScript라는 이름으로 세상에 공개되었습니다. 그런데 이 시점에 Netscape사가 Java를 개발한 Sun Microsystems사와 협업하면서 Java applet이 큰 인기를 끌게 되었는데 이를 상업적으로 이용하고자 이름을 LiveScript에서 JavaScript로 변경하게 된 것입니다.  이름의 변경 순서가 Mocha  LiveScript  JavaScript 가 되는군요.MS(Microsoft)에서는 이에 대응하기 위해 JScript를 만들고 IE 3부터 JScript를 포함시켜서 제공했지요. 당연한 말이지만JavaScript와 JScript는 서로 비슷하지만 특징이 다릅니다. 그로인해 우리가 잘 알고있는 JavaScript의 고질적인 문제인 Fragmentation(파편화 현상)이 발생하게 됩니다. ECMAScript여하간 Netscape사는 이 JavaScript의 표준을 잡기 위해 ECMA(정보 통신기술 표준화 기구)에 표준화 작업을 요청합니다. 당연히JavaScript라는 이름을 사용하려고 했지만 Sun과의 라이선스 문제 때문에 ECMAScript라는 이름으로 표준화가 진행되게 됩니다.이렇게만 놓고 보면 JavaScript와 ECMAScript가 비슷한 의미로 사용되는 것처럼 보이는데 사실 작은 차이가 있습니다.우리가 흔희 말하는 JavaScript는 1개의 Core와 2개의 Module로 구성되어 있습니다. 여기서 1개의 Core는 JavaScript를 구성하고 있는 Script language(ECMAScript)입니다. 2개의 Module은 BOM(Browser Object Model), DOM(Document Object Model)을 지칭합니다.달리 말하자면 ECMAScript는 JavaScript를 구성하는 Core Script언어로 웹 환경에서만 사용되는 언어가 아닙니다. 웹 환경은 ECMAScript가 사용되는 환경 중 하나일 뿐입니다.  JavaScript = ECMAScript + BOM + DOM현재 ECMAScript version은 7까지 나와있습니다. (ECMAScript 2016 = ES7)이렇듯 JavaScript와 ECMAScript는 정확한 의미의 차이는 분명히 있지만 그냥 저냥 대충 통용해서 사용합니다. 흔히 우리가JavaScript라고 표현하면 ECMAScript를 의미한다고 보시면 됩니다. TypeScript그러면 TypeScript는 또 어떤걸까요? 왜 TypeScript가 대세로 떠오른 걸까요?TypeScript는 Microsoft에서 개발하여 2012년에 발표한 오픈 소스 프로그래밍 언어입니다. JavaScript로 대규모 application개발을 하기 위해 개발되었고 컴파일 과정을 거치면 JavaScript가 되는 언어입니다.CoffeeScript 처럼 compile하면 JavaScript가 생성되는 변환 언어의 한 종류라 볼 수 있습니다. 그냥 JavaScript로 개발하면 되지 굳이 이런 변환언어를 사용하는 이유는 무엇일까요? ( 이런 프로그래밍을 메타프로그래밍 이라고 합니다. )가장 큰 이유는 기능의 추가에 있습니다.변환언어의 가장 큰 장점은 변환되는 언어에 기능을 쉽게 추가할 수 있다는 것인데 예를 들면, 추상 클래스, 인터페이스, 정적 데이터타입 사용, 엄격한 타입 체크등을 JavaScript에 추가하여 개발을 쉽게 끌고 갈 수 있습니다.즉, 전통적인 OOP방식으로 JavaScript개발을 진행할 수 있다는 것이죠.  기존 객체지향 언어(Java, C++, C#)를 알고 있고 JavaScript를 알고 있으면 TypeScript를 아주 쉽게배울 수 있습니다.TypeScript는 다른 변환언어와는 다르게 JavaScript의 superset입니다. 그렇기 때문에 이미 JavaScript를 알고 있으면쉽게 TypeScript를 사용할 수 있으며 ES6(ECMAScript 2015)나 ES7(ECMAScript 2016)에서 제공되는 기능 중 필요한 것만 골라서 이용할 수 있습니다. 아래의 그림은 TypeScript와 ECMAScript간의 포함관계를 보여줍니다.( 이미지 출처 : https://angular2buch.de )2017년 3월부로 TypeScript는 Google의 공식언어 중 하나로 채택되었습니다. MS에서 개발한 언어를 Google이표준언어로 채택하다니 놀랍습니다. 그만큼 TypeScript의 언어적 기능이 좋고 앞으로의 발전가능성이 많다는 의미겠지요.기존 Google의 사내 표준언어 (Canonical Language)는 C, C++, Java, JavaScript, Python, Go 정도였는데 Google은 이 중 JavaScript를 이용하여 AngularJS(1.x)를 개발했었습니다.하지만 AngualrJS(1.x)의 차기버전인 Angular(2.x)를 개발하면서 JavaScript의 기능상의 한계를 느끼게 되고결국 2014년에 Google에서 발표한 AtScript를 이용해 Angular(2.x)를 개발하게 됩니다.하지만 TypeScript가 Angular의 표준언어 중 하나로 채택이 되면서 기존의 AtScript로 작성했던 Angular 2를 몽땅 TypeScript로 전환했습니다. Google에서 말하기로는 변환이 아주 쉬웠다고 하더군요.이렇게 TypeScript의 위상이 올라가면서 기존 Google에서 JavaScript의 대체 언어로 밀고있었던 Dart의 위상 역시 살짝 하락한 상태입니다. (물론 Google은 아니라고 하지만요. )  Angular는 공식적으로 3개의 언어를 지원합니다. (TypeScript, JavaScript, Dart)   그런데 공식문서에서나 커뮤니티활동에서 가장 많이 사용되는것은 TypeScript입니다. 결국 Angular는 꼭 해야할 것 중 하나이니 TypeScript도 그냥 해야지요..머..End.",
        "url": "/javascript-history"
    }
    
    
    };

</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://moon9342.github.io/">IT Blog</a> &copy; 2018</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/">GitHub Pages</a></section>
                <nav class="site-footer-nav">
                    <a href="mailto:moon9342@gmail.com">moon9342@gmail.com</a>
                    <a href="/">Latest Posts</a>
                    
                    
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search IT Blog</h1>
                <p class="subscribe-overlay-description">lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"  placeholder="Search..." />
    </div>
    <!--<button class="" onclick="myFunc()" id="searchBtn" type="button" ><span>Search</span></button>-->
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
    <!--<script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>-->
</span>


            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113135179-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
