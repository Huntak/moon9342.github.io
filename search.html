<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous">
    </script>

    <!-- 웹 폰트 설정 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- Font Awesome 설정 -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- custom.css -->
    <link rel="stylesheet" href="/assets/built/custom.css">

    <!-- syntax.css -->
    <link rel="stylesheet" href="/assets/built/syntax.css">

    <!-- gist.css -->
    <link rel="stylesheet" href="/assets/built/better-gist-styles.css">

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Development & Technical Training" />
    <link rel="shortcut icon" href="https://moon9342.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://moon9342.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="IT Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Development & Technical Training" />
    <meta property="og:url" content="https://moon9342.github.io/search" />
    <meta property="og:image" content="https://moon9342.github.io/assets/built/images/blog-cover.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Development & Technical Training" />
    <meta name="twitter:url" content="https://moon9342.github.io/" />
    <meta name="twitter:image" content="https://moon9342.github.io/assets/built/images/blog-cover.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="IT Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "IT Blog",
        "logo": "https://moon9342.github.io/"
    },
    "url": "https://moon9342.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://moon9342.github.io/assets/built/images/blog-cover.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://moon9342.github.io/search"
    },
    "description": "Development & Technical Training"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <!-- 사용자 browser 확인 코드 - Chrome이 아니면 경고 메시지 출력 -->

    <script>
        var agent = navigator.userAgent.toLowerCase();
        var _iPhone = false;
        var _chrome = false;
        var result = false;
        if (agent.indexOf("iphone") != -1) {
            _iPhone = true;
        }
        if (agent.indexOf("chrome") != -1) {
            _chrome = true;
        }

        if( _iPhone || _chrome ) {
            result = true;
        }

        if( !result ) {
            alert("이 블로그는 Google Chrome Browser에 최적화 되어 있습니다 !!");
        }

    </script>

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://moon9342.github.io">IT Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-back-end" role="menuitem"><a href="/tag/back-end/">Back End</a></li>
    <li class="nav-front-end" role="menuitem"><a href="/tag/front-end/">Front End</a></li>
    <li class="nav-miscellaneous-article" role="menuitem"><a href="/tag/miscellaneous-article/">Miscellaneous Article</a></li>
    <li class="nav-archive" role="menuitem"><a href="/archive.html">Archive</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>

    window.store = {
    
    "angular-lecture-lifecycle": {
        "title": "Angular 강좌(20) - Component LifeCycle",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Component Lifecycle이번 포스트에서는 Angular의 Lifecycle에 대해서 알아보겠습니다. 다른 Framework과 마찬가지로 Angular 역시여러 단계의 lifecycle을 관리합니다. Component와 Directive가 이 lifecycle의 영향을 받게 되며 각 lifecycle마다 제공되는hook method를 이용하여 특정 작업을 처리할 수 있습니다.이런 hook method는 interface형태로 우리에게 제공됩니다. Component 혹은 Directive class가 이 interface를 구현하고그 안의 특정 method를 overriding하는 식으로 hook method를 이용할 수 있습니다.Component를 대상으로 객체가 생성되고 소멸되기까지 호출되는 hook method를 순서대로 나열하면 다음과 같습니다. Directive는View를 가지고 있지 않기 때문에 ngAfter로 시작되는 hook method는 호출되지 않습니다.  constructor  ngOnChanges  ngOnInit  ngDoCheck  ngAfterContentInit  ngAfterContentChecked  ngAfterViewInit  ngAfterViewChecked  ngOnDestroy간단하게 Project를 하나 생성해서 각 lifecycle단계에서 해당 hook method가 호출되는지 확인하는 식으로 진행하시면 됩니다. constructorComponent 혹은 Directive가 생성될 때 호출됩니다. 사실 constructor는 Angular의 lifecycle의 단계에 포함될 내용은 아닙니다.TypeScript에서는 일반적으로 constructor에서 초기화를 진행합니다. 하지만 Angular에서 사용하는 속성의 초기화는 ngOnInit에서 하는것이 좋습니다. ngOnChanges@Input을 이용해 부모 Component가 자식 Component에게 데이터를 전달할 수 있습니다. ngOnChanges는 부모 Component에서 자식 Component로 데이터가 binding 될 때 혹은 변경되었을 때 호출됩니다. 따라서 @Input을 사용하지 않으면 호출되지 않습니다.정확하게는 부모 Component로부터 자식 Component에게 전달하는 primitive 값이 변경되거나 혹은 참조하는 객체의 reference가 변경되어야 호출됩니다. 즉, 참조하는 객체의 property가 변경되는 경우에는 ngOnChanges가 호출되지 않는다는 것 기억하셔야 합니다.@Input을 이용한 값의 binding은 생성자가 호출된 후에 일어납니다. 즉, 생성자에서 @Input을 이용해 binding한 값을 출력하면undefined가 출력되게 됩니다. 간단한 이벤트 처리를 통해 @Input으로 전달되는 값을 변경해보면 값이 변경될 때마다ngOnChanges hook method가 호출되는걸 확인할 수 있습니다.ngOnChanges hook method의 인자로 SimpleChanges 객체를 하나 받을 수 있습니다. 해당 객체를 이용하면 변경되기 이전값과이후값등을 알 수 있습니다.import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges {  @Input() myInput: string;  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {  }} ngOnInitngOnInit는 ngOnChanges가 호출된 이후에 모든 속성에 대한 초기화가 완료된 시점에 딱 한번만 호출됩니다. 즉, class가 가지고 있는속성과 @Input을 통해 값을 내려받은 속성이 모두 초기화가 된 이후에 호출됩니다. 결국 Component의 속성 참조는 ngOnInithook method이후에 참조하는 것이 좋습니다.결국 생성자는 Service의 Injection같은 사항을 처리하고 속성에 대한 초기화는 ngOnInit에서 처리하시는게 좋다는 말입니다.import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges {  @Input() myInput: string;  myString = 'Hello';  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`Constructor 호출!! =&gt; myString : ${this.myString}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {    console.log(`ngOnInit 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngOnInit 호출!! =&gt; myString : ${this.myString}`);  }} ngDoCheckngOnInit hook method가 호출된 이후에 호출됩니다. Component에서 발생하는 모든 상태변화에 반응하여 호출되어지는 hook method로Angular의 Changes Detection이 상태변화를 감지하면 자동으로 호출되게 됩니다. 한가지 주의하셔야 할 점은 ngOnChanges와는 다르게 primitive값의 변경, reference 객체의 변경, reference객체의 속성변경에 대한 모든 변경에 대해 해당 hook mehtod가호출된다는 점입니다. 심지에 이전값과 같은 값이 assign되었음에도 호출됩니다. 따라서 ngDoCheck을 많이 사용하게 되면그만큼 성능이 저하될 수 있습니다.import {Component, DoCheck, Input,         OnChanges, OnInit, SimpleChanges} from '@angular/core';interface IBook {  btitle: string;  bauthor: string;}@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges, DoCheck {  @Input() myInput: IBook;  myString = 'Hello';  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`Constructor 호출!! =&gt; myString : ${this.myString}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {    console.log(`ngOnInit 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngOnInit 호출!! =&gt; myString : ${this.myString}`);  }  ngDoCheck() {    console.log(`ngDoCheck 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngDoCheck 호출!! =&gt; myString : ${this.myString}`);  }} ngAfterContentInit, ngAfterContentChecked최초의 ngDoCheck hook method가 호출된 후에 한번만 호출되며 앞서 배운 ngContent directive를 이용해 부모 Component의 template일부를 자식 Component에서 projection한 후 호출됩니다. 여기서 Content의 의미는 ngContent directive처럼 외부에서Component View안으로 내용을 가져온 것을 지칭합니다. 이 hook method 이후에 Change Detection이 실행된 후 바로 따라서 ngAfterContentChecked hook method가 호출됩니다. ngAfterViewInit, ngAfterViewCheckedComponent에 속한 모든 View와 ViewChild가 시작되고 나서 호출됩니다. 쉽게 생각하면 HTML이 모두 화면에 출력된 후 호출된다고 생각하시면 됩니다. ngAfterViewChecked는 Component의 View에 대한 Change Detection이 실행되고 난 후 호출됩니다. ngOnDestroyComponent가 소멸하기 직전에 호출됩니다. 일반적으로 사용된 자원에 대한 해제 코드가 들어옵니다.import {  AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit,   Component, DoCheck, Input, OnChanges, OnDestroy, OnInit,  SimpleChanges} from '@angular/core';interface IBook {  btitle: string;  bauthor: string;}@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges, DoCheck, AfterContentInit,  AfterContentChecked, AfterViewInit, AfterViewChecked, OnDestroy {  @Input() myInput: IBook;  myString = 'Hello';  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`Constructor 호출!! =&gt; myString : ${this.myString}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {    console.log(`ngOnInit 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngOnInit 호출!! =&gt; myString : ${this.myString}`);  }  ngDoCheck() {    console.log(`ngDoCheck 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngDoCheck 호출!! =&gt; myString : ${this.myString}`);  }  ngAfterContentInit() {    console.log(`ngAfterContentInit 호출!!`);  }  ngAfterContentChecked() {    console.log(`ngAfterContentChecked 호출!!`);  }  ngAfterViewInit() {    console.log(`ngAfterViewInit 호출!!`);  }  ngAfterViewChecked() {    console.log(`ngAfterViewChecked 호출!!`);  }  ngOnDestroy() {    console.log(`ngOnDestroy 호출!!`);  }}이번 포스트는 Angular가 제어하는 Component와 Directive의 lifecycle에 대해서 살펴봤습니다. 어떤 시점에 어떤 hookmethod가 호출되는지 이해하고 Change Detection이 어느 시점에 호출되는지를 이해하시면 조금 더 Angular를 이해하는데 도움이될 듯 합니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-lifecycle"
    }
    ,
    
    "angular-lecture-pipe": {
        "title": "Angular 강좌(19) - Pipe",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Pipe이번 포스트에서는 Angular의 Pipe에 대해서 알아보겠습니다. Pipe는 HTML template내에서 출력하고자 하는 데이터를 원하는형식으로 변환하여 출력하는 기능입니다. 원본 데이터에는 변형을 가하지 않은 상태로 출력 형태만 변경해 주기 때문에원치않은 Side Effect를 없앨 수 있습니다.가장 흔하게 사용하는 예부터 시작하여 사용자 정의 pipe를 생성하는 것 까지 살펴보겠습니다. Built-in PipeAngular는 몇가지 종류의 built-in pipe를 지원합니다. 자세한 사항은 여기를 클릭해 보시면 볼 수 있습니다. 이 중 몇가지만 예를 들어보기로 하죠.다음은 대문자로 출력내용을 바꾸는 pipe의 사용법입니다.&lt;h5 #resultStatus     class=\"mb-0 text-white lh-100\"&gt;    Search Result : {{searchTitle | uppercase }}&lt;/h5&gt;searchTitle의 값이 그대로 interpolation을 이용해 출력되는 형태에서 uppercase라는 내장 pipe를 이용해 출력되는 영문문자열을대문자로 변경해 출력하는 것입니다.이와 유사하게 다음과 같이 날짜에 대한 pipe도 존재합니다.&lt;div&gt;{{ today }}&lt;/div&gt;&lt;div&gt;{{ today | date }}&lt;/div&gt;&lt;div&gt;{{ today | date: 'y년 MM월 dd일' }}&lt;/div&gt;today = new Date();원래 출력되는 형식과 pipe로 변형되서 출력되는 형식을 잘 보시면 될 듯 합니다. 또한 pipe사용은 체이닝을 지원합니다.여러 pipe를 이어서 원하는 형식으로 변환시켜 출력 가능하다는 말이죠.이번에는 우리예제 중 Material Table의 출력 중 가격부분을 통화단위로 바꾸어서 출력하는걸 해보도록 하죠.다음은 list-box.component.html의 일부입니다.&lt;ng-container matColumnDef=\"bprice\"&gt;  &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;  &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bprice | currency: 'KRW'}} &lt;/mat-cell&gt;&lt;/ng-container&gt;위의 예에서 볼 수 있듯이 책의 가격을 통화단위(원화)로 변경해서 출력할 수 있습니다. 이렇게 built-in pipe를 이용해서처리할 수 있고 built-in pipe로 처리할 수 없는 것들은 custom pipe를 이용해 처리할 수 있습니다.사용자 정의 pipe를 이용해 비슷한 처리를 해 보겠습니다.command 창을 열고 다음의 명령을 실행해 pipe를 생성합니다.  ng generate pipe bookPricebook-price.pipe.ts 파일이 생성되게 됩니다. 기본적인 code가 생성되고 내용은 다음과 같이 수정합니다.import { Pipe, PipeTransform } from '@angular/core';@Pipe({  name: 'bookPrice'})export class BookPricePipe implements PipeTransform {  transform(value: any, args?: any): any {    return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') + '원';  }}bookPrice란 이름의 pipe를 사용하면 transform() method가 호출되서 변환작업을 진행하게 됩니다. 적절하게해당 method의 내용을 우리가 원하는 내용으로 변경해주면 되겠네요. 위의 코드는 입력받은 숫자를 3자리마다 ,를찍고 맨 마지막에 ‘원’을 붙여서 문자열을 리턴하는 코드입니다.우리가 만든 pipe를 Module에 등록하고 list-box.component.html 에서 다음과 같이 사용하시면 됩니다.&lt;ng-container matColumnDef=\"bprice\"&gt;  &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;  &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bprice | bookPrice}} &lt;/mat-cell&gt;&lt;/ng-container&gt;이번 포스트에서는 Angular에서 Pipe라고 불리는 요소가 어떠한 역할을 하는지에 대해서 알아보았습니다. Pipe는어렵지 않은 내용이기 때문에 built-in pipe를 사용하는 방법과 custom pipe를 작성하는 방법만 몇가지 알아두시면됩니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-pipe"
    }
    ,
    
    "angular-lecture-directive": {
        "title": "Angular 강좌(18) - Directive",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Directive이번 포스트에서는 Angular의 Directive에 대해서 알아보겠습니다. 지금까지 예제를 작성하면서 여러 directive를 사용해 왔는데요.그에 대해서 조금 더 정리를 해 보려 합니다.Directive는 DOM의 모양이나 동작을 지시하기 위한 명령이라고 생각하시면 됩니다. 크게 HTML Element형태로 사용되거나 Element의 attribute의 형태로 사용되게 됩니다. 예를 들면 우리가 사용했던 ngIf 같은 attribute를 떠올리시면 됩니다.Routing에서 사용했던 &lt;router-outlet&gt;&lt;/router-outlet&gt; Element 역시 directive입니다.이렇게 directive는 DOM을 제어하기 위한 용도로 사용되는데 DOM을 제어하기 위해서 우리는 지금까지 Component를 이용했었습니다. Component로 제어하면 되지 굳이 directive로 DOM을 제어할 필요가 있느냐 하는 의문이 들 수 있습니다. 하지만 Component는원칙적으로 자신이 rendering하는 View에 대해서만 관심이 있습니다. 여러 View들이 공통적으로 사용하는 Element나 Element의attribute같은 것들을 따로 directive로 지정해 사용하면 SRP관점에서 봤을 때도 타당하고 Component의 복잡도를 낮출 수 있으며유지보수와 같은 관리적인 측면에서도 더 나은 형태로 구현이 가능합니다.Component 역시 큰 의미에서 directive입니다. Component는 directive이면서 View를 가지고 있고 자식 Component 또한 가질 수있습니다. 하지만 directive는 View를 가지고 있지 않고 자식 directive 또한 가질 수 없습니다.Directive는 크게 다음과 같은 4가지 종류로 구분 할 수 있습니다.      Component Directive    우리가 알고 있는 Component입니다. selector에서 우리가 directive를 지정해 사용하게 됩니다.            Attribute Directive    HTML Element의 Attribute로 사용됩니다. built-in 형태로는 ngClass 같은 것들이 있습니다.            Structural Directive    DOM의 구성을 제어하기 위한 directive로 ngIf , ngFor, ngSwitch 등이 있습니다.            Custom Directive    built-in 형태로 만들어진 directive가 아닌 직접 만들어서 사용하는 directive를 지칭합니다.      이 중 Component에 대해서는 많이 사용해 봤으니 Structural Directive와 Custom Directive에 대해서알아보도록 하겠습니다. Structural Directive우리 예제에서도 사용했던 ngIf, ngFor등을 지칭합니다. 단, 이것들은 built-in된 형태입니다. 이런 구조적 directive를우리가 직접 만들어서 사용할 수도 있습니다. ngIf와 ngFor를 사용하실 때 몇가지 알아두셔야 하는 사항이 있습니다.일반적으로 다음과 같이 코드처리 합니다.&lt;div *ngIf=\"hero\" class=\"name\"&gt;&lt;/div&gt;hero가 null과 undefined가 아니면 &lt;div&gt;를 DOM에 추가하고 interpolation을 이용해 값을 출력하는 코드입니다.이 코드는 사실 다음과 같이 변형되어서 실행됩니다.&lt;ng-template [ngIf]=\"hero\"&gt;  &lt;div class=\"name\"&gt;&lt;/div&gt;&lt;/ng-template&gt;ng-template을 이용해서 조건을 통해 &lt;div&gt;의 처리를 결정합니다.비교해서 보셔야 할 것으로 ng-container가 있습니다. 위의 코드는 다음의 코드로 표현이 가능합니다.&lt;ng-container *ngIf=\"hero\"&gt;  &lt;div class=\"name\"&gt;&lt;/div&gt;&lt;/ng-container&gt;Angular는 동일한 Element에 두개 이상의 *ngIf, *ngFor, *ngSwitch를 사용할 수 없습니다. for문을 돌리면서 if문을이용해 비교하고 싶은 경우에는 문제가 됩니다. 이 같은 경우를 해결하기 위해 ng-container를 제공하는 것이라 보시면 됩니다. Custom Directive기존에 만들었던 mySearchProject에 간단하게 Custom Directive를 추가하고 어떻게 이용하는지 살펴보도록 하겠습니다.command 창을 열고 다음의 명령을 실행해서 directive를 하나 생성합니다. 현재 command 창의 working directory는src/app 입니다.  ng generate directive textColor두개의 파일이 생성됩니다. Angular CLI의 이름규칙에 의해 text-color.directive.ts 라는 이름의 파일이 생성됩니다.그 내용을 다음과 같이 수정합니다.import {Directive, ElementRef, Renderer2} from '@angular/core';@Directive({  selector: '[myColor]'})export class TextColorDirective {  constructor(elementref: ElementRef, renderer: Renderer2) {    renderer.setStyle(elementref.nativeElement,'color','darkred');  }}위의 directive 내용은 HTML Element의 속성으로 myColor 가 사용되었을 경우 해당 Element를 DOM에rendering 할 때 글자색을 darkred로 설정하라는 것입니다.이렇게 directive를 생성하면 사용하기 위해서 Root Module에 등록해야 합니다. Angular CLI를 이용했기 때문에이미 등록이 되어 있습니다. 이제 실제 해당 directive가 정상적으로 동작하는지 확인해보면 될 듯 합니다.pages/home 폴더에 있는 home.component.html을 수정해서 해당 directive를 사용해 보죠.&lt;h1&gt;HOME&lt;/h1&gt;&lt;hr&gt;&lt;p myColor&gt;이 Web Application은 Angular 강좌를 위한 Test App입니다.&lt;p&gt;이 강좌는 다음의 내용을 포함합니다. &lt;/p&gt;&lt;ul&gt;  &lt;li&gt;Angular의 기본 구조&lt;/li&gt;  &lt;li&gt;Angular CLI&lt;/li&gt;  &lt;li&gt;Component&lt;/li&gt;  &lt;li&gt;Template - Template Reference Variable&lt;/li&gt;.........  위와 같이 myColor라는 directive를 사용할 수 있습니다. 해당 P Element의 text 글자는 darkred로 출력되겠네요.가장 직관적인 예를 들기 위해 text color를 변경하는걸로 처리를 했는데 그 외 DOM을 제어하는 다른 기능들도 할 수 있습니다.이번에는 이벤트 처리를 한번 해 보죠. 위의 예에서 해당 P Element를 클릭했을 때 alert() 이 수행되게 할려면 다음과 같이처리하시면 됩니다.import {Directive, ElementRef, HostListener, Renderer2} from '@angular/core';@Directive({  selector: '[myColor]'})export class TextColorDirective {  @HostListener('click', ['$event']) elementClick(e) {    // e안에는 event객체가 들어온다.    // this는 directive 객체를 지칭.    alert(e.srcElement.innerHTML)  }  constructor(elementref: ElementRef, renderer: Renderer2) {    renderer.setStyle(elementref.nativeElement,'color','darkred');  }}이벤트를 처리하기 위해 @HostListener decorator를 이용했습니다. 여기서 host라는 표현이 나오는데 지금 우리 예제에서myColor 속성을 적용한 HTML Element를 host라고 지칭합니다.이벤트 객체를 얻기 위해 처리하는 부분을 조심해서 보시면 됩니다.추가적으로 @Input decorator를 이용해서 directive가 값을 전달 받을 수 있습니다. 원래 @Input은 부모 Component가 자식 Component에게 데이터를 전달해 주기 위해 사용했었는데 directive에게도 값을 전달 할 수 있습니다. 사용하는 Component때 했던 것과 동일합니다.이번 포스트는 Directive에 대해서 정리해보았습니다. 더 많은 기능이 있지만 기본적으로 이런 용도로 사용된다는 정도만 알고 계시면될 듯 합니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-directive"
    }
    ,
    
    "angular-lecture-inspection-1": {
        "title": "Angular 강좌(17) - 중간 정리",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle 중간 정리지금까지 Angular의 구조와 기본개념을 살펴보기 위해서 간단한 예제프로그램을 작성했습니다.이제 기존에 하지 못했던 조금 더 자세한 사항에 대해 알아봐야 할 듯 합니다. Performance Issue먼저 얘기할 부분은 Angular의 Performance 입니다.기존 AngularJS에 비해서 Angualr는 여러 관점에서 성능향상이 이루어졌습니다. 하나씩 간단하게 살펴보겠습니다.      Digest Loop로 인한 성능 저하 문제가 개선되었습니다. 우리 예제에서 다뤄보았던 양방향 바인딩 기억하시나요?AngularJS에서는 이 양방향 바인딩을 처리하기 위해 watcher라는걸 사용합니다. 이 watcher라는 놈이 수행될 때마다 digest loop가 수행되어 양방향 바인딩을 처리하는 구조였습니다. 양방향 바인딩이 많아질수록 watcher가 증가하고결과적으로 digest loop의 수행도 같이 증가해서 결국 성능이 저하되는 문제가 발생했던 겁니다.지금의 Angualr는 전통적인 양방향 바인딩을 다른 방식으로 처리함으로써 이 문제를 해결했습니다.    현재 Agnular에서 양방향 바인딩은 내부적으로 Property binding과 Event binding으로 변환되어서 처리됩니다.만약 Angular의 Change Detection에 대해 자세히 알고 싶으시면여기를참고하세요.    Angular는 AoT Compile을 지원합니다. AoT(Ahead of Time) compile이란 사전 컴파일을 지칭합니다. 런타임에 컴파일을 하지 않고 미리 컴파일을 해 놓기 때문에 실행 속도를 더 높일 수 있는 것이죠. 안드로이드 개발을 해 보신 분이라면 Dalvik과ART를 알고 계실 겁니다. Dalvik은 JIT 컴파일러를 이용하고 ART는 AoT 컴파일러를 사용합니다. 둘을 비교해보자면 JIT(Just-In-Time)은실행시점에 소스코드를 컴파일하는 방식입니다. 설치는 빠르게 되겠지만 실행이 좀 느리겠지요. AoT는 설치시점에 소스코드를컴파일하는 방식입니다. 따라서 설치가 조금 느려지지만 실행시 빠르게 실행되는 장점을 가지고 있습니다.  Angular뿐만 아니라 모든 Front-End Framework이 가지는 문제점 중 하나는 바로 SPA(Single Page Application) 구조에서 오는 rendering의 속도 문제입니다.우리는 기존에 SSR(Server Side Rendering)을 이용해 프로그램을 했었습니다. 예를 들면, JSP 이런것들 이지요. SSR의 장점은일단 클라이언트에게 빠르게 화면을 보여줄 수 있다는 겁니다. 하지만 라이브러리가 다 로딩된 후에야 Client와 interaction이 가능합니다.반면에 SPA 구조는 모든 라이브러리가 다 로딩되어야 Client가 화면을 볼 수 있습니다. 즉, Client가 초기에 화면을 보기까지 로딩시간이걸린다는 것입니다. CSR(Client Side Rendering) 이라고 불리는 이 방식은 화면이 뜨자마자 바로 interaction이 가능하다는 장점이 있습니다. 요즘에는 이 둘을 섞어서 최적화를 꾀하고 있습니다. 이와 관련된 사항으로 Angular는 Lazy Loading을 사용합니다.Lazy Loading(지연 로딩)은 SPA의 단점을 극복하기 위한 하나의 방법으로 사용하는 모든 라이브러리를 한꺼번에 다 불러들이지 않고필요한 시점에 필요한 라이브러리만 로딩하는 방식입니다. 이를 이용해 로딩 시간을 단축할 수 있기 때문입니다. Angular CLI그 다음 살펴볼 부분은 Angular CLI입니다. 우리 예제 프로그램을 작성하기 위해 사용했던 것 기억하시지요?Angular CLI(Command Line Interpreter)는 command 명령어를 이용해서 프로젝트의 생성 및 Scaffolding, build, 개발서버를 이용한실행과 테스팅까지 수행할 수 있는 개발지원 도구 입니다. 간단하지 않는 프로젝트의 구조 생성 및 설정 그리고 Coding Convention등을 자동으로 잡아주기 때문에 편하게 개발환경을 구축하고 표준적 방식으로 프로젝트를 진행할 수 있도록 도와주는 아주 고마운 도구이지요.다음은 일반적으로 많이 사용되는 Angular CLI의 명령어와 알아두어야 할 사항들 입니다.  프로젝트의 생성    ng new &lt;project_name&gt;        위와 같은 형태로 프로젝트를 생성하면 기본 폴더 구조와 파일이 생성됩니다. 이전에도 언급했지만 이렇게 생성된 프로젝트의 구조와Coding Convention이 Angular의 표준 스타일입니다. 또한 필요한 의존 Module이 같이 설치됩니다. 만약 의존Module을 설치하고 싶지 않을 경우 --skip-install option을 이용해 프로젝트를 생성하시면 됩니다.    내장 개발서버를 이용한 프로젝트 실행    ng serve        위와 같은 명령을 이용하면 내장 개발 서버를 이용해 우리 프로젝트를 deploy할 수 있습니다. 기본적으로 사용하는 port는 4200입니다. 만약 다른 포트를 사용하고 싶을 때는 --port option을 이용해 포트번호를 변경할 수 있습니다. 그리고 --o option을이용하면 시스템에 설정되어 있는 default browser를 실행해 http://localhost:4200 으로 접속까지 해 줍니다.    이 내장 개발서버는 LiveReload 기능을 지원합니다. 쉽게말하자면 우리가 코드를 수정하면 그 내용을 컴파일하여 즉각 반영하고 browser를 refresh까지 시켜준다는 것이지요. 개발을 편하게 가져갈 수 있습니다.    프로젝트 구성요소 추가    ng generate &lt;구성요소&gt; &lt;구성요소명&gt;        위와 같은 명령을 이용하면 프로젝트에 새로운 Angular 구성요소를 추가할 수 있습니다. 우리는 component, service 구성요소를 추가해봤지요. 그 외에 다음과 같은 Angular 구성요소들을 추가할 수 있습니다.          directive      pipe      module      class      interface      enum      guard        이런 구성요소가 어떤 역할을 하는지는 나중에 하나씩 살펴봐야 겠네요. 기존에 우리 프로젝트에서 추가했던 search-box Component를 가지고 간단하게 Naming Rule에 대해 정리를 한번 해 보겠습니다.    다음과 같은 명령을 실행하면 새로운 Component가 하나 만들어 집니다.    ng generate component search-box        생성되는 파일은 총 4개입니다. option을 설정하면 파일이 만들어지지 않을수도 있습니다. 즉, CSS, HTML, SPEC파일을생성하지 않을수도 있다는 말입니다. CSS와 HTML을 inline방식으로 사용할 수 있으니까요. SPEC은 테스트를 위한 파일입니다.    그런데 만들어지는 파일의 이름이 좀 특이합니다. 다음과 같은 형태로 만들어졌습니다.    search-box-component.css     search-box-component.html    search-box-component.tssearch-box-component.spec.ts        파일명이 모두 search-box.component.* 형태로 만들어집니다. Angular는 Naming의 혼란을 방지하기 위해 케밥 표기법(Kebab case)을 이용해서 Angular 구성요소의 이름을 붙이게 됩니다. 사실 우리에게 익숙한표기법은 Camel case입니다. 각 단어의 첫글자를 소문자로 쓰고 붙어있는 단어들은 대문자로 시작하는 표기법입니다. Java의기본 표기법이죠. 참고로 Pascal case도 있습니다. Camel case와 유사한데 Pascal case는 첫 글자도 대문자로 시작합니다.Kebab-case는 하이픈(-)을 이용한 표기법입니다. Angular는 기본적으로 Kebab case를 Angular 구성요소 이름을 붙일 때 사용한다는걸 기억하시면 됩니다. 참고로 class의 이름은 Pascal case를 이용합니다.    이렇게 만들어진 search-box-component.ts 파일의 내용을 살펴보죠    import { Component, OnInit } from '@angular/core';  @Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {    constructor() { }    ngOnInit() {  }  }        위의 코드에서 selector가 어떤 역할을 하는지 아실겁니다. 이 selector에 명시된 이름의 tag를 다른 template에서이용하면 해당 tag 위치에 우리 Component에서 지정한 template이 표시되게 됩니다. 이 selector에 명시된 이름이결국 &lt;app-search-box&gt;&lt;/app-search-box&gt;형태로 어딘가에서 이용된다는 말이죠. 이 selector에 지정된 이름을붙일 때 접두어 app을 이용해 Kebab case로 표현합니다. 기존의 HTML tag와 혼동되는걸 피하기 위해서라고 생각하시면 됩니다.    참고로 이 접두어는 .angular-cli.json 설정파일에서 다른것으로 지정할 수 있습니다.    우리는 CSS와 HTML을 따로 파일을 만들어서 사용했지만 inline형태로 이용할 수 있습니다. 아래와 같이 말이죠.    import { Component, OnInit } from '@angular/core';  @Component({  selector: 'app-search-box',  template: `&lt;h1&gt;Hello&lt;h1&gt;             &lt;p&gt;              this is a sample text             &lt;/p&gt;            `,  style: `.myStyle {              color : red          }         `})export class SearchBoxComponent implements OnInit {    constructor() { }    ngOnInit() {  }  }          여기서는 backquote ( ` ) 기호를 이용하는 template string을 사용했습니다. 다른 Angular 구성요소를 추가하는방법과 이용법은 이후 포스트에서 하나씩 실습을 통해 알아보도록 하겠습니다.    프로젝트 Build    ng build        위와 같은 명령을 이용하면 우리 프로젝트를 Angular CLI를 이용해 Build할 수 있습니다. 기존에는 SystemJS를 이용해서bundling을 했지만 현재는 webpack을 이용해 bundling합니다. option을 따로 주지 않고 build를 진행하면 개발환경 build를 수행하게 됩니다. 만약 productionbuild를 수행하시려면 --prod option을 이용하시면 됩니다. 또한 deploy를 위한 base url을 설정할 때는 --base-href option을이용하시면 됩니다. Angular CLI Build에 관한 보다 자세한 option 사항은 여기를 참조하시면 됩니다.  이번 포스트는 기존에 설명하기 좀 난감(?)했던 성능문제라던지 Angular CLI의 Naming Rule에 대해 보충설명을 진행했습니다. 만약 Angular CLI에 대해 더 자세하게 알고 싶으시면 여기를 살펴보시면 됩니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-inspection-1"
    }
    ,
    
    "angular-lecture-table-event": {
        "title": "Angular 강좌(16) - Material Table Event",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Angular Material Table Event이번 포스트는 list-box Component의 Angular Material Table의 row를 클릭하면 해당 책의 세부정보를 detail-box Component의View에 출력하는 부분을 작성해 보겠습니다. 이 작업 역시 BehaviorSubject를 이용해 선택한 책의 정보를 자동으로 갱신해 출력할 수 있도록 처리하겠습니다.Service에 Client에 의해 선택된 책의 세부정보가 담긴 객체정보가 존재해야 합니다. detail-box Component는 이 정보를 subscribe해야 하고 만약 Client에 의해 다른 책이 선택된다면 이 정보를 갱신해주면 될 듯합니다.다음은 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';import { HttpClient } from \"@angular/common/http\";import { BehaviorSubject } from \"rxjs/BehaviorSubject\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  // Client에 의해 선택된 책의 정보 - 초기화  selectedBook: IBook = {    bauthor: '',    bdate: '',    btranslator: '',    bpublisher: '',    btitle: '',    bprice: 0,    bisbn: '',    bimgurl: ''  };  constructor(private http: HttpClient) { }  updateBooks: BehaviorSubject&lt;IBook[]&gt; = new BehaviorSubject&lt;IBook[]&gt;(this.books);    // selectedBook에 대한 BehaviorSubject 객체 생성  updateSelectedBook: BehaviorSubject&lt;IBook&gt; = new BehaviorSubject&lt;IBook&gt;(this.selectedBook);  getJsonData(url:string, name:string, category:string, keyword:string) {    this.http.get&lt;IBook[]&gt;(`${url}${name}`)        .subscribe(res =&gt; {           let tmp = null;           // 도서종류와 검색어를 이용한 도서 데이터 Filtering 시작           if( category == 'all' ) {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             });           } else if( category == 'country') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator == '') {                 return true;               } else {                 return false;               }             });           } else if( category == 'foreign') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator != '') {                 return true;               } else {                 return false;               }             });           }          // 도서종류와 검색어를 이용한 도서 데이터 Filtering 끝          this.updateBooks.next(tmp);          //this.books = tmp;          //console.log(this.books);        });  }  getBooks(): IBook[] {    return this.books;  }}이제 Material Table row event를 처리해야 합니다. 이 부분은 API 사용이기 때문에 별다른 설명이 없습니다. 다음의 코드를이용하시면 됩니다.다음은 list-box.component.html 파일의 내용입니다.&lt;div class=\"example-container mat-elevation-z8\"&gt;  &lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;    &lt;ng-container matColumnDef=\"bisbn\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"btitle\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Title &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bauthor\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Author &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bprice\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;mat-header-row class=\"list-header-style\"                    *matHeaderRowDef=\"displayedColumns\"&gt;    &lt;/mat-header-row&gt;    &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"             (click)=\"rowSelect(row)\"&gt;    &lt;/mat-row&gt;  &lt;/mat-table&gt;  &lt;mat-paginator #paginator                 [pageSize]=\"5\"                 [pageSizeOptions]=\"[5, 10, 20]\"                 showFirstLastButtons&gt;  &lt;/mat-paginator&gt;&lt;/div&gt;아래쪽에 &lt;mat-row&gt;에 대한 이벤트 처리만 유의해서 보시면 됩니다. Table의 각 row를 클릭할 때 마다 rowSelect()를 이용해 method를 호출하면서 현재 선택된 row 객체를 인자로 넘겨줍니다.다음은 list-box.component.ts 파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { MatTableDataSource } from '@angular/material';import { MatPaginator } from '@angular/material';import { ViewChild } from '@angular/core';import { HttpSupportService } from \"../http-support.service\";import { SelectionModel } from '@angular/cdk/collections';interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent {  displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];  dataSource;  books: IBook[];  // event 처리  selection = new SelectionModel&lt;IBook&gt;(false, []);  @ViewChild(MatPaginator) paginator: MatPaginator;  constructor(private httpSupportService:HttpSupportService) {    this.httpSupportService.updateBooks.subscribe(data =&gt; {      this.books = data;      this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);      this.dataSource.paginator = this.paginator;    })  }  rowSelect(row) {    this.selection.select(row);    this.httpSupportService.updateSelectedBook.next(this.selection.selected[0]);  }}SelectionModel을 이용해 사용자가 선택한 row에 대한 정보를 획득합니다. Service의 updateSelectedBook의 next()를호출하여 detail-box Component에서 구독하고 있을 선택된 책의 정보를 갱신합니다.마지막으로 detail-box.component.ts 파일입니다.import { Component, OnInit } from '@angular/core';import {HttpSupportService} from \"../http-support.service\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-detail-box',  templateUrl: './detail-box.component.html',  styleUrls: ['./detail-box.component.css']})export class DetailBoxComponent implements OnInit {  book: IBook;  constructor(private httpSupportService:HttpSupportService) {    this.httpSupportService.updateSelectedBook.subscribe(selectedBook =&gt; {      this.book = selectedBook;    });  }  ngOnInit() {  }}기존에 sample data를 삭제하고 Service를 이용하여 updateSelectedBook 객체를 subscribe하게끔 처리했습니다.Table의 이벤트 처리하는 부분만 잘 보시면 됩니다. 데이터 공유는 이전 포스트에서 설명했던 방식 그대로 똑같이 적용해서 처리했습니다.여기까지해서 기본적인 도서 검색에 대한 프로그램을 완성했습니다. 다음 포스트들은 실습과 약간 무관하지만 알아야 하는부분들에 대해서 정리해 보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-table-event"
    }
    ,
    
    "angular-lecture-data-share-service-rxjs": {
        "title": "Angular 강좌(15) - Service RxJS",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Angular RxJS이번 포스트는 RxJS를 이용해 데이터를 공유하는 방법에 대해서 알아보겠습니다. RxJS에 대한 이론적인 내용은 다른 포스트에서알아보기로 하고 여기서는 RxJS를 이용해 우리 예제를 어떻게 구현할 수 있나에 초점을 맞추어 보도록 하죠.지금까지 작성한 우리 예제 프로그램은 search-box Component에서 Search 버튼을 클릭하면 Service의 method가 호출되서JSON 데이터를 확보합니다. 이 데이터를 자동으로 list-box Component에 전달할 방법이 없었기 때문에 list-box Component에서 Service를 이용해 데이터를 가져가는 방식으로 동작했습니다.여기서는 BehaviorSubject class를 이용해 보도록 하겠습니다. 이 BehaviorSubject는 Observable의 특별한 형태라고 보시면 됩니다. 연관된 데이터를 쉽게 구독할 수 있는 method와 데이터를 변경하기 위한method등 사용하기 쉬운 몇가지 method를 제공해서 보다 쉽게 RxJS 기능을 이용할 수 있도록 고안된 class입니다.먼저 http-support.service.ts 파일에 BehaviorSubject class 타입의 객체를 하나 생성합니다. 연관된 데이터를 생성자의인자로 이용해서 객체를 생성합니다.updateBooks: BehaviorSubject&lt;IBook[]&gt; = new BehaviorSubject&lt;IBook[]&gt;(this.books);새로운 JSON 데이터가 만들어지면 updateBooks에 데이터를 밀어 넣습니다. 다음과 같은 method를 이용합니다.this.updateBooks.next(tmp);//this.books = tmp;기존에는 JSON 데이터를 만들어서 this.books에 바로 assign했는데 이 데이터를 updateBooks의 method를 이용하여 books에 밀어 넣습니다.이제 list-box Component를 수정할 차례입니다. 데이터를 가져오기 위한 버튼은 필요없으니 HTML에서 삭제합니다. 또한 버튼이 클릭되었을 때 Service에서 데이터를 가져오는 method도 의미가 없으니 삭제해야 겠네요.list-box Component는 단순합니다. 주입된 Service의 updateBooks를 구독하고 있다가 데이터가 변경되면 변경된데이터를 자동으로 가져와 Table의 DataSource에 injection하는 코드만 작성하면 됩니다. 생성자에서 처리하면 될 듯 합니다.  constructor(private httpSupportService:HttpSupportService) {    this.httpSupportService.updateBooks.subscribe(data =&gt; {      this.books = data;      this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);      this.dataSource.paginator = this.paginator;    })  }BehaviorSubject class의 도움을 받으면 RxJS의 이론적인 내용과 Observable에 대한 내용을 잘 몰라도 쉽게 구현이 가능합니다. 하지만 나중에 RxJS의 이론적인 내용은 한번 보셔야 합니다.마지막으로 부모 Component의 초기화 버튼을 누르면 list-box에 출력된 도서 내용도 초기화 되어야 합니다. 이 부분은 위의 내용을응용해 구현해 보세요!!우리 프로그램이 거의 완성되어가고 있습니다. 다음은 list-box에서 책을 선택하면 해당 책의 세부정보가 detail-box에 출력되도록처리해 보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-service-rxjs"
    }
    ,
    
    "angular-lecture-data-share-service-mediator-pattern": {
        "title": "Angular 강좌(14) - Service Mediator Pattern",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Service Mediator Pattern이번 포스트는 Service의 개념을 이용해서 Component간 데이터를 공유하는 Service Mediator Pattern에 대해서 알아보겠습니다.먼저 간단한 경우부터 살펴보기로 하죠.도서종류와 검색어를 입력하고 Search! 버튼을 클릭하면 Service를 이용해서 JSON 파일로부터 데이터를 읽어들입니다. 원래는RESTful 서버를 이용해서 JSON 데이터를 가져와야 하지만 우리는 RESTful 서버를 이용하지 않으니 일단 JSON 파일로 부터 데이터를읽어들이고 데이터를 filtering해서 사용하겠습니다.먼저 부모 Component인 book-search-main Component에서 선택된 도서종류를 search-box Component에서 사용해야 하므로선택된 도서종류에 대한 값을 search-box Component에서 사용할 수 있도록 코드를 수정합니다.다음은 book-search-main.component.html 중 일부 입니다.    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    [selectedValue]=\"selectedValue\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;    &lt;/app-search-box&gt;@Input decorator로 데이터를 받기 위해 search-box.component.ts를 수정해야 합니다.다음은 search-box.component.ts 파일입니다.import {  Component, OnInit,  Input, Output, EventEmitter} from '@angular/core';import { HttpSupportService } from \"../http-support.service\";import {JSON_DATA_CONFIG, JsonConfig} from \"./json-config\";@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    {      provide: JsonConfig,      useValue: JSON_DATA_CONFIG    }  ]})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;    @Input('selectedValue') selectedValue:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor(private httpSupportService:HttpSupportService,              private jsonConfig:JsonConfig) { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });    this.httpSupportService.getJsonData(      this.jsonConfig.url,      this.jsonConfig.name,      this.selectedValue,      this.keyword);  }  inputChange(): void {  }}부모 Component로부터 받은 도서종류와 Client로부터 입력받은 keyword를 가지고 injection된 Service의 method를 호출합니다.다음은 http-support.service.ts 파일입니다.import { Injectable } from '@angular/core';import { HttpClient } from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  constructor(private http: HttpClient) { }  getJsonData(url:string, name:string, category:string, keyword:string) {    this.http.get&lt;IBook[]&gt;(`${url}${name}`)        .subscribe(res =&gt; {           let tmp = null;           // 도서종류와 검색어를 이용한 도서 데이터 Filtering 시작           if( category == 'all' ) {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             });           } else if( category == 'country') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator == '') {                 return true;               } else {                 return false;               }             });           } else if( category == 'foreign') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator != '') {                 return true;               } else {                 return false;               }             });           }          // 도서종류와 검색어를 이용한 도서 데이터 Filtering 끝           this.books = tmp;           console.log(this.books);        });  }  getBooks(): IBook[] {    return this.books;  }}Filtering처리를 해야해서 코드가 좀 길어졌네요. 알기 쉽게 좀 풀어서 코드를 작성했습니다. Filtering처리된 JSON 데이터를얻어와서 일단 books 속성에 저장했습니다. 그리고 list-box Component에서 데이터를 가져가기 위해 getBooks() method를하나 작성했습니다.이제 데이터를 가져가는 list-box Component를 살펴보면 됩니다. list-box Component에서 데이터를 가져가기 위한 버튼을하나 준비합니다.다음은 list-box.component.html 파일입니다.&lt;br&gt;&lt;button mat-raised-button color=\"warn\"        (click)=\"getData()\"&gt;Get DATA!&lt;/button&gt;&lt;div class=\"example-container mat-elevation-z8\"&gt;  &lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;    &lt;ng-container matColumnDef=\"bisbn\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"btitle\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Title &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bauthor\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Author &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bprice\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;mat-header-row class=\"list-header-style\"                    *matHeaderRowDef=\"displayedColumns\"&gt;    &lt;/mat-header-row&gt;    &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;  &lt;/mat-table&gt;  &lt;mat-paginator #paginator                 [pageSize]=\"5\"                 [pageSizeOptions]=\"[5, 10, 20]\"                 showFirstLastButtons&gt;  &lt;/mat-paginator&gt;&lt;/div&gt;Table 상단에 Get DATA!라는 버튼을 만들고 event binding을 시켰습니다. 마지막으로 list-box.component.ts 파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { HttpClient } from \"@angular/common/http\";import { MatTableDataSource } from '@angular/material';import { MatPaginator } from '@angular/material';import { ViewChild } from '@angular/core';import {HttpSupportService} from \"../http-support.service\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent {  displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];  dataSource;  books: IBook[];  @ViewChild(MatPaginator) paginator: MatPaginator;  constructor(private httpSupportService:HttpSupportService) {  }  getData(): void {    this.books = this.httpSupportService.getBooks();    this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);    this.dataSource.paginator = this.paginator;  }}주입된 Service객체를 이용해서 Service에 저장되 있는 JSON데이터를 가져다가 Table의 DataSource에 설정하게 됩니다.내용이 좀 많지만 천천히 따라가면서 살펴보시면 어렵지 않게 이해하실 수 있습니다. 그림으로 보자면 아래와 같은 형태입니다.동작은 잘 하지만 list-box Component에 데이터를 가져오기 위해서 버튼을 한번 더 클릭해야 한다는 것이 좀 그렇네요.Service에 의해서 데이터가 공유되는 건 확인했지만 새로 검색을 해서 데이터가 변경되면 당연히 list쪽에서는 데이터가자동으로 변경되지 않습니다.이 문제는 RxJS를 이용해서 처리할 수 있습니다. 다음 포스트에서는 RxJS를 이용해서 데이터의 흐름을 subscribe(구독) 하고 구독하고 있는 데이터를 어떻게 변경해야 하는지에 대해서 알아보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-service-mediator-pattern"
    }
    ,
    
    "angular-lecture-data-share-service": {
        "title": "Angular 강좌(13) - Service",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Service이번 포스트는 Angular의 Service에 대해서 알아보겠습니다. 먼저 Service의 기본적인 사항들을 알아본 후 이를 통해 데이터를 공유하는Service Mediator Pattern으로 넘어가면 될 듯 하네요.이 Service는 Angular에만 존재하는 개념이 아닙니다. 객체지향 프로그래밍을 다뤄보신 분은 익히 들어본 개념입니다. 특히 Spring과 같은 Framework이나 MVC Pattern을 다뤄보신 분들이라면 쉽게 이해하실 수 있는 내용입니다.우리는 Angular를 하고 있으니 여기에 맞춰 설명을 하자면 Component는 View를 표현하고 관리하는게 주된 역할입니다. 즉, 데이터를 받아와서 View에 출력한다던지 View의 값이 변경되면 그걸 또 어떻게 처리한다던지하는 View와 밀접한 로직을 Component class가가지고 있게 됩니다.만약 View를 처리하는 로직 이외의 별도의 로직이 필요하면 그 로직은 어디에 두는것이 좋을까요? 로그인 처리를 할때필요한 인증로직이라던지 혹은 서버와의 데이터 통신을 위한 REST 서버의 호출같은 로직을 그냥 필요할 때마다 Component안에 집어 넣어서 처리하는게 좋을까요?우리는 CBD(Component Based Development)를 하고 있습니다. 각각의 Component는 자신의 주된 관심사에 집중하게끔 코드를 작성해야합니다. 객체지향설계에서 얘기하는 SRP(Single Responsibility Principle)을 생각하시면 됩니다. Component안에 다른 관심사가존재하면 Component의 독립성이 보장되지 못하고 결국 중복 코드가 발생하며 Component의 재사용과 유지보수에 문제가 발생하게되겠죠.그래서 위에서 얘기한 별도의 로직들은 다른 곳에서 관리할 필요가 있습니다. Service라는 걸 이용해서 이 로직들을 작성하고 다른 Component에서 이 Service를 가져다가사용하는 식으로 관리를 하면 SoC(Separation of Concern)원칙에 잘 들어맞을 거 같습니다.이렇게 Component와 Service를 분리해서 작성하고 Component에서 Service를 사용하는 건 좋은데 사용할 때 문제가 하나 있습니다. Dependency라는게 생기는 거죠. 쉽게 단위 코드로 Component에서Service를 사용하는 예를 한번 보죠. 아래는 Component class입니다.MyService service = new MyService();service.getUserAuth('moon9342');pseudocode 입니다. Component class안에서 직접 Service 객체를 생성해서 이용하는 경우입니다. 이런 경우 우리 Component는Service에 의존하게 됩니다. 이걸 Dependency Relationship(의존관계)이 존재한다 라고 표현하기도 합니다. 이 때 Componentclass의 입장에서 Service 객체를 Dependency라고 표현합니다.이렇게 의존관계가 성립되면 Service가 변경되었을 때 우리 Component는 그에 따른 영향을 받을 수 밖에 없습니다. 연관관계가 강하게 성립되어서 서로 독립적으로 사용하는게 힘들어지는것이고 재사용이나 유지보수에 문제가 생기게 되겠네요.이 문제를 해결하는 Design Pattern이 바로 DI(Dependency Injection)입니다. 우리 Service객체(Dependency)를 사용하는 객체인Component에게 주입해서 사용하는 것입니다. 주입하는 방법은 일반적으로 constructor를 이용하는 방법과 setter를 이용하는 방법이있는데 Angular는 constructor injection을 지원합니다.즉, Component가 직접 Service를 new keyword로 생성하는 것이 아니라 Angular Framework이 Service를 Component가 사용할 있도록Service객체를 생성해서 Component에게 넣어주는 방식입니다. 이걸 IoC(Inversion of Control)라고 합니다. Angular Framework은 IoC Container입니다.이론적인 배경을 간단히 설명했으니 이제 Service를 우리 예제에 추가해보겠습니다. Angular application은 Module의 집합입니다. Module은 크게 Feature Module과 Shared Module이 있다는 얘기 혹시 기억하시나요? 어디에 Service를 생성하느냐 하는 문제인데 사실 case-by-case입니다.특성상 여러 Feature Module에서 사용하는 공통 로직의 개념이면 따로 Shared Module을 만들어서 그 안에 Service를 포함시키는게 좋습니다. 하지만 우리 예제처럼 bookSearch Module에서만 사용할 생각이면 해당 Module안에 포함시키는게더 좋은 선택이겠죠. Service 생성다음의 코드를 이용해 우리 bookSearch Module에 서비스를 하나 추가합니다.command 창을 열어서 다음과 같은 명령어를 실행시킵니다.  ng generate service HttpSupport성공적으로 수행되면 현재 Module 폴더에 2개의 파일이 생성됩니다. 하나는 SPEC 파일이고 나머지 하나가 바로 Service 입니다.다음은 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';@Injectable()export class HttpSupportService {  constructor() { }}주의해서 보셔야 하는 부분은 @Injectable decorator입니다. 해당 class가 다른 class에 주입(Injection)될 수 있다는걸의미합니다. 아까도 설명했듯이 주입은 생성자를 이용하게 되고 주입과정은 Angular Framework이 담당합니다.이제 이 안에 JSON 데이터를 가져오는 코드를 작성해야 합니다. 우리 예제의 list-box Component는 View를 rendering할 때 HttpClient를 이용해 JSON데이터를 가져와 Material Table로 화면에 바로 출력합니다. 이 부분을 변경해야겠죠.search-box Component에서 Search! 버튼을 클릭하면 HttpClient를 이용해서 데이터를 가져와서 그 데이터를 list-box가사용할 수 있도록 처리해야 합니다.원래는 Back End 프로그램도 하나 작성해서 RESTful 서비스 하는걸 예로 들어야 하는데 서버쪽 프로그램이 없으니 그냥 JSON 파일로부터 데이터를 받는걸로 처리했습니다.다음은 수정된 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';import { HttpClient } from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  constructor(private http: HttpClient) { }  getJsonData() {    this.http.get&lt;IBook[]&gt;('assets/data/book.json')        .subscribe(res =&gt; {           this.books = res;           console.log(this.books);        });  }}interface IBook도 저런식으로 코드마다 등장해서는 안되겠죠. 원래 따로 빼서 관리해야 합니다. 하지만 예제를 좀 이해하기 쉽도록 그냥 중복해서 썻습니다. ^^;;constructor(private http: HttpClient) { }생성자로 인자가 하나 들어옵니다. 사실 이것도 HttpClient 타입의 객체가 우리 서비스 안으로 Injection되는 것입니다.생성자에 인자를 받으면서 Access Modifier를 이용하면 class안에 속성으로 자동 지정됩니다. 여기서는 private으로 Injection된 HttpClient 객체를 받았습니다.getJsonData() method가 호출되면 Injection받은 HttpClient 객체를 이용해서 파일로부터 JSON 데이터를 읽어들인 후 console에 정상적으로 읽었는지 출력합니다. Service Injection위에서 생성한 Service 객체를 search-box Component에 Injection한 후 사용해 보겠습니다.다음은 search-box.component.ts 파일의 내용입니다.import {  Component, OnInit,  Input, Output, EventEmitter} from '@angular/core';import { HttpSupportService } from \"../http-support.service\";@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    HttpSupportService  ]})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor(private httpSupportService:HttpSupportService) { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });    this.httpSupportService.getJsonData();  }  inputChange(): void {  }}기존 코드에서 변경된 부분을 살펴보면import { HttpSupportService } from \"../http-support.service\";기본적으로 import는 시켜줘야 사용할 수 있겠지요.constructor(private httpSupportService:HttpSupportService) { }constructor를 이용해 Service가 Injection되었습니다.this.httpSupportService.getJsonData();Injection받은 Service의 method를 호출하는 부분입니다.@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    HttpSupportService  ]})Angular Framework에 어떤 class가 Injection이 되는지 알려줘야 합니다. Component의 Metadata부분에providers를 이용해 처리해야 합니다.실행해보면 정상적으로 console에 JSON데이터가 출력되는걸 확인하실 수 있습니다. Injector기본적으로 Angular Framework은 dependency객체를 어떻게 생성해야 하는지 알지 못합니다. 그래서 우리가 Component의 Metadata를 이용해서 providers에 그 정보를 명시했었지요. 이 정보를 근간으로 Injector가 의존객체를 생성하고주입합니다.정리하자면 Component가 생성될 때 Angualr는 Injection에 필요한 객체를 Injector에 요청합니다. 이 Injector는 이미 생성한 객체들을 담고 있는 Container를 유지하고 있는데 이 안에 객체가 있으면 바로 주입하고 그렇지 않으면의존객체를 생성한 후 주입하게 됩니다.그림으로 표현하면 다음과 같습니다.( 이미지 출처 : https://angular.io/guide/architecture )여기서 주의해야 할 점이 있는데 각각의 Component 각자 하나씩의 Injector를 가지고 있습니다. Component는 tree형식으로구성되니 Injector 역시 tree형태로 구성이 되게됩니다. 만약 Injection요청에 대한 내용이 현재 Component의 providers부분에명시되어 있지 않으면 부모 Component의 providers에서 검색하게 됩니다. 이렇게 부모로 타고 올라가면서 의존객체를 찾게 되는것이죠.만약 상위 Component에서 의존객체를 생성해 놓았으면 하위 Component에서 따로 선언하지 않아도 사용이 가능합니다.또한 Component의 providers에 등록해 놓을 수도 있지만 Module의 providers에도 등록할 수 있습니다. 이런 경우 해당 Module안에있는 모든 Component들이 해당 의존모듈을 사용할 수 있게 되겠네요. 최상위 Component인 Root Component가 가지고 있는Root Injector는 Application 전역에서 사용가능한 의존모듈을 가지고 있게 되겠네요. Provider위에서 설명했듯이 Module안에 providers로 등록한 의존객체는 Module안에서 사용이 가능합니다. Component에서 등록한 의존객체는자신과 자식 Component에서 사용이 가능하지요.이렇게 보면 Module과 Component에 등록하는게 크게 차이가 없어 보이지만 Module에 등록하는 경우 의존객체는 하나의 객체가 생성되서 사용됩니다. 즉, Singleton 형태로 사용된다는 것이죠. 반면 Component에 등록된 의존객체는 해당 Component가 생성될 때 마다 의존객체가 따로 생성되게 됩니다.따라서 정보공유를 목적으로 하는 Service Mediator Pattern을 이용할 경우 일반적으로 Module에 의존객체를 등록해서 사용하는것이좋습니다.이 provider에 대해서 조금만 더 알아보도록 하죠.Component안에서 의존객체를 등록하려면 다음의 코드를 이용합니다.@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    HttpSupportService  ]})우리는 지금 의존객체라는 표현을 쓰면서 객체만이 주입되는식으로 표현했는데 실제 객체뿐만 아니라 Value도 주입할 수 있습니다. 일단 먼저 의존객체를 주입하는 방식에 대해서 코드를 조금만 상세히 표현해 보겠습니다. 위의 코드는 사실 밑의 코드의 축약형 입니다.@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    {      provide: HttpSupportService,    // 데이터 타입      useClass: HttpSupportService    // 실제 객체를 생성하기 위해 필요한 class명    }  ]})provide의 값과 useClass의 값이 같을 경우 축약형으로 표현할 수 있습니다. provide는 만들어지는 객체의 데이터 타입입니다.useClass는 실제 객체를 생성하기 위해 사용되는 class명이구요. 당연히 두개가 틀릴 수 있습니다. interface를 이용하거나 duck typing을 이용하면 서로 다른 데이터 타입과 class를 사용할 수 있습니다.duck typing에 대해서는 여기를 클릭하시면 간단한 내용을 확인하실 수 있습니다.이번에는 의존객체가 아닌 고정값을 주입하는 방법에 대해서 알아보겠습니다. 일반적인 예는 configuration 값을 주입받는 경우입니다.간단하게 환경설정파일을 하나 만들어서 그 안에 configuration내용을 채워놓고 그 값을 주입받아 보겠습니다.command 창을 열어 다음의 명령을 실행해서 하나의 class를 생성합니다. 현재 command 창의 working directory는search-box Component의 위치입니다.  ng generate class jsonConfigjson-config.ts 파일이 생성됩니다. 해당 파일에 다음과 같이 우리가 사용하는 JSON 파일에 대한 경로와 파일명을 설정정보로입력합니다.export class JsonConfig {  url: string;  name: string;}export const JSON_DATA_CONFIG: JsonConfig = {  url: 'assets/data/',  name: 'book.json'};다음은 search-box.component.ts 파일의 내용입니다.import {  Component, OnInit,  Input, Output, EventEmitter} from '@angular/core';import { HttpSupportService } from \"../http-support.service\";import { JSON_DATA_CONFIG, JsonConfig } from \"./json-config\";@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    {      provide: HttpSupportService,      useClass: HttpSupportService    },    {      provide: JsonConfig,      useValue: JSON_DATA_CONFIG    }  ]})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor(private httpSupportService:HttpSupportService,              private jsonConfig:JsonConfig) { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });    this.httpSupportService.getJsonData(this.jsonConfig.url, this.jsonConfig.name);  }  inputChange(): void {  }}기존에 비해 몇가지 사항이 달라졌습니다. Value를 Injection받을 때 어떻게 처리해야 하는지를 유심히 보시면 됩니다.service의 method를 호출할 때 주입값을 가지고 method를 호출하기 때문에 service의 코드도 변경해야 합니다.다음은 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';import {HttpClient} from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  constructor(private http: HttpClient) { }  getJsonData(url:string, name:string) {    this.http.get&lt;IBook[]&gt;(`${url}${name}`)        .subscribe(res =&gt; {           this.books = res;           console.log(this.books);        });  }}마지막으로 한가지가 더 남아있습니다. 의존객체를 생성할 때 객체를 그대로 사용하는게 아니라 특정 로직을 거쳐 의존객체를 생성해사용할 수 있습니다. 객체지향에서 나왔던 Factory Pattern 생각하시면 됩니다. 이 부분은 여기서 따로 설명하지는 않겠습니다. Optional DependencyOptional Dependency는 의존객체의 주입이 필수가 아니라는 것을 의미합니다. @Optional decorator를 이용하면 의존객체가존재하지 않더라도 프로그램 오류가 나지 않습니다.단순히 생성자에서 의존객체를 주입받을 때 @Optional decorator를 명시하시면 됩니다. 물론 의존객체가 들어오지 않을때의로직처리는 해 주어야 합니다.constructor(private httpSupportService:HttpSupportService,            @optional private jsonConfig:JsonConfig) { }이번 포스트에서는 Angular의 Service에 대해서 알아보았습니다. 기본적인 Service의 사용방법을 먼저 숙지하신 후 이 Service를이용해 데이터를 공유하는 방법으로 넘어가면 될 듯 보입니다. 다음 포스트는 Service Mediator Pattern을 이용한 Component간데이터 공유에 대해서 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-service"
    }
    ,
    
    "angular-lecture-data-share-4": {
        "title": "Angular 강좌(12) - 데이터공유(Content Projection)",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Content Projection이번 포스트는 과거 AngularJS에서 transclusion이라고 불리었던 Content Projection에 대해서 알아보겠습니다. 쉽게 말하자면부모 Component가 자식 Component에게 template을 전달해 줄 수 있는 기능입니다. 이 역시 우리 예제에서는 필요없는 부분이지만 간단하게 내용을 추가해서 알아보겠습니다.다음은 book-search-main.component.html의 내용입니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 #resultStatus class=\"mb-0 text-white lh-100\"&gt;Search Result : {{searchTitle}}&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;    &lt;button mat-raised-button color=\"primary\"            (click)=\"clearCondition()\"&gt;검색 초기화&lt;/button&gt;    &lt;button mat-raised-button color=\"primary\"            (click)=\"changeDOM()\"&gt;DOM 직접 변경&lt;/button&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;      &lt;p&gt;Content Projection!&lt;/p&gt;      &lt;p&gt;First Paragraph&lt;/p&gt;      &lt;p&gt;Second Paragraph&lt;/p&gt;    &lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;기존에 비해 변경된 부분만 보시면 됩니다. 위의 코드 중&lt;app-search-box [bookCategory]=\"displayCategoryName\"                (searchEvent)=\"changeTitleBar($event)\"&gt;  &lt;p&gt;Content Projection!&lt;/p&gt;  &lt;p&gt;First Paragraph&lt;/p&gt;  &lt;p&gt;Second Paragraph&lt;/p&gt;&lt;/app-search-box&gt;부분을 보면 하위 Component를 포함시키면서 3개의 &lt;p&gt; Element를 전달한 것을 보실 수 있습니다. 이렇게 부모 Component가자식 Component에게 특정 template을 전달해 줄 수 있는 기능이라고 생각하시면 됩니다. 자식 Component인search-box.component.html은 다음과 같이 작성합니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar #toolbar class=\"search-toolbar-style\"&gt;    Search Keyword : {{keyword}}    &lt;ng-container *ngIf=\"_bookCategory != null\"&gt;      ( {{_bookCategory}} )    &lt;/ng-container&gt;  &lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\" (ngModelChange)=\"inputChange()\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;  &lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt;다른 부분은 다 동일하고 맨 마지막에 &lt;ng-content&gt;&lt;/ng-content&gt; directive가 보입니다. 이 directive가 부모 Component가전달해 준 template으로 치환되게 됩니다.다음에는 Service에 대해서 알아본 후 이를 이용한 데이터 공유 방법인 Service Mediator Pattern에 대해서 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-4"
    }
    ,
    
    "angular-lecture-data-share-3": {
        "title": "Angular 강좌(11) - 데이터공유(@ViewChild)",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle 부모 Component의 직접적인 자식 요소 제어이번 포스트는 부모 Component에서 자식 요소에 직접 접근하는 방법에 대해서 알아보겠습니다. 이전 포스트에서 @Input decorator를이용해 부모 Component에서 자식 Component로 데이터를 전달하는 방법에 대해서 알아보았는데 이번에는 약간 다릅니다.부모 Component는 자식 Component 객체뿐만 아니라 자식으로 포함된 Directive에 직접 접근할 수 있고 또한Component가 Rendering하는 View자체에 직접 접근할 수 있습니다.하지만 이런 접근 방법이 항상 좋은건 아닙니다. 오히려 좋지 않은 현상이 발생하게 됩니다. 예를 들어 Component가 직접적으로 DOM에 접근해서 제어하는 코드를 작성한다고 가정해 보죠. 일단 간단하게 프로그램을 구현할 수 있으나 나중에 Component의 View가 변경되면 Component에서 처리하는 부분도 당연히 그에 맞게 바뀌어야 합니다. Component의 재사용성과 유지보수성에 문제가 생길 여지가 있습니다.그렇기 때문에 이런 직접적인 접근방식은 꼭 필요한 경우가 아니면 지양하는 것이 좋습니다.그럼 천천히 한번 알아보도록 하죠. @ViewChild, @ViewChildren Decorator부모 Component template안에 위치한 모든 자식 요소들을 ViewChild라고 합니다. 이 ViewChild안에는 자식 Component 객체뿐만아니라 Component가 Rendering하는 View의 DOM 그리고 Directive가 포함됩니다.자식 Component객체에 직접 접근하는 방법부터 살펴보도록 하겠습니다.자식 Component 객체에 직접 접근하려면 @ViewChild decorator를 이용하시면 됩니다. 조건에 부합되는 객체 1개를 찾게되고그에 대한 property를 지정해서 사용할 수 있습니다. 만약 @ViewChildren을 이용하면 조건에 부합되는 객체를 모두 찾게 되고QueryList 형태로 객체들의 집합을 얻을 수 있습니다. QueryList는 실제 배열이 아니기 때문에 toArray() method를 이용해배열을 얻어내 이용할 수 있습니다.그럼 간단한 예를 가지고 알아보도록 하죠.부모 Component에 초기화버튼을 하나 만들어서 해당 버튼을 누르면 Client가 선택한 도서 종류와 입력된 키워드를 초기화 시키는작업을 해 보도록 하겠습니다.먼저 초기화버튼을 만들어야 하니 book-search-main.component.html부터 수정해야 합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result : &lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;                  &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;    &lt;button mat-raised-button color=\"primary\"            (click)=\"clearCondition()\"&gt;검색 초기화&lt;/button&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;검색 초기화 버튼을 생성하고 해당 버튼을 클릭하면 clearCondition() method가 호출되도록 처리했습니다.다음은 부모 Component인 book-search-main.component.ts 파일입니다. clearCondition() method를 작성해야하고해당 method안에서 자신의 검색에 관련된 사항을 초기화하고 자식 Component를 찾아 자식 Component의 property를초기화시키는 작업을 진행합니다.import {Component, OnInit,        ViewChild, ViewChildren, QueryList } from '@angular/core';import { SearchBoxComponent } from \"../search-box/search-box.component\";@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css',  './offcanvas.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  searchTitle = null;  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {    for(let element of this.bookCaterory ) {      if(element.value == category) {        this.displayCategoryName = element.viewValue;      }    }  }  changeTitleBar(searchInfo) : void {    this.searchTitle = `${searchInfo.keyword} ( ${searchInfo.category} )`;  }  @ViewChild(SearchBoxComponent) searchComp: SearchBoxComponent;  @ViewChildren(SearchBoxComponent) searchCompArr: QueryList&lt;SearchBoxComponent&gt;;  clearCondition(): void {    this.selectedValue = null;    this.searchTitle = null;/*    @ViewChild를 사용할 경우    this.searchComp._bookCategory = null;    this.searchComp.keyword = null;*/    // @ViewChildren을 사용할 경우    this.searchCompArr.toArray()[0]._bookCategory = null;    this.searchCompArr.toArray()[0].keyword = null;  }}부모 Component와 자식 Component가 데이터를 공유하는게 아니라 부모 Component가 직접 자식 Component 객체를제어하는 방식입니다. Component가 Rendering하는 View의 DOM에 직접 접근@ViewChild와 @ViewChildren을 이용하면 자식 Component의 객체뿐 아니라 Component가 rendering하는 View의DOM에 직접 접근할 수 있습니다. 이전에 나왔던 Template Reference Variable을 이용해서 Component가 DOM에 접근하는 것이죠.우리 예제에 딱히 필요하진 않지만 이해를 돕기 위해 버튼 하나를 더 추가해 어떻게 사용하는지 살펴보겠습니다.book-search-main.component.html을 수정해 버튼을 하나 더 추가합니다.......&lt;h5 #resultStatus class=\"mb-0 text-white lh-100\"&gt;Search Result : &lt;/h5&gt;.........    &lt;button mat-raised-button color=\"primary\"            (click)=\"changeDOM()\"&gt;DOM 직접 변경&lt;/button&gt;......            일부만 표시했습니다. 결과를 표시하는 영역에 Template Reference Variable #resultStatus을 지정했습니다. 그리고 버튼을 하나추가했구요. 해당 버튼을 클릭하면 changeDOM() method가 호출되겠네요.다음은 book-search-main.component.ts 파일 내용입니다.import {Component, OnInit,        ViewChild, ViewChildren, QueryList,        ElementRef } from '@angular/core';import { SearchBoxComponent } from \"../search-box/search-box.component\";@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css',  './offcanvas.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  searchTitle = null;  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {    for(let element of this.bookCaterory ) {      if(element.value == category) {        this.displayCategoryName = element.viewValue;      }    }  }  changeTitleBar(searchInfo) : void {    this.searchTitle = `${searchInfo.keyword} ( ${searchInfo.category} )`;  }  @ViewChild(SearchBoxComponent) searchComp: SearchBoxComponent;  @ViewChildren(SearchBoxComponent) searchCompArr: QueryList&lt;SearchBoxComponent&gt;;  clearCondition(): void {    this.selectedValue = null;    this.searchTitle = null;/*    @ViewChild를 사용할 경우    this.searchComp._bookCategory = null;    this.searchComp.keyword = null;*/    // @ViewChildren을 사용할 경우    this.searchCompArr.toArray()[0]._bookCategory = null;    this.searchCompArr.toArray()[0].keyword = null;  }  @ViewChild('resultStatus') resultToolbar: ElementRef;  changeDOM(): void {    this.resultToolbar.nativeElement.onclick = function() {      alert('DOM을 직접 제어할 수 있어요!!');    };    this.resultToolbar.nativeElement.innerHTML = \"클릭해보세요!!\";  }}아래부분에 resultStatus Template Reference Variable을 이용해서 해당 Element의 Reference를 획득하는 부분을 잘 보시면됩니다. 이렇게 ElementRef type의 객체를 획득하면 nativeElement 속성으로 직접 제어할 수 있습니다.이번 포스트에서는 @ViewChild와 @ViewChildren을 이용해 자식 Component의 객체를 직접 제어하거나 rendering된 View의 DOM에직접 접근해서 제어하는 방법에 대해서 살펴보았습니다. 다음 포스트는 Angular에서 Content Projection이라고 불리는 부분에 대해서살펴보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-3"
    }
    ,
    
    "angular-lecture-data-share-2": {
        "title": "Angular 강좌(10) - 데이터공유(@Output)",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle @Output Decorator이번 포스트는 자식 Component에서 부모 Component로 데이터를 전달하기 위한 @Output decorator에 대해서 알아보겠습니다.자식 Component에서 부모 Component로 데이터를 전달하기 위해서는 EventEmitter를 이용한 이벤트 처리를 하셔야 합니다. 즉, 자식 Component에서 발생한 event를 부모 Component가 event bidning을 이용해 데이터를 받는 방식입니다.코드레벨에서 알아보죠. 이전에 @Input decorator를 설명하면서 사용했던 예제를 좀 수정해서 사용하겠습니다.아래는 search-box.component.ts 내용입니다.import { Component, OnInit,         Input, Output, EventEmitter } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });  }  inputChange(): void {  }}부모 Component에게 이벤트를 전달하기 위해 다음의 코드로 EventEmitter 객체를 생성하고 @Output decorator를 이용했습니다.부모 Component는 searchEvent 이름으로 event binding 해야합니다.@Output() searchEvent = new EventEmitter();자식 Component에서 Search! 버튼을 눌렀을 때 setKeyword() method가 호출되는데 이 안에서 searchEvent에 대한 이벤트를발생시킵니다. 그러면서 부모 Component에게 전달할 데이터를 인자로 넣어줍니다.this.searchEvent.emit({    keyword : `${this.keyword}`,    category: `${this._bookCategory.replace('category: ','')}`});이제 부모 Component에서 어떻게 event binding을 이용해서 데이터를 받는지만 살펴보면 됩니다.아래는 book-search-main.component.html 입니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result : {{searchTitle}}&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;    &lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;주의해서 보셔야 할 부분은&lt;app-search-box [bookCategory]=\"displayCategoryName\"                (searchEvent)=\"changeTitleBar($event)\"&gt;&lt;/app-search-box&gt;입니다. event binding을 이용해서 searchEvent 이벤트가 발생하면 changeTitleBar() method를 호출하고 인자를 받아서처리하고 있네요. 인자 받는 방식도 유의해서 보셔야 합니다.&lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result : {{searchTitle}}&lt;/h5&gt;interpolation을 이용해 searchTitle 속성의 값을 View에 출력하고 있네요. 아마 changeTitleBar() method안에서 내용이결정될 듯 합니다.마지막으로 book-search-main.component.ts 파일입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css',  './offcanvas.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  searchTitle = null;  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {      for(let element of this.bookCaterory ) {        if(element.value == category) {          this.displayCategoryName = element.viewValue;        }      }  }  changeTitleBar(searchInfo) : void {    this.searchTitle = `${searchInfo.keyword} ( ${searchInfo.category} )`;  }}기본적인 개념은 이미 설명했으니 코드레벨에서 한번 천천히 살펴보시면 충분히 이해할 수 있을 듯 보입니다.여기까지 작업한 내용을 실행해 정상적으로 동작하는지 확인하시면 될 듯 합니다.자식 Component에서 부모 Component로 Event를 이용해서 데이터를 어떻게 전달하는지에 대해서 간단하게 살펴보았습니다.다음 포스트는 부모 Component에서 자식 요소에 접근할 때 또 다른 방법으로 어떤 방법이 있는지 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-2"
    }
    ,
    
    "angular-lecture-data-share-1": {
        "title": "Angular 강좌(9) - 데이터공유(@Input)",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Component Data Sharing이번 포스트는 Component 간의 데이터 공유에 대해서 알아보고 그 내용을 기반으로 우리 mySearchProject의 도서검색 부분을완성해 나가도록 하겠습니다.최종적으로 완성된 프로그램은 여기를 클릭하시면 실행시켜 보실 수 있습니다.실행시켜 보시면 이전에 비해 세가지 기능이 추가되었습니다.  도서 검색 시 도서 종류(국내도서, 국외도서, 국내외도서)에 대한 Filtering이 가능합니다.  키워드 입력 후 Search버튼을 클릭하면 해당 키워드에 대한 책만 list-box에 출력됩니다.  list-box에 출력된 책 중 하나를 선택하면 해당 책에 대한 세부내역을 detail-box에 출력합니다.이 기능들을 구현하려면 Component간의 데이터 공유 방법을 아셔야 합니다. Component간 데이터를 공유하는방법은 여러가지가 있는데 하나씩 살펴보면서 우리 코드에 적용해 보겠습니다.그럼 천천히 한번 살펴보기로 하죠. @Input Decorator이전에 View의 포함관계를 설명하면서 Component Tree에 대한 언급을 한 적이 있습니다. Component간의 부모-자식 관계가성립되면 서로간의 데이터 연결통로가 생성됩니다. 이를 통해 부모 Component와 자식 Component간의 데이터 공유가 이루어질 수 있습니다.먼저 부모 Component에서 자식 Component로 데이터를 전달하는 방법에 대해서 알아보죠.만약 부모 Component가 사용자 입력양식을 가지고 있다면 Client에 의해서 사용자 입력양식의 상태값이 변경될 수 있고 그 상태값를 자식 Component와 공유할 필요가 있습니다. 우리 예제로 설명하자면상위 Component인 book-search-main Component에서 Client가 설정한 도서 종류가 하위 Component인 search-box Component에 전해져야 제대로 된 검색을 수행할 수 있다는 말입니다.이런 경우 부모 Component는 property binding을 이용해 자식 Component에게 데이터를 전달해 줄 수 있습니다. 이렇게 전달된데이터는 @Input decorator에 의해서 자식 Component에서 사용될 수 있습니다.우리 예제를 수정해서 Client가 Select Box에서 선택한 도서 종류 정보가 하위 Component인 search-box Component와 공유되는지확인해 보겠습니다.book-search-main.component.html 파일의 내용을 다음과 같이 수정합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;위의 코드에서 다음의 코드를 주의해서 보시면 됩니다.&lt;mat-select placeholder=\"도서종류\"            #bookCategorySelect            [(ngModel)]=\"selectedValue\"            (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;    &lt;mat-option *ngFor=\"let category of bookCaterory\"                [value]=\"category.value\"&gt;                {{ category.viewValue }}    &lt;/mat-option&gt;&lt;/mat-select&gt;이전에 배웠던 Tempalte Reference Variable과 양방향 바인딩을 이용해 Client가 도서 종류를 변경하면 changeValue() method가 호출됩니다.이 method는 book-search-main.component.ts안에 정의되어 있어야 하겠죠.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css',  './offcanvas.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {      for(let element of this.bookCaterory ) {        if(element.value == category) {          this.displayCategoryName = element.viewValue;        }      }  }}method의 하는일을 보니 Client가 선택한 도서 종류를 가지고 displayCategoryName이라는 속성의 값을 변경하고 있습니다.이 displayCategoryName 속성이 바로 자식 Component인 search-box Component에게 전달되는 데이터입니다.다시 위쪽의 book-search-main.component.html의 내용을 보면 아래와 같은 코드가 있습니다.&lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"&gt;&lt;/app-search-box&gt;&lt;/div&gt;search-box Component에 property binding을 이용해 bookCategory라는 이름으로 displayCategoryName 속성을 바인딩해 놓은걸 확인하실 수 있습니다.이제 search-box.component.ts의 내용을 보죠import { Component, OnInit, Input } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  @Input() bookCategory:string;  keyword = null;  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;  }  inputChange(): void {  }}@Input decorator를 볼 수 있습니다. @Input decorator를 이용하기 위해서 import를 해 줘야 하는것도 잊지 마시구요.@Input() bookCategory:string;위의 코드처럼 bookCategory라는 이름으로 부모 Component가 property binding으로 전달해준 데이터를 받을 수 있습니다.이 속성을 View에 interpolation을 이용해서 출력하면 될 듯 합니다.다음은 View에 rendering되는 search-box.component.html 입니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;    Search Keyword : {{keyword}}    &lt;ng-container *ngIf=\"bookCategory != null\"&gt;      ( {{bookCategory}} )    &lt;/ng-container&gt;  &lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\" (ngModelChange)=\"inputChange()\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;Toolbar부분에 {{keyword}}와 함께 {{bookCategory}}를 이용해서 속성과 binding시킨 걸 확인할 수 있습니다. 만약 bookCategory값이 null이면 출력되지 않게끔 built-in directive를 이용해 처리했습니다.위의 코드에서 보듯이 자식 Component인 select-box Component는 자신에게 데이터를 주는 부모 Component가 어떤 Component인지는 알 필요가 없습니다. 단지 전달된 데이터를 사용할 수 있도록 해주는 property의 이름과 data type만이 필요할 뿐이죠. Component간의 Loosely Coupling을 유지하면서 데이터를 공유할 수 있습니다.기본적인 @Input decorator를 사용하는 방법에 대해 설명했는데 몇개의 응용이 있습니다.우리는 부모 Component의 book-search-main.component.html에서 property binding을 이용해 bookCategory라는이름의 property를 사용했습니다. 이를 사용하기 위해서 자식 Component인 search-box Component에서 역시같은 이름으로 사용했구요. 만약 다른이름으로 사용하실려면 아래와 같이 처리하시면 됩니다.@Input('bookCategory') mySelected:string;bookCategory라는 이름의 property 대신 mySelected property를 사용할 수 있습니다. interpolation 역시 mySelected으로 사용해야겠죠.지금까지의 예는 모두 부모 Component가 전달해 준 데이터를 그대로 가져다 사용하는 방식입니다. 만약 부모 Component가 전달해 준 데이터를 가공해서 자식 Component에서 사용하려면 어떻게 해야 할까요?setter를 이용하면 이 작업을 할 수 있습니다. 우리의 코드가 이렇게 바뀌겠네요.import { Component, OnInit, Input } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  _bookCategory: string;    @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  keyword = null;  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;  }  inputChange(): void {  }}사용되는 setter의 이름과 부모 Component가 property binding하는 property의 이름이 같아야 합니다. interpolation은 _bookCategory으로 변경되어야 하겠네요.한가지 추가적으로 기억하셔야 할 점은 이렇게 부모 Component가 자식 Component에게 데이터를 전달해 줄 때 이 방식이call-by-value방식이 아닌 call-by-reference방식이라는 것입니다. 즉, 우리의 예제에서 부모 Component와 자식 Component가둘 다 bookCategory를 reference하고 있는 형태입니다. 이렇게 연결된 상태에서 부모 Component가 해당 property의 값을변경시키면 그 값을 자식 Component가 공유하고 있으므로 변경된 값을 그 즉시 사용할 수 있는 것이죠.이렇게 생각하면 자식 Component가 공유되고 있는 property의 값을 변경하면 그 변경 내용이 부모 Component에게 영향을미쳐야 합니다. 하지만 실제로 코드 작업을 해 보면 그렇지 않다는 것을 확인하실 수 있습니다. 왜 이런 현상이 발생할까요?만약 자식 Component에서 변경된 값이 부모 Component에게 영향을 주게끔 처리하면 나중에 이 공유데이터의 변화를 예측하기 힘들어지게 됩니다. 데이터의 변경을 tracking하기 힘들어진다는 것이죠. 지금은 간단한 경우이니 별 문제가 안되지만 프로그램이커지게 되면 이런 데이터의 공유 문제가 프로그램의 구현과 디버깅을 힘들게 하는 원인이 됩니다.Angular는 Stateful Component와 Stateless Component의 개념이 있습니다. Stateful Component는 다른말로 Smart Component라고도 하는데 이 Component는 데이터의 정보를 변경하거나 저장할 수 있습니다. 하지만 Dumb Component라고 불리는 Stateless Component는 단지 상태 정보를 참조만 해서 이용할 수 있습니다. 우리의 예제에서 상위 Component인 book-search-mainComponent는 Stateful Component입니다. 반면 자식 Component인 search-box Component는 Stateless Component이구요. 그렇기때문에 자식 Component에서 공유된 변수에 대한 변경을 해 주어도 상위 Component에 영향을 미치지 않게 되는 것입니다.조금 어려운 개념인데 이 Stateful과 Stateless에 대해 조금 더 알고싶으시면 여기를 참조하시면 됩니다.쉽게 말하자면 @Input decorator를 이용하면 부모 Component에서 자식 Component에게 데이터를 전달할 수 있지만 그 반대는 허용되지 않는군요. 이 문제를 해결하기 위해 @Output decorator를 사용할 수 있습니다. 즉, 자식 Component에서 변경된 사항을 부모 Component에게 전달하는 방법이 따로 있다는 것이죠. 다음 포스트에서는 @Output decorator에 대해서 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-1"
    }
    ,
    
    "angular-lecture-material-table": {
        "title": "Angular 강좌(8) - Material Table",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Material Table Component이번 포스트에서는 이전에 만들었던 list-boxComponent가 표현하는 부분을 Material Table을 이용해서 작성해 보겠습니다. 기본적인 테이블 구성과 함께 Pagination까지 추가해서 간단하게 Paging까지 구현해보겠습니다.사실 설명할 부분이 많지는 않습니다. DataSource만 Table에 잘 연결하면 알아서 보여주기 때문이죠. 그게 또 Component 기반개발의 장점이기도 하구요.먼저 CSS부터 수정하도록 하겠습니다. 다음은 list-box.component.css 파일입니다..example-container {  display: flex;  flex-direction: column;  min-width: 300px;  margin-top: 30px;}.mat-table {  overflow: auto;  max-height: 500px;}.mat-header-cell.mat-sort-header-sorted {  color: black;}.list-table-style {  font-family: Georgia;}.list-header-style {  background-color: beige;}그 다음은 list-box.component.html 파일입니다.&lt;div class=\"example-container mat-elevation-z8\"&gt;  &lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;    &lt;ng-container matColumnDef=\"bisbn\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bisbn}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"btitle\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Title &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.btitle}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bauthor\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Author &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bauthor}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bprice\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bprice}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;mat-header-row class=\"list-header-style\"                     *matHeaderRowDef=\"displayedColumns\"&gt;                      &lt;/mat-header-row&gt;    &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;  &lt;/mat-table&gt;  &lt;mat-paginator #paginator                 [pageSize]=\"5\"                 [pageSizeOptions]=\"[5, 10, 20]\"                 showFirstLastButtons&gt;  &lt;/mat-paginator&gt;&lt;/div&gt;Table Component를 이용하기 때문에 book-search.module.ts에 관련된 Module을 import해 주어야 합니다.import { MatTableModule } from '@angular/material/table';그리고 Paging처리를 해야 하기 때문에 MatPaginatorModule 역시 import합니다.import { MatPaginatorModule } from '@angular/material/paginator';위의 HTML에서 가장 중요한 부분은 당연히 DataSource를 바인딩 하는 부분입니다.&lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;Property binding을 이용하여 Component에 있는 dataSource라는 속성과 연결시켰습니다. 이 dataSource라는 속성은도서정보에 대한 객체배열을 이용해서 만든 MatTableDataSource class의 객체입니다. JSON 데이터를 가져와서 만든객체입니다.마지막으로 list-box.compoennt.ts파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { HttpClient } from \"@angular/common/http\";import { MatTableDataSource } from '@angular/material';import { MatPaginator } from '@angular/material';import { ViewChild } from '@angular/core';interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent {  displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];  dataSource;  books: IBook[];  @ViewChild(MatPaginator) paginator: MatPaginator;  constructor(private http: HttpClient) {    this.http.get&lt;IBook[]&gt;('assets/data/book.json')      .subscribe(res =&gt; {        this.books = res;        this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);        this.dataSource.paginator = this.paginator;      });  }} Code Review  원래 Code Review란 표현은 Code Inspection에서 기인한 용어로 코드를 실제로 실행하지 않고 사람이 검토하는 과정을 통해논리적인 잠재 오류를 찾아내고 이를 개선하는 작업을 지칭합니다.그런데 여기서는 그냥 위의 코드를 살펴보자는 의미로 사용했습니다. ^^;;코드를 좀 간단히 설명해보죠.먼저 Table을 생성하는 구문은 다음과 같습니다.&lt;mat-table [dataSource]=\"dataArray\"&gt;  ...&lt;/mat-table&gt;위의 코드에서 dataArray라고 되어있는 부분이 실제 Table에 rendering되는 데이터입니다. 배열형태로 되어 있고 배열안의각각의 객체를 row로 가져와서 화면에 출력하게 됩니다.다음은 Table의 컬럼을 표현하는 template입니다. 구문은 다음과 같습니다.&lt;ng-container matColumnDef=\"bisbn\"&gt;    &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;    &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bisbn}} &lt;/mat-cell&gt;&lt;/ng-container&gt;matColumnDef 속성은 사용할 컬럼의 이름입니다. 이 부분은 list-box.component.ts파일안에 컬럼명에 대한 배열이정의되는데 이 부분과 매칭되어야 합니다. 다음은 list-box.component.ts안에 정의된 컬럼명에 대한 배열입니다.displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];그리고 아래의 구문에 의해 ISBN 컬럼의 제목과 내용이 출력됩니다. dataSource에 연결된 모든 row를 가져와서 element라는 변수에반복적으로 할당 하면서 element.bisbn값을 테이블에 출력하라는 말입니다.&lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;&lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bisbn}} &lt;/mat-cell&gt;이와 같은 형태로 하나의 컬럼에 대한 데이터를 화면에 출력할 수 있습니다. 우리는 총 4개의 컬럼을 화면에 출력하고 있는 것이죠.list-box.compoennt.ts에서는 사용할 데이터를 HttpClient의 get() method로 가져온 후 이를 다음의 코드를 이용해서 객체화 시켰습니다.this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);dataSource와 연결시키기 위해 위에 있는 코드처럼 객체를 생성해서 연결하셔야 합니다.Paginator의 사용은 코드에 나온것처럼 사용하시면 됩니다. 내부적으로 처리되기 때문에 사용하는 방법만 아시면 충분합니다.TypeScript를 사용하기 때문에 interface를 이용하여 data type을 명확히 지정했습니다. 이 부분역시 이전 HTML Table Element로작업했을 때와는 다르게 처리하셔야 합니다. 정리이제 1차적인 작업은 모두 끝났습니다. 논리적인 설명보다는 실제 사용할 화면을 만들면서 필요한 개념들에 대해서 그때 그때 설명하는 방식을 취했습니다. 이제 Component간의 상태공유에 대한 문제만 해결되면우리의 프로그램은 얼추 완성할 수 있을 듯 보입니다.조금만 더 진행시켜 일단 프로그램을 완성한 후 세부적인 내용들에 대해서 다시 짚어가며 살펴보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-material-table"
    }
    ,
    
    "angular-lecture-exercise-2": {
        "title": "Angular 강좌(7) - 실습(2)",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle list-box Component View이번 포스트에서는 도서 정보를 리스트 형태로 출력하는 list-box Component를 구현해 보도록 하겠습니다.먼저 HTML Table Element를 이용하여 구현해보겠습니다. 사실 우리는 최종적으로 Angular Material Table Component를 이용할 것이기 때문에 HTML Table Element에 대한 CSS처리는 하지 않았습니다.여하간 만들어지는 list의 형태는 다음 그림과 같습니다.더 많은 책이 하단에 쭉 나열됩니다. 나중에는 book-search-main Component에서 만들어 놓은 Angular Material Select를 이용해 선택한 조건으로 책들에 대한 리스트가 출력되겠지만 지금은 그냥 조건없이 모든 책이 나열됩니다.기존에 작성했던 book-search-main.component.html 파일을 열어서 HTML Select Element를 이용한 부분을Material Select로 변경합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"  [(ngModel)]=\"selectedValue\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;  &lt;/div&gt;    &lt;div&gt;    &lt;app-search-box&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;일단 Angular Material의 MatSelectModule을 사용하기 때문에 book-search.module.ts에 다음과 같이 import작업부터 해야코드에러가 나지 않을 듯 보입니다.import { MatSelectModule } from '@angular/material/select';mat-select가 Select box에 대한 Angular Material Component 입니다. 양방향 바인딩으로 selectedValue란 이름의 Component의 속성에바인딩 시켜놓은 상태입니다.mat-option은 Select box안의 각각의 Option Component입니다. 여러개가 존재할 수 있기 때문에 ngFor directive를 이용하여 반복처리 했습니다.Angular는 구조적 지시자(Structural Directive)라는걸 제공합니다. DOM 요소를 추가하거나 삭제 혹은 반복처리를 함으로 화면의구조를 변경할 때 사용합니다. 대표적으로는 ngIf와 ngFor가 있습니다. 이름에서 의미하다시피 ngIf는 boolean값을 입력받아true일 경우 ngIf 가 선언된 Element를 DOM에 추가합니다. 만약 false일 경우에는 ngIf 가 선언된 Element는 DOM에서 제거됩니다. ngFor 는 반복가능한 데이터를 입력받아 DOM에 반복해서 Element를 표현할 때 사용합니다.  Directive에 대해서는 나중에 다른 포스트에서 다시 설명하겠습니다. 여기서는 구조적 지시자로 ngIf와 ngFor를 사용해서 DOM을제어하는 방식에 대해서만 알아두시면 됩니다.코드를 보고 유추하건대 bookCaterory는 배열형태의 데이터이고 배열의 각 원소는 객체이겠네요. 데이터 바인딩에서 학습했던 내용과 연계해서 생각해 보시면 됩니다.그럼 아마도 book-search-main.component.ts에 다음과 같은 내용이 포함되어야 할 것입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css',  './offcanvas.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];    constructor() { }  ngOnInit() {  }}그 다음은 실제 리스트가 출력되는 list-box.component.css 파일의 내용입니다.위쪽 margin을 주기 위한 style을 정의해 놓았습니다..example-container {  margin-top: 20px;}다음은 list-box.component.html 파일의 내용입니다.&lt;table class=\"example-container\"&gt;  &lt;thead&gt;  &lt;th&gt;ISBN&lt;/th&gt;  &lt;th&gt;Title&lt;/th&gt;  &lt;th&gt;Author&lt;/th&gt;  &lt;th&gt;Price&lt;/th&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr *ngFor=\"let book of books\"&gt;      &lt;td&gt;{{book.bisbn}}&lt;/td&gt;      &lt;td&gt;{{book.btitle}}&lt;/td&gt;      &lt;td&gt;{{book.bauthor}}&lt;/td&gt;      &lt;td&gt;{{book.bprice}}&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;코드를 수행시키기 위해 먼저 book.json 파일을 하나 준비합니다. book.json 파일의 내용은 다음과 같이 작성하시면 됩니다.단, btranslator는 번역자를 의미합니다. 이 값이 존재하면 외국서적이라는 말이겠죠. 만약 국내도서면 이 값이 \"\"로 표현됩니다.다른 key값들에 대해서는 이름에서 그 의미를 충분히 유추할 수 있을 듯 합니다.[     {        bauthor: \"카일 루든(Kyle Loudon)\",      bdate:\"2000년 04월\",      btranslator:\"허 욱\",      bpublisher:\"한빛미디어(주)\",      btitle:\"C로 구현한 알고리즘\",      bprice:25000,      bisbn:\"89-7914-063-0\",      bimgurl:\"http://image.hanbit.co.kr/cover/_m_1063m.gif\"   },   {        bauthor:\"권기경, 박용우\",      bdate:\"2002년 09월\",      btranslator:\"\",      bpublisher:\"한빛미디어(주)\",      btitle:\"IT EXPERT, 모바일 자바 프로그래밍\",      bprice:23000,      bisbn:\"89-7914-206-4\",      bimgurl:\"http://image.hanbit.co.kr/cover/_m_1206m.gif\"   },   ...   ...   ...]   작성한 데이터 파일을 src/assets/data 폴더 아래에 저장합니다. 이 JSON data를 불러오기 위해 HttpClientModule를 이용합니다.더 쉽게 파일로 import해서 쓸 수 있지만 여기서는 HttpClientModule로 처리했습니다.book-search.module.ts 파일안에 HttpClientModule에 대한 import 구문을 작성합니다.import { HttpClientModule } from \"@angular/common/http\";아래는 list-box.component.ts 파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { HttpClient } from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent implements OnInit {  books: IBook[];  constructor(private http: HttpClient) {    this.http.get&lt;IBook[]&gt;('assets/data/book.json')      .subscribe(res =&gt; this.books = res);  }  ngOnInit() {  }}약간 이상한 코드가 들어있는데 그 이유는 책의 정보를 가져오기 위해 HttpClient의 get() method를 호출하면서Arrow Function을 이용해 코드를 작성했기 때문입니다. 이 부분은 나중에 RxJS를 설명할 때 더 자세히 봐야 할 듯 하고지금은 book.json에 대한 HTTP연결로 JSON 데이터를 가져온다고 이해하시면 충분합니다. 문제점도서정보에 대한 JSON을 작성해서 실행해보시면 아시겠지만 출력은 잘 됩니다.하지만 몇가지 문제가 있습니다.      책이 100권이 있으면 밑으로 쭉 나열되게 됩니다. Paging 처리를 해야 하는데 이것또한 쉬운작업은 아닙니다.        Event 처리하기가 쉽지 않습니다. 각 행을 클릭하면 해당 책의 세부정보를 detail-box Component를 이용하여 View에 출력해야 합니다. 클릭이벤트를 처리하기가 쉽지 않네요.        book-search-main.component.html에서 만들어놓은 Select Box의 선택 정보를 알아와서 그에 맞추어 책들을필터링 해야 하는데 어떤 도서를 선택했는지 현재로서는 알 방법이 없습니다.  이 외에도 Table Header를 클릭해서 리스트를 Sorting하는 것과 같은 일반적인 테이블이 가지는 기능을 우리가 추가로 구현해야되는 문제가 있습니다. 제대로 사용할려면 부가적인 작업이 훨씬 더 많이 들어가야 합니다.이와 같은 문제를 Material의 Table Component를 이용하면 쉽게 해결할 수 있습니다. 다음 포스트에서는 도서 리스트를 출력하는부분을 Material Table Component를 이용하여 다시 작성해 보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-exercise-2"
    }
    ,
    
    "mysql-5-7-archive-setting": {
        "title": "MySQL 5.7.2 Windows용 ZIP Archive 설치",
            "author": "database",
            "category": "",
            "content": "IntroductionMySQL을 install하지 않고 ZIP Archive를 다운받고 압축 풀어서 사용하는 사용하는 방식에 대한 설명입니다. 기존 5.6버전은 JSON에 대한 지원이 되지 않기 때문에 5.7버전을 대상으로 진행합니다. MySQL 5.7.2 ZIP Archive DownloadMySQL을 다운로드 받기 위해 링크를 눌러 이동합니다.아래의 그림처럼 다운로드 링크가 보이게 되는데 이 중 Windows (x86, 64-bit), ZIP Archive으로 되어있는 것을 찾아 다운로드 링크를 눌러 다운로드를 받습니다. 링크를 누르면 로그인하거나 회원가입하라는 화면이 나오는데 화면 하단에 보면그냥 다운로드 할 수 있는 링크가 있습니다.다운로드가 끝나면 적절한 위치에 압축을 풀어줍니다. 저는 D:/[Tools]/mysql 이라는 폴더로 압축된 내용을 풀었습니다. 해당 폴더 하단에 보면 기본적으로 다음과 같은 폴더와 파일들이 보이게 됩니다. MySQL System Database 생성ZIP Archive 버전은 MySQL을 기동하기 위한 System Database가 제공되지 않기 때문에 기본 System Database부터 생성해야 합니다.먼저 mysql 폴더 하단에 data라는 폴더를 생성합니다.그런 다음 관리자 권한으로 command 창을 열고 다음의 명령을 실행합니다. 명령을 실행시키는 폴더는 mysql하단의 bin folder에서 실행합니다.mysqld --initialize약간의 시간이 지나면 data 폴더 하단에 필요한 파일들이 생성됩니다. root 계정 패스워드 변경root계정의 패스워드를 변경하는 부분입니다. 꼭 필요한건 아니지만 현재 root계정은 패스워드 없이 바로 사용할 수 있기 때문에 보안상 설정하는게 좋습니다.다음과 같이 mysqld 명령을 이용해 MySQL 서버를 기동시킵니다.mysqld --console --explicit_defaults_for_timestamp --skip-grant-tables정상적으로 MySQL 서버가 기동되면 다음과 같은 화면을 보실 수 있습니다.이제 별도의 command창을 열고 다음의 명령을 입력해서 MySQL console에 진입합니다. 정상적으로 수행되면 mysql&gt; 프롬프트가떨어지게 됩니다.mysql -u root mysql이제 다음의 SQL문을 이용해서 root 계정의 패스워드를 갱신합니다. 패스워드를 root1234로 변경한다면 다음과 같이 하시면 됩니다.update USER set authentication_string=password('root1234') where user='root';변경이 정상적으로 수행되었으면 다음의 구문을 실행합니다.flush privileges;이제 마지막으로 다음과 같은 구문을 실행합니다.alter user 'root'@'localhost' identified by 'root1234', 'root'@'localhost' password expire never;이제 exit를 입력해 MySQL console을 빠져나옵니다. 그런다음 다음의 명령을 실행하면 root 계정의 패스워드를 입력하라고 합니다. 아까 설정한 root1234를 입력하면 MySQL console에 정상적으로 진입할 수 있습니다.mysql -u root -p MySQL 서버 중지현재 동작중인 MySQL 서버를 중지시킬려면 command 창에서 다음과 같은 명령을 실행시키시면 됩니다.mysqladmin -u root -p shutdown성공적으로 수행되면 실행되고 있던 MySQL 서버의 실행이 중지됩니다. 새로운 사용자 생성 및 권한 부여이전까지 정상적으로 수행되었다면 현재 MySQL 서버는 기동이 중지되어 있을겁니다.초기화 작업이 이미 진행되었기 때문에 이제 MySQL 서버를 기동시키기 위해서 다음과 같이 실행하시면 됩니다.mysqld새로운 사용자 계정을 생성하기 위해 새로운 command 창을 열어서 root계정으로 MySQL console에 진입합니다.mysql -u root -p새로운 사용자를 생성합니다. 아이디는 java, 패스워드 java로 설정해서 생성하도록 하겠습니다. 아래의 두 문장을 실행합니다.create user java identified by 'java';create user java@localhost identified by 'java';이제 데이터가 입력될 새로운 데이터베이스를 하나 생성 합니다. 다음의 명령을 이용해 library라는 이름의 데이터베이스를생성하겠습니다.create database library;새로 생성된 library database에 대한 모든 권한을 조금 전에 추가한 java 계정에게 부여하려면 다음과 같이 하시면 됩니다.grant all privileges on library.* to java;grant all privileges on library.* to java@localhost; SQL Script 파일을 이용해 Database 구축만일 기존에 사용하던 Database에 대한 SQL Script 파일을 가지고 있다면 해당 파일을 이용해 간단하게 데이터베이스를구축할 수 있습니다.command 창을 열어서 다음과 같은 명령어로 Script를 실행시켜 데이터베이스를 구축할 수 있습니다.mysql -u java -p library &lt; SQL_Script_File.sqlEnd.",
        "url": "/mysql-5.7-archive-setting"
    }
    ,
    
    "angular-lecture-databinding": {
        "title": "Angular 강좌(6) - Data Binding",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Data BindingAngular는 View와 Component에서 발생한 데이터의 변경 사항을 자동으로 일치시키는 기능을 제공하는데 이를 Data Binding( 데이터 바인딩 )이라고 합니다.Angular의 데이터 바인딩은 다음과 같이 크게 두가지 종류가 있습니다.      Two-Way Data Binding : 일반적으로 양방향 바인딩이라고 합니다. Component와 View의 상태 정보를 자동으로 일치시켜 주는 기능입니다.        One-Way Data Binding : 일반적으로 단방향 바인딩이라고 합니다. Component에서 View쪽으로 혹은 View에서 Component쪽으로 한 방향으로 데이터를 바인딩 해주는 기능입니다.  위와 같이 크게 두 가지 바인딩이 있지만 실제로 양방향 바인딩은 내부적으로 두개의 단방향 바인딩으로 구성됩니다. 기존 AngularJS는 다른 방식으로 양방향 바인딩을 제공했는데 성능상의 문제가 많아서 Angular에서는 이를 단방향 바인딩 2개를 이용해서 기존의양방향 바인딩처럼 이용할 수 있도록 제공해 주고 있습니다.단방향 바인딩은 다음과 같이 다시 세가지 방식으로 나누어 집니다 .  Interpolation : Component에서 선언한 속성을 View에서 사용하는 경우입니다. 다음의 형태를 이용합니다.{{ value }}  Property binding : View의 DOM이 소유한 HTML Element property를 []를 이용하여 binding하는 경우입니다. 다음의 형태로이용합니다.[property]=\"value\"   Event bidning : View의 DOM에 대한 Event handler로 Component의 method를 사용하는 경우입니다. 다음의 형태로 이용합니다.(event)=\"function\"위에서 간단하게 Data Binding의 종류와 형태를 살펴보았는데 이전 예제를 이용해서 각각을 코드로 살펴보겠습니다. Interpolation예제를 통해 interpolation의 사용법을 알아보겠습니다. 우리가 작성하고 있는 예제에서 search-box.component.html을 다음과 같이 수정합니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{ keyword }}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput placeholder=\"Search Keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"&gt;Search!&lt;/button&gt;&lt;/div&gt;위의 코드에서  {{ keyword }}  부분을 찾을 수 있는데 이 표현이 바로 interpolation이라고부르는 단방향 바인딩 입니다. keyword 라는 이름의 Component 속성을 찾아 그 값을 View에 표현하라는 것이지요.따라서 우리의 Component에는 keyword라는 이름의 속성이 존재해야 합니다.search-box.component.ts 파일을 열어 class안에 해당 속성을 추가합니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  keyword = 'java';    constructor() { }  ngOnInit() {  }}SearchBoxComponent class안의 keyword 속성에 있는 Java란 값이 View에 그대로 출력되게 됩니다. 실행시켜서 확인해보시면 될 듯 합니다. Event BindingEvent bidnging 역시 단방향 바인딩의 한 종류로 DOM의 Event Handler로 Component의 method를 활용할 수 있는방법입니다.search-box Component의 View에서 Search 버튼을 클릭하면 입력된 키워드가 위쪽 Toolbar 영역에 출력되도록 코드를 작성하면 다음과 같습니다.아래는 수정된 search-box.component.html입니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{keyword}}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;위의 코드에서 #inputKeyword 라는 걸 보실 수 있을 텐데 Angular의 Template Reference Variable입니다.Template Reference Variable은 DOM의 HTML Element에 대한 참조 변수입니다. 쉽게 설명해서 HTML Element에변수를 하나 지정했다고 보시면 됩니다. 이렇게 참조 변수를 선언해 놓으면 template내의 JavaScript코드에서#기호를 제외한 변수이름으로 참조가 가능합니다.setKeyword(inputKeyword.value)에서 알 수 있듯이 Template Reference Variable inputKeyword를 # 기호없이사용해서 변수를 참조하고 있습니다. 입력상자이기 때문에 value속성을 이용해서 입력된 값을 알아내고 있는 거지요.한가지 주의해야 하는 것은 이런 Template Reference Variable은 HTML Template상에서만 사용할 수 있습니다. 물론 위의예와 같이 Event Binding을 이용해서 Component class로 전달할 수 있지만 기본적으로 Component class와는 별개로동작합니다.참고로 Agnular는 interpolation을 사용할 때 Safe Navigation Operator를 이용할 수 있습니다. ? 기호로 표현되며Component class의 속성값이 null이거나 undefiend일 경우 interpolation을 이용하면 오류가 발생할 여지가 있습니다.이때 ?를 이용하면 그런 오류를 만났을 때 처리를 종료하고 에러를 발생시키지 않게됩니다.예를 들자면  {{ book?.btitle }}  이런식으로 사용합니다. book이라는 객체가 null인 경우 문제가 생길 수 있죠. 이런 오류를방지할 때 사용됩니다.아래는 수정된 search-box.component.ts 입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  keyword = 'Java';  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;  }}위의 코드는 버튼을 클릭했을 때 Template Reference Variable을 이용하여 키워드 입력상자에서 사용자가입력한 검색 keyword 값을 가져와 Component의 method를 호출하여 Component 속성의값을 변화시킵니다. 이렇게 변경된 Component의 속성은 interpolation을 통해 다시 View에 출력되게 됩니다. Two-Way Data Binding이번에는 양방향 바인딩에 대해서 알아보겠습니다. 위에서 설명한 Search버튼은 입력된 키워드를 기반으로 실제 검색을 하기 위한 버튼이지 검색어를 위쪽 Toolbar 영역에 출력하기 위한 버튼은 아닙니다. 해서 키워드 입력상자( input ) 상자에 키워드를 입력할 때 사용자가 입력한 내용이 위쪽 Toolbar 영역에 출력되도록 처리해보겠습니다.양방향 바인딩을 사용하는 가장 쉬운 방법은 FormsModule이 제공하는 NgModel directive를 이용하는 것입니다. 따라서 먼저 FormsModule을 import하는 부분부터 처리해 주셔야 합니다. book-search.module.ts 파일에 FormsModule에 대한 import 처리를 합니다.// 양방향 바인딩을 위한 FormsModule importimport { FormsModule } from '@angular/forms';다음과 같이 바인딩할 요소의 속성에 [(ngModel)] 과 함께 바인딩할 대상을 선언하시면 됩니다. 다음은 수정된 search-box.component.html 입니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{keyword}}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;실행을 시켜보시면 키워드 입력상자에 글자를 입력할 때 상단의 키워드 표시영역에 같이 출력되는 것을 보실 수 있습니다. 이렇게 양방향바인딩이 설정되어 있을 때 사용자가 글자를 입력하면 NgModel로 바인딩한 값이 변경이 됩니다. 이 때 이벤트가 하나 발생하는데이 이벤트를 처리하기 위해 ngModelChange를 이용할 수 있습니다.위의 코드를 약간 수정해 다음과 같이 작성해보죠.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{keyword}}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\" (ngModelChange)=\"inputChange()\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;  (ngModelChange)에 바인딩 된 inputChange()는 search-box.component.ts 안에 class의 method로 정의되어 있어야 합니다.데이터가 변경될 때 자동적으로 이벤트가 발생되고 바인딩된 method를 통해 특정 로직을 수행할 수 있습니다.영문일 경우는 문제없이 잘 수행되지만 한글일 경우는 약간의 문제가 있습니다. 바로바로 화면에 적용되지 않는 것이죠. 양방향 바인딩은기본적으로 문자 입력이 완료된 시점에 compositionend라는 browser 이벤트가 발생하고 이에 따라 바인딩을 처리합니다. 하지만영문과 다르게 한글은 조합형 문자이기 때문에 글자가 다 만들어 지기 전까지는 해당 이벤트가 발생하지 않고 따라서 화면에 출력되지않게 되는 것입니다.이 문제를 해결하기 위해서는 Angular에서 제공하는 COMPOSITION_BUFFER_MODE 설정을 변경하시면 됩니다. 설정하는 방법은 아래의코드를 참조하시면 됩니다.아래는 book-search.module.ts 파일 입니다.import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { BookSearchMainComponent } from './book-search-main/book-search-main.component';import { SearchBoxComponent } from './search-box/search-box.component';import { ListBoxComponent } from './list-box/list-box.component';import { DetailBoxComponent } from './detail-box/detail-box.component';import { MatFormFieldModule } from '@angular/material/form-field';import { MatInputModule } from '@angular/material';import { MatButtonModule } from '@angular/material/button';import { MatToolbarModule } from '@angular/material/toolbar';import { MatCardModule } from '@angular/material/card';// 양방향 바인딩을 위한 FormsModule importimport { FormsModule } from '@angular/forms';// COMPOSITION_BUFFER_MODE importimport { COMPOSITION_BUFFER_MODE } from '@angular/forms';@NgModule({  imports: [    CommonModule,    MatFormFieldModule,    MatInputModule,    MatButtonModule,    MatToolbarModule,    MatCardModule,    FormsModule  ],  providers: [    {      provide: COMPOSITION_BUFFER_MODE,      useValue: false    }  ],  declarations: [BookSearchMainComponent,                  SearchBoxComponent,                  ListBoxComponent,                  DetailBoxComponent]})export class BookSearchModule { } Property BindingProperty binding을 이용하면 DOM 상의 HTML Element에 대한 property를 Component의 속성과 바인딩 할 수 있습니다. 주의하실 점이 하나 있는데 property binding은 HTML Element의 Attribute에 값을 binding하는 것이 아니라 HTML이 browser에 의해 parsing되면메모리에 DOM이 생성되는데 이 DOM의 HTML ELement에 대한 property에 값이 binding된다는 것입니다.이번에는 detail-box Component를 이용해서 한번 알아보죠.일단 완성된 화면은 다음과 같습니다.제목, 저자, ISBN, 가격, 출판일, 이미지 정보는 interpolation을 이용해 출력하고 property binding을이용하여 만약 책의 가격이 20000을 초과하면 구입버튼을 disabled 시키게 처리했습니다.detail-box-component.css에서 사용된 CSS는 다음과 같습니다..example-card {  width: 500px;  margin: 0 auto;}.example-header-image {  background-image: url('/assets/images/book-icon.jpg');  background-size: cover;}.book-image {  width: 100px !important;}.detail-header-style {  font-family: Georgia;}아래는 detail-box.component.html 입니다.&lt;mat-card class=\"example-card\"&gt;  &lt;mat-card-header class=\"detail-header-style\"&gt;    &lt;div mat-card-avatar class=\"example-header-image\"&gt;&lt;/div&gt;    &lt;mat-card-title&gt;제목 : {{book.btitle}}&lt;/mat-card-title&gt;    &lt;mat-card-subtitle&gt;저자 : {{book.bauthor}}&lt;/mat-card-subtitle&gt;  &lt;/mat-card-header&gt;  &lt;img mat-card-image class=\"book-image\" src=\"{{book.bimgurl}}\"&gt;  &lt;mat-card-content&gt;    &lt;p&gt;      ISBN : {{book.bisbn}}, 도서 가격 : {{book.bprice }}, 출판일 : {{book.bdate}}    &lt;/p&gt;  &lt;/mat-card-content&gt;  &lt;mat-card-actions&gt;    &lt;button mat-button            mat-raised-button color=\"primary\"            [disabled]=\"book.bprice &gt; 20000\"&gt;바로 구입&lt;/button&gt;  &lt;/mat-card-actions&gt;&lt;/mat-card&gt;book 객체의 속성으로 바인딩 시켰습니다. 당연히 detail-box.component.ts 안에 class 속성으로 book 객체가 정의되어 있겠네요.주의해서 보셔야 할 부분은&lt;button mat-button        mat-raised-button color=\"primary\"        [disabled]=\"book.bprice &gt; 20000\"&gt;바로 구입&lt;/button&gt;부분입니다. disabled 라는 속성에 property binding을 이용해 조건을 걸었습니다. 현재 책 값이 20000원을 초과하면 “바로 구입”버튼을비활성화 시키는 것이죠. 사용하는 법을 잘 기억해 두시면 될 듯 합니다.다음은 데이터가 들어있는 detail-box.component.ts 입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-detail-box',  templateUrl: './detail-box.component.html',  styleUrls: ['./detail-box.component.css']})export class DetailBoxComponent implements OnInit {  book = {    btitle: 'Head First Design Patterns: 스토리가 있는 패턴 학습법',    bauthor: '에릭 프리먼외 3명',    bprice: 28000,    bdate: '2005년 08월',    bisbn: '89-7914-340-0',    bimgurl: 'http://image.hanbit.co.kr/cover/_m_1340m.gif'  };  constructor() { }  ngOnInit() {  }}이번 포스트에서는 Angular의 Data Binding에 대해서 살펴보았습니다. 다음 포스트는 지금까지 배운 내용과 Directive에 대한 내용을 섞어 약간 복잡하지만 책의 리스트를 출력하는 list-box Component와 연결된 View를 살펴보도록 하겠습니다. 먼저 기본적인 HTML Table Element을 이용해 보고 그 다음에 Angular Material Table Component을 이용해 리스트를 출력해보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-databinding"
    }
    ,
    
    "jekyll-regenerate-speed-up": {
        "title": "Jekyll 기반의 GitHub Page 생성(9)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Site Regeneration 속도 올리기블로그에 포스트개수가 많아지고 기능이 추가될수록 Jekyll의 site generation 속도가 현저하게 떨어지게 됩니다. 어쩔 수 없는일이긴 합니다. 포스트가 1,000개 정도 되면 컴퓨터 사양에 따라 많이 다르겠지만 약 1분 가량의 시간이 걸리게 된답니다.처음에야 포스트가 얼마 없다보니 금방 site가 생성되지만 말이죠.일반적으로 우리가 새로운 포스트를 쓸 때 로컬에서 watch mode를 이용해서 파일이 변경되면 다시 site를 regeneration하도록 설정하고사용합니다. 그래야 변경된 내용을 빠르게 확인할 수 있기 때문이지요.하지만 우리가 포스트의 내용을 변경해서 저장할 때 마다 가지고 있는 모든 폴더에 있는 파일을 검색하고 generation하는 건 비효율적입니다. site regeneration 시간이 너무 오래걸려서 내가 수정한 혹은 작성한 내용을 확인하기 위해 많이 기다려야 하는 것이지요. 추후에 블로그에 글 내용이 많아지신다면 무슨 말인지 충분히 공감하실 겁니다.이 문제를 해결하기 위해 간단한 설정하나를 추가해 보도록 하겠습니다.지금까지 우리는 site를 생성하고 로컬 웹서버를 이용해 실행시키기 위해 다음과 같이 명령을 실행시켰습니다.  bundle exec jekyll serve이제 저 명령 뒤에 option을 하나 주시면 됩니다. --limit_posts 라는 option은데 뒤쪽에 숫자 인자가 들어옵니다. 예를 들어 다음과 같이 실행시키면  bundle exec jekyll serve --limit_posts 1시간상으로 마지막으로 등록된 포스트 1개만 가지고 site를 regeneration시키게 됩니다. 물론 기존의 내용은 컴파일 되지 않기때문에사이트에 나타나지는 않겠지만 현재 작업하고 있는 포스트에 대한 내용은 빠르게 확인이 가능합니다. 이렇게 작업하고 최종적으로는site 전체를 다시 build해 주시면 될 듯 합니다.End.",
        "url": "/jekyll-regenerate-speed-up"
    }
    ,
    
    "git-github": {
        "title": "Git과 GitHub의 간단 사용법",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionGit과 GitHub에 대한 간단한 설명입니다. 간단한 이론과 함께 실습을 통해 command 기반의 명령어로 어떤일을 처리할 수 있는지를 알아보도록 하겠습니다. 누구나 한번쯤은 겪었던 일위의 그림은 누구나 한번쯤 겪어봤을 만한 상황입니다. 파일을 계속 수정해 나가면서 이름을 바꾸어 저장하는 경우입니다.그 당시야 최종 파일이 어떤것인지 알 수 있겠지만 시간이 흐르면 당연히 저 중 어떤 파일이 최종 Report파일인지 알 수없게 됩니다.아래의 그림은 조금 다른 경우입니다.( 이미지 출처 : http://slidedeck.io/cursor-education )여러명이 공동으로 같은 파일을 작업할 때 파일 내용을 덮어쓰는 문제가 생길 수 있습니다. 다른 사람이 작업한 사항을유실할 수 있다는 것이죠.이와 같은 문제가 항시 빈번하게 발생하게되고 이를 해결하기 위해 나온 시스템이 바로 VCS( Version Control System )입니다. Version Control System ( VCS )VCS 는 파일의 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템을 의미합니다. 이런 VCS는다음과 같은 특징을 가지고 있습니다.  각 파일을 이전 상태로 되돌릴 수 있습니다.  시간에 따라 수정 내용을 비교해 볼 수 있습니다.  누가 문제를 일으켰는지 쉽게 추적할 수 있습니다.  파일을 잘못 고쳤을 때 쉽게 복구할 수 있습니다. Centralized Version Control System ( CVCS )CVCS는 중앙집중식 버전 관리 시스템입니다. 우리가 예전에 사용했던 CVS나 Subversion같은 제품이 이 범주에 들어갑니다.파일을 관리하는 서버가 별도록 존재하고 클라이언트는 중앙 서버에서 파일을 받아서 사용하는 개념입니다. 그림으로표현하면 다음과 같습니다.( 이미지 출처 : https://git-scm.com/ )여기서 Checkout이라는 용어가 나오는데 나중에 우리가 살펴볼 Git의 Checkout과는 다른 개념임에 유의하셔야 합니다.이런 CVCS는 중앙서버에 문제가 발생하면 다른 사람과의 협업 자체가 불가능해지게 됩니다. 또한 중앙서버의 하드디스크에문제가 발생하면 프로젝트의 모든 History를 잃어버리게 됩니다.Backup서버를 운영하면 이런 문제점을 일시 해결할 순 있지만 본질적인 문제는 남아있게 됩니다. ( 백업서버까지 날라간다면??? )이런 문제점을 해결하기 위해 분산형 VCS가 등장하게 됩니다. Distributed Version Control System ( DVCS )DVCS는 분산 버전 관리 시스템입니다. 우리가 알고 있는 Git이 대표적 제품입니다. 이 외에 다른 제품들도 있지만Git만 알아도 됩니다.이 방식은 CVCS처럼 클라이언트가 파일의 마지막 Snapshot을 Checkout하는 방식이 아닙니다. 클라이언트는 서버 저장소를통째로 로컬에 복제해서 사용합니다. 즉, 그림으로 보면 다음과 같습니다.( 이미지 출처 : https://git-scm.com/ ) Git의 탄생Linux kernel은 대규모의 open source project입니다. 이 project의 버전관리를 위해 초기에는BitKeeper라는 상용 DVCS를 사용했었는데 2005년도에 이 BitKeeper의 무료사용이 제고되면서 리누스 토발즈의 주도로Linux 개발 커뮤니티가 자체 VCS를 개발했는데 이게 바로 Git입니다.Git은 다음과 같은 특징을 가집니다.  단순한 구조에서 오는 빠른 속도  완벽한 분산처리  branch를 사용한 비선형적 개발 가능  속도나 크기면에서 대형 Project에 적합Git의 데이터 저장 방식은 이 포스트의 범주를 넘어가니 그 부분은 제외하겠습니다. 실제 Git이 어떤 방식으로 데이터를 저장하는가에대한 내용은 여기를 클릭해 살펴보시면 될 듯 합니다. Git의 기본Git은 파일을 3가지 상태로 관리합니다. Committed, Modified, Staged라고 불리는 3가지 상태로 파일을 관리하게 되는데각각의 의미는 다음과 같습니다.  Git의 파일 상태      Committed : 파일을 수정한 후 해당 파일에 대해 commit명령을 실행해 파일을 로컬 데이터베이스(로컬 Repository)에 안전하게 저장한 상태를 의미합니다.    Modified : 파일을 수정한 후 아직 로컬 데이터베이스에 commit하지 않은 상태를 의미합니다.    Staged : 파일을 수정한 후 수정할 파일을 곧 commit할 것이라고 표시한 상태를 의미합니다.  Git은 파일상태 관리와 더불어 3가지 영역을 사용합니다.  Git의 사용 영역      Git directory : Git이 project의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미합니다.다른말로 Local Repository라고 하며 만약 특정 폴더를 Git directory(Local Repository)로 설정하려면 git init명령을이용하면 됩니다. Repository로 설정되면 .git이라는 숨김폴더가 생성되고 이 안에 Git 관리 정보들이 생성되게 됩니다.    Working directory : project의 특정 branch를 checkout한 내용이 들어있는 폴더입니다.    Staging Area : Git directory에 존재하며 단순한 파일입니다. 곧 commit할 파일에 대한 정보를 가지고 있게 됩니다.   Git으로 하는 작업의 기본 순서작업의 기본순서는 다음과 같습니다.  Working directory에서 파일 수정  Staging Area에 수정한 파일을 Stage해서 commit할 Snapshot 생성 ( git add )  Staging Area에 있는 수정된 파일을 commit해서 Git directory에 영구적인 Snapshot으로 저장 ( git commit )( 이미지 출처 : https://git-scm.com/ )( 이미지 출처 : http://egloos.zum.com/incredible/v/7278471 ) Git 설치 &amp; 기본 설정http://git-scm.com를 클릭해서 Git Official HomePage로 이동해서 Git을다운로드 한 후 기본설정으로 install하시면 됩니다.Git을 설치하신 후 git config를 이용해 기본적인 환경설정을 하시면 됩니다. 설정파일은 크게 3가지 종류가 존재하는데 다음과 같습니다.  Git의 환경설정파일( Windows system 기준 )      $GIT_HOME/mingw64/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정으로git config --system으로 설정합니다.    $USER_HOME/.gitconfig : 특정 사용자에게만 적용되는 설정입니다. git config --global으로 설정합니다.    .git/config : Git directory안에 위치하며 특정 저장소에만 적용되는 설정입니다.  각각의 설정파일은 위에 나열된 순서의 역순으로 적용된다는 것도 같이 기억해 두셔야 합니다.Windows system에서 Git을 설치하면 Git Bash 메뉴가 생성되는데 이를 실행해 console을 실행시킨 후 사용자 이름과Email주소를 설정하시면 됩니다.  참고로 MINGW64는 Windows system으로 porting한 GNU 소프트웨어 도구 모음입니다. Git Local Repository 생성그럼 Git을 이용해 Git Repository를 만들어서 사용해 보도록 하겠습니다. 가지고 있는 project가 없기 때문에 간단하게폴더를 하나 생성하고 그 폴더를 project 폴더로 간주하고 진행하겠습니다.Git의 기본 명령과 개념을 이해하는 목적이기 때문에 command 창에서 명령어를 이용해서 작업을 진행하겠습니다.추후에 실제 project에 적용하실 때는 IDE의 기능을 이용하거나 SourceTree와같은 GUI툴을 이용하시는게 좋습니다.다음과 같은 순서로 진행합니다.  윈도우 탐색기를 이용해 먼저 프로젝트 폴더를 생성합니다. D:/MyProject로 생성합니다. 나중에 Git으로 관리할파일을 하나 생성합니다. 다음과 같은 내용을 가지고 있는 파일을 생성하고 파일 이름은 readme.txt로 저장합니다.    This is a sample text.        project 폴더로 이동해 console을 통해 git init을 실행해 Git Repository를 생성합니다. 다음과 같은 메시지가 출력되는걸확인하실 수 있습니다.    Initialized empty Git repository in D:/MyProject/.git/            메시지에서 나온것 처럼 .git 폴더가 생성되고 그 안에 Git Repository가 생성됩니다. 또한 Repository에필요한 각종 Skeleton들도 같이 생성됩니다.        이 상태에서 git status를 실행합니다. 그러면 Git이 아직 추적하고 있지 않은 readme.txt가 존재한다고 알려줍니다.        Git Repository를 생성했지만 아직 어떠한 파일도 관리를 하고 있지 않습니다. 이제 Git이 파일을 관리하게하려면 Repository에 git add를 이용해 파일을 추가하고 git commit을 이용해 commit까지 진행해야 합니다.다음의 그림처럼 명령을 이용하여 Repository에 파일 추가, 확인, commit까지 진행합니다. ( -m option은 commit message를 작성하기 위해서사용합니다. )    이제 마지막으로 readme.txt 파일의 내용을 에디터를 이용해 적당히 수정한 후에 다시 git status를 실행시켜 보시면 됩니다. 그럼 Git은 해당 파일이 변경(Modified)됬다는 것을 인식해서 보여주게 됩니다. 변경된 내용을 적용해 Repository에 저장하려면 다시 git add를 이용해 해당 파일을 staging 한 후 git commit을 실행해야 합니다. Branch 생성그 다음에 알아볼 내용은 branch 입니다. branch는 기본 project에 영향이 가지 않는 상태에서 새로운 기능을 추가하거나기존 기능을 변경해야 하는 경우에 유용하게 사용할 수 있습니다. 필요에 의해 만들어지는 이런 각각의 branch들은 서로간의 영향을 받지 않습니다. 그렇기 때문에 여러 작업을 동시에 진행시킬 수 있습니다.( 이미지 출처 : https://rogerdudler.github.io/git-guide/index.ko.html )Repository를 처음 생성하게 되면 Git는 master라는 이름의 branch를 만들어 줍니다. 위에서 우리가 readme.txt 파일을Repository에 추가하고 내용을 변경해서 commit까지 진행했었는데 모두 이 master라는 branch에서 처리했던 겁니다.master가 아닌 다른 branch를 생성할 수 있습니다. 또한 “이제부터의 작업은 xxx branch에서 진행할꺼야!” 라는 식으로명령을 줄 수 있는데 이걸 checkout이라고 합니다. 즉, checkout은 특정 branch의 내용을 가져와서 Working directory를 설정하는 작업이라고 보시면 됩니다. 특정 branch에서 일어나지 않는 모든 작업은 당연히 master branch에서 일어나게 됩니다.현재 어떤 branch가 존재하는지 알아볼려면 git branch 명령을 이용하시면 됩니다. 만약 새로운 branch를 생성하고 싶으면 git branch branch_name형태로 branch이름을 명시하시면 새로운 branch가 생성됩니다.현재 작업중인 branch는 * 기호로 표시됩니다. 아래 그림은 새로운 branch를 생성하고 git checkout 명령을 이용하여 hotfixbranch를 Working directory에 가져온 것입니다. 지금부터 하는 작업은 모두 hotfix branch에서 발생하는 것이고 master branch와는무관하게 동작합니다.실제로 파일을 변경하거나 추가해서 hotfix branch에서 작업한 후 다시 master branch를 checkout해보시면 아까 했던 작업이 masterbranch에는 영향을 미치지 않는다는 것을 확인하실 수 있습니다. 이 부분은 개별적으로 실습해 보시길 바랍니다.참고로 모든 branch를 확인하기 위해서는 다음의 명령을 실행하시면 됩니다.  git branch -a Branch MergeMerge 작업은 현재 작업중인 branch에 다른 branch를 가져와서 병합하는 작업을 의미합니다. git merge branch_name을 이용하여현재 branch에 명시된 이름의 branch를 가져와 파일을 병합하게 됩니다.만약 두개의 branch에서 같은 파일의 같은 곳을 수정했을 경우 해당 파일을 병합할 때 당연히 문제가 발생하게 됩니다. 그냥 합쳐질 수가없기 때문이지요. conflict가 발생했다고 표현합니다. 이런 경우 충돌이 일어난 내용을 살펴보고 수동으로 해결해야 합니다.  Git은 병합이 실패했을 때 그 해결을 모두 사용자에게 일임합니다.그래서 수동으로 파일을 수정한 후 다시 commit작업을 진행해야 합니다. merge 작업은 Remote Repository 를 설명하는 부분에서 다시 한번 다뤄보기로 하겠습니다. .gitignore 파일project 폴더 안에서 굳이 추적할 필요가 없는 파일들도 존재합니다. 입출력 데이터파일이나 로그파일, 혹은 .class와 같은 파일들은굳이 Git을 이용해서 관리할 필요가 없습니다. 즉, 임시로 사용되거나 결과물로 생성되는 파일들이 이 범주에 들어갑니다.이런경우 .gitignore 파일을 이용해 추적 관리할 필요가 없는 파일을 배제시킬 수 있습니다. 그냥 만들어도 되지만 여기로 이동해 보시면 조금 쉽게 .gitignore 파일의 내용을 만들어 복사해서 사용하실 수 있습니다. Remote RepositoryGit은 혼자 사용할 수 도 있지만 기본적으로 다른 사람과 협업을 하기 위한 도구입니다. 협업 도구로서 Git의 가장 큰 유용함은 Remote Repository(원격 저장소)에 있습니다.이 Remote Repository는 우리가 따로 구축해서 사용할 수 있습니다. 또한 이런 Remote Repository를 서비스하는 회사도 굉장히 많이 있습니다. Git 기반의 Remote Repository 중 가장 대표적인 것이 바로 GitHub입니다.Remote Repository를 쉽게 생각하자면 로컬에서 작업한 Git Local Repository가 외부에 있는거라고 생각하시면 됩니다. GitHub는이런 Remote Repository를 전세계적으로 서비스하고 있고 굉장히 많은 사람들이 GitHub를 자신들이 수행하고 있는 project의 Remote Repository로 이용하고 있습니다.GitHub에 있는 이런 Remote Repository는 크게 public repository와 private repository로 구분됩니다. 말 그대로 public repository는 아무나 파일들을 열람할 수 있도록 공개되어 있는 repository이고private repository는 권한을 가진 사람들만 사용할 수 있는 repository입니다.GitHub는 Fork와 Pull Request라는 기능을 제공하고 있습니다. 정확히 말하자면 이 Fork와 Pull Request는 Git이 제공하는 것이아니라 GitHub가 제공하는 서비스 입니다.      Fork : 다른 사람의 Repository를 통째로 내 GitHub 계정으로 복사해 오는 기능입니다. 즉, GitHub 계정간 Repository를 서로복사해 갈 수 있는 기능이라고 보시면 됩니다.        Pull Request : 다른 사람의 Repository를 Fork한 후 그 내용을 수정한 다음 원본 Repository에 수정된 내용을 보내 병합을요청할 수 있는데 이 작업을 Pull Request라고 합니다. 아무나 Repository를 수정할 수 있는 권한을 주게 되면 Repository는 금방엉망이 될 테니 READ기능(Fork)만 제공하고 병합시에는 요청을 받아서 처리하도록 합니다.   GitHub에 Remote Repository 생성그럼 이제 GitHub에 계정을 생성하고 Remote Repository를 생성해 사용하는 방법에 대해서 알아보겠습니다.GitHub에 계정을 생성하고 새로운 Repository를 생성하는 버튼을 클릭하면 다음과 같은 화면을 보실 수 있습니다. Repository이름을 입력하고 간단한 설명을 입력합니다. Repository의 종류를 선택할 수 있는데 private은 비용을 지불해야 사용할 수 있습니다. 우리는 아까 만들어 놓은 Local Repository와 연결시키는 목적으로 사용할 것이기 때문에 README 파일을 만들지 않고Repository를 생성합니다.Repostiroy를 생성하면 다음과 같은 화면을 보실 수 있습니다. Repository에 현재 파일이 존재하지 않기 때문에이렇게 나오는 것이고 만약 특정 파일들이 저장되어 있으면 파일의 목록들이 보여지게 됩니다. Remote Repository 관리 명령어GitHub에 생성한 Remote Repository를 관리하기 위해서 Git은 몇몇개의 명령어를 제공합니다.  git clone : Remote Repository의 모든 내용을 Local Repository로 복사합니다.  git remote : Local Repository를 특정 Remote Repository와 연결시킬 때 사용합니다.  git push : Local Repository에 추가된 파일이나 변경 사항을 연결된 Remote Repository에 저장하기 위해서 사용합니다.  get fetch : Remote Repository와 Local Repository의 변경 사항이 다를 때 이를 비교 대조해서 충돌을 해결하고최신 데이터를 반영하기 위해서 사용합니다.  git pull : 연결된 Remote Repository의 최신 내용을 Local Repository로 가져오면서 merge합니다. git push와 반대의 개념이라고 보시면 되지만 merge할 때 문제가 발생했을 때 추적이 어렵습니다. 따라서 git pull을 이용하는 것 보다는 일단git fetch로 변경사항을 받고 이를 확인해서 코드를 수정한 후 Local Repository에 commit한 다음 git push로 최종 변경 사항을Remote Repository에 반영하는게 더 좋은 방법입니다. git clonegit clone은 Remote Repository에 있는 project를 내 컴퓨터로 가져올 때 사용합니다. 즉, GitHub에서 Local 환경으로 복사하는 작업입니다. 위에서 생성했던 MyProjectRemote란 GitHub Remote Repository를 Local로 clone해 보도록 하겠습니다.      먼저 Remote Repository의 주소를 복사합니다.        로컬 컴퓨터에서 프로젝트를 저장할 폴더를 생성한 후 git clone을 이용해 저장소를 복사합니다. D:/GitHub 폴더를 생성한 후 이 폴더 안에서 다음의 명령을 실행시킵니다.    git clone https://github.com/moon9342/MyProjectRemote.git정상적으로 clone이 진행되면 저장소 이름으로 폴더가 하나 생성되는것을 볼 수 있습니다. 당연히 이 폴더는 Remote Repository와 연결되어 있는 Local Repository가 됩니다.이해를 돕기 위해 순차적으로 생각해보면 다음과 같이 project가 진행될 수 있습니다.      협업을 책임지는 사람(PM)이 GitHub에 빈 Remote Repository를 생성합니다.        PM은 자신의 Local Repository에 project에 필요한 기본 구조와 여러가지 환경설정 그리고 개발한 필요한 기타 사항들을만들어서 저장합니다.        PM은 project의 뼈대가 담겨있는 이 Local Repository를 GitHub에 생성해 놓은 빈 Remote Repository와 연결합니다. 이때 git remote 명령을 이용하게 됩니다.        PM은 자신이 Local Repository에 가지고 있는 내용을 Remote Repository에 push 합니다.        이제 협업하는 사람 모두가 이 Remote Repository를 clone해서 로컬로 복사해 간 다음 자신이 해야 하는 작업을 진행합니다.  위와 같은 식으로 생각하면 git remote와 git clone의 차이점을 이해할 수 있습니다. git remoteGitHub에 빈 Remote Repository를 생성한 후 git remote를 이용하여 Local Repository와 연결할 수 있습니다.다음과 같은 명령을 이용합니다.  git remote add origin “Remote Repository URL”연결이 성공했는지를 다음의 명령어를 이용해서 확인해 볼 수 있습니다.  git remote -v git pushgit remote를 이용하여 Local Repository와 Remote Repository가 연결되었으면 이제 자신이 작업한 내용을Remote Repository에 upload를 할 수 있습니다.이 때 git push 명령을 이용하면 파일을 upload할 수 있는데 기본적으로 Remote Repository의 master branch에upload되게 됩니다. 따라서 만약 다른 branch의 내용을 upload하려 하면 다음과 같이 명령을 실행시켜야 합니다.  git push origin “local branch명”위의 명령에서 origin은 원격 저장소의 별칭입니다. git remote를 이용하여 Remote Repository를 연결할 때 이 origin이라는 별칭을 이용해서 원격 연결을 했었습니다.만약 origin 저장소에 Local의 모든 branch를 push하려면 다음과 같이 명령을 수행하시면 됩니다.  git push origin --allgit push가 진행될 때 Remote Repository에 같은 이름의 branch가 존재한다면 내용이 변경될 것이고 만약해당 branch가 존재하지 않는다면 새로운 branch를 Remote Repository에 생성하게 됩니다. 같은 이름의 branch가존재하지만 내역이 다르다면 당연히 push는 일어나지 않고 작업이 거부됩니다.간단한 예를 들자면 Local Repository의 master branch의 내용을 Remote Repository에 push하려면 다음과 같이실행하시면 됩니다.  git push origin master만약 Local Repository의 hotfix branch의 내용을 Remote Repository에 push하려면 다음과 같이 실행하시면 됩니다.  git push origin hotfix git fetch &amp; git pullRemote Repository를 이용하다 보면 다른 누군가가 먼저 commit할 경우가 있습니다. 이런 경우git은 당연히 파일의 내용이 서로 상이하기 때문에 push를 허용하지 않습니다.Remote Repository와 Local Repository를 적절히 서로 맞춰야 하며 이럴 때 사용하는 것이 git fetch 입니다.즉, fetch는 Remote Repository의 commit들을 Local Repository로 가져오는 역할을 하고 사용자는 Local Repository로 가져온 commit들을 자신의 작업과 적절히 병합하여 Remote Repository에 push해야 합니다.git pull은 Remote Repository의 정보를 가져오면서 자동으로 Local branch에 병합하는 명령어 입니다. 편하게 사용할 수 는 있지만 만약 conflict가 발생하면 내역 확인이 쉽지 않은 단점이 있습니다. Remote Branch를 Local로 가져오기만약 Local Repository에 Remote Repository의 branch가 존재하지 않는다면 git pull을 이용한다해도 자동으로 Remote Repository에 있는 branch를 가져오지 못합니다.Remote Repository에 있는 branch를 Local Repository로 가져오실려면 다음과 같이 작업하셔야 합니다.우선 git remote에 대한 내역을 갱신해야 합니다. 해당 명령을 하지 않을 경우 나중에 branch를 찾지 못한다는 오류가 발생할 수 있기때문입니다. 다음과 같은 명령을 이용합니다.  git remote update그 다음은 Remote Repository의 branch내역을 확인해야겠죠. -a option을 이용하면 Remote Repository와 Local Repository의 모든 branch를 확인할 수 있습니다.  git branch -r이제 Local Repository에 동일 이름의 branch를 생성하면서 Remote Repostiroy의 branch를 가져온 후 해당 branch로 checkout을 해 보죠. 다음과 같이 실행하시면 됩니다.  git checkout -t &lt;Remote_Branch_Name&gt;만약 Local Repository에 같은 이름의 branch가 아니라 다름이름의 branch를 생성하고 싶을 경우는 아래처럼 -b option을 이용하시면 됩니다.  git checkout -b &lt;Local_Branch_Name&gt; &lt;Remote_Branch_Name&gt;End.",
        "url": "/git-github"
    }
    ,
    
    "angular-lecture-exercise-1": {
        "title": "Angular 강좌(5) - 실습(1)",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle 결과 화면먼저 실습의 결과화면을 한번 보고 개념적으로 무엇을 할 것인지 파악한 후 코드를 살펴보면 될 듯 싶습니다.여기를 누르면 실습의 결과 Web Application을 볼 수 있습니다. 상단에 Navigation Bar가 있고각 메뉴를 클릭하면 내용이 그에 맞게 변하는 SPA형식의 Web Application입니다.UI 부분은 Bootstrap을 살짝 이용했습니다. CSS를 안쓰니 워낙 안예뻐서요. 약간 개념적으로 이상한 얘기도 좀 나오는데천천히 이해하시면 됩니다. 일단 만든 Application이 어떤 형태인지는 이해하는것은 그리 어렵지 않아보입니다.그럼 한번 시작해보죠. SPA( Single Page Application )요즘 만들어지는 거의 대부분의 Front End Web Application은 SPA 형태입니다. Web Application이 하나의 Web Page로구성되는 것이죠. 이와 대비되는 개념이 기존에 우리가 많이 했었던 JSP, ASP, PHP같은 것들입니다.이 기술들은 모두 SSR(Server Side Rendering)기반의 Round Trip 방식의 Web Application을 개발하는데 사용됩니다.기존의 Web Application은 Client가 새로운 Web Page를 요청할 때 마다 서버쪽에서 Web Page를 동적으로 만들어서 Client Browser에게 전송하는 방식을 취했습니다. 이 방식의 장,단점을 잠깐 살펴봐야 합니다. 장점은 서버쪽에서 모든 작업이이루어지기 때문에 개발하기가 용이하다는 점입니다. 이미 개발방식도 정형화되어 있고 jQuery 정도만 익혀서 결과 WebPage에 적용하는 식으로 Client쪽 처리도 쉽게 할 수 있습니다.기존 Desktop 환경에서는 이 방식이 크게 문제가 되지 않았습니다. 하지만 Web Application의 사용환경이 Desktop환경에서 Mobile환경으로 넘어가면서 다음과 같은 문제가 발생하기 시작합니다.      클라이언트가 새로운 페이지를 요청하고 받을 때 마다 web browser 화면 전체가 결과 Page로 Refresh됩니다. 필요한 데이터만받아서 필요한 부분만 갱신하면 되지 전체 페이지를 다 받아서 새로 고침하는 것은 네트워크 사용량을 생각해봐도 비효율적입니다.        Mobile환경에서 Client는 이미 Native App을 사용하는 방식으로 UX가 확고하게 굳어져 있습니다. 따라서 우리의Web Application도 마치 Native App처럼 동작하도록 만들어 제공해야 한다는 것이죠.  결국 위와 같은 문제를 해결하기 위해 나온 모던 웹 패러다임이 바로 SPA입니다. Network traffic의 감소 및 사용성 관점에서 상당히 가치있는 Front End 개발방식이라고 볼 수 있습니다. 하지만 SPA도 단점이 없는 것은 아닙니다. 일반적으로 두가지의 단점을 많이이야기 합니다.  초기 로딩 속도 문제  검색엔진최적화(SEO, Search Engine Optimization) 문제실습인데 설명이 너무 길어지는군요. 이 문제는 여기서 따로 언급하지는 않겠습니다. 여하간 SEO 문제를 해결하기 위해Angular Router를 이용하여 PathLocationStrategy라는 Location 정책을 이용해 우리의 Angular Application을 작성하겠습니다. Module 생성우리는 이미 AppModule이라고 불리는 Root Module을 가지고 있습니다. 여기에 추가적으로 다른 Module을 만들어서 개발할 수 있습니다.먼저 Module에 대해 간단히 알아보고 우리 프로그램에 맞게 Module을 구성해 보도록 하겠습니다.Angular의 Module은  연관성이 있는 Angular의 구성요소들을 하나의 단위로 묶은 것을 지칭합니다. 또한 Angular Application은 크게 본다면 이런 Module의 집합이라고 할 수 있습니다. JavaScript에서말하는 Module과는 다른 개념입니다.아주 간단한 application인 경우 Root Module 하나로 구성할 수 있지만 일반적으로 여러개의 Module을 이용해서 구성하게 됩니다.일반적으로 다음과 같은 형태의 Module을 이용합니다.      Feature Module    특정 화면을 구성하는 구성요소를 묶어서 Module로 관리할 수 있습니다. 우리예제에서 Home은 단일 View로 구성되어 있습니다. 따로 Module을 만들어서 Home에 대한 구성요소를 관리해도 됩니다. 하지만 우리 예제에서는 Home에 대한 Component를 Root Module에서관리하도록 하겠습니다. 하지만 도서 검색이나 영화 검색같은 경우 여러 요소들이 필요할 테고 각각을 Module로 따로 관리하는게 좋습니다.Application안에 여러 화면이 존재할 경우 각 화면별로 Module화를 시키지 않으면 추후에 구성요소의 관리가 어려워짐은 당연합니다.또 Application 전역에서 사용하는 구성요소들을 따로 묶어서 Module로 만들 수도 있습니다. 이런 기능들은 Root Module에 import가 될 필요가 있는 것들로 간단한 예를 들자면Authentification Module이나 Routing Module등이 있습니다.            Shared Module    Feature Module에 의해서 공통적으로 사용되는 구성요소들을 묶어서 Module로 관리할 수 있습니다. 주로 Feature Module에서 공통적으로 사용되는 Directive나 Pipe같은 것들이 포함됩니다.  먼저 Routing Module을 생성하고 그 안에서 Router를 구성하고 등록해보겠습니다.그 후 Routing Module을 Root Module에서 가져다 사용하는 식으로 작성을 해 보죠.command 창을 열고 다음의 명령을 이용하여 새로운 Module을 하나 생성합니다.  ng generate module app-routing정상적으로 실행되면 src/app/app-routing 폴더가 생성되고 그 안에 app-routing.module.ts 파일이 생성됩니다.조금뒤에 이 Module안에 Router를 작성하게 되겠죠. 우리가 가지고 있는 app.module.ts라는 Root Module에 Router를 생성, 등록해도 됩니다. 하지만 실제 Application을 작성할 때는 사용되는 Routing이 많아지게 되는데 이때는 Routing Module로 빼서 관리하시는게 좋습니다. 각 Routing이 사용할 Component 생성각 Routing 경로가 사용할 Component를 생성합니다. 그런데 위에서 특정 화면을 구성하는 구성요소를 Module화 시켜서 사용하는게 좋다고 했으니 우리의 2가지 화면에 대해 Module을 생성하고 이 안에 Component를 생성하도록 하겠습니다.Home은 아까 언급했듯이 별다른 기능이 없는 View이기 때문에 따로 Module로 생성하지 않고 도서 검색에 대한 Module과 영화 검색에 대한 Module만 만들도록 하겠습니다.Home 화면을 담당할 Component는 src/app/pages 하단에 생성하고 Root Module에서 직접 import해서 사용하도록 생성합니다.command 창에서 Angular CLI를 이용해 Component를 생성합니다.  ng generate component pages/home이제 도서 검색을 위한 Module을 생성하고 그 안에 Component를 생성합니다.  ng generate module bookSearch   ng generate component bookSearch/bookSearchMain마지막으로 영화 검색을 위한 Module을 생성하고 그 안에 Component를 생성합니다.  ng generate module movieSearch   ng generate component movieSearch/movieSearchMain정상적으로 수행되면 아래의 그럼처럼 각각의 폴더안에 파일들이 생성되게 됩니다. Routing Module 수정이제 Routing Module을 수정하여 Router를 구성합니다. app-routing.module.ts를 다음과 같이 수정합니다.import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';// Angular Router Module importimport { Routes, RouterModule } from \"@angular/router\";// Routing 처리를 할 각각의 Component importimport { HomeComponent } from \"../pages/home/home.component\";import { BookSearchMainComponent } from    \"../book-search/book-search-main/book-search-main.component\";import { MovieSearchMainComponent } from    \"../movie-search/movie-search-main/movie-search-main.component\";// Router 생성( path 표시할 때 Root path에 대한 '/'는 제외 )const routers: Routes = [  { path : '', component : HomeComponent },  { path : 'book', component : BookSearchMainComponent },  { path : 'movie', component : MovieSearchMainComponent }];@NgModule({  imports: [    CommonModule,    RouterModule.forRoot(routers)  ],  declarations: [],  exports: [RouterModule]})export class AppRoutingModule { } Root Module 수정Routing Module이 만들어졌으니 이제 Root Module에서 Routing Module을 불러들이는 코드를 작성해야 합니다.app.module.ts 파일의 내용입니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// BrowserAnimationsModule import 구문 추가import { BrowserAnimationsModule } from '@angular/platform-browser/animations';// MatTableModule import 구문 추가import { MatTableModule } from '@angular/material/table';import { AppComponent } from './app.component';import { HomeComponent } from './pages/home/home.component';// Feature Module importimport { BookSearchModule } from \"./book-search/book-search.module\";import { MovieSearchModule } from \"./movie-search/movie-search.module\";// Routing Module importimport { AppRoutingModule } from \"./app-routing/app-routing.module\";@NgModule({  declarations: [    AppComponent,    HomeComponent  ],  imports: [    BrowserModule,    BrowserAnimationsModule,    MatTableModule,    AppRoutingModule,    BookSearchModule,    MovieSearchModule  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { } Navigation Menu 작성이제 Navigation Menu를 만들어야 합니다. Routing Module을 이용해 Router의 구성과 등록이 완성되었으나 해당 Routing Path에 대한 View를 어디에 표시할지는 아직 지정하지 않았습니다.app.component.html을 수정해 RouterOutlet directive를 이용해 View의 rendering위치를 지정해야 합니다.여기서는 Bootstrap을 이용해서 화면을 구성했습니다. Bootstrap의 예제중에 Blog 예제가 있는데 그 형식을가져다가 사용했습니다. Bootstrap을 사용하기 위해서는 다음과 같이 Bootstrap을 설치하여야 합니다.  npm install bootstrap@4.0.0-beta.2버전에 약간 주의하셔야 합니다. 현재 최신 버전(bootstrap@4.0.0-beta.3)의 Bootstrap은 Angular CLI로 Production build를 했을 때 bundling 오류가 발생합니다.설치가 완료되면 Bootstrap을 import하셔야 합니다. .angular-cli.json 파일을 다음과 같이 수정합니다.   \"styles\": [        \"../node_modules/bootstrap/dist/css/bootstrap.min.css\",        \"styles.css\"   ],이제 app.component.html 파일을 수정합니다.&lt;nav&gt;    &lt;a routerLink=\"/\"&gt;Home&lt;/a&gt;    &lt;a routerLink=\"/book\"&gt;도서검색&lt;/a&gt;    &lt;a routerLink=\"/movie\"&gt;영화검색&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;쉽게 보기 위해 Bootstrap은 걷어내고 실제 필요한 부분만 명시했습니다. 주의해서 보셔야 할 건 routerLink 입니다.&lt;a&gt;의 href 속성을 이용하면 서버에 request를 보내게되니 href를 이용하지 않습니다.각각의 메뉴를 클릭했을 때 해당 URL을 Router에 전달하고 Router에 의해서 Component가 선택되서 &lt;router-outlet&gt;&lt;/router-outlet&gt;안에 Component가 지정한 HTML이 출력되게 됩니다.결과가 잘 나오나요? Home 화면의 내용을 바꾸실려면 src/app/pages/home 폴더 안에 home.component.html을적절히 수정하시면 됩니다.참고로 다음과 같은 routerLinkActive directive를 이용하면 routerLink directive의 값과 현재 browser URL이 정확히 일치할 때 특정 style의 class를 지정할 수 있습니다.&lt;nav&gt;    &lt;a routerLink=\"/\"&gt;Home&lt;/a&gt;    &lt;a routerLink=\"/book\"       [routerLinkActiveOptions]=\"{ exact: true }\"       routerLinkActive=\"menuActiveClass\"&gt;&gt;도서검색&lt;/a&gt;    &lt;a routerLink=\"/movie\"&gt;영화검색&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;위의 예처럼 링크를 클릭해서 특정 경로로 Routing을 할 수도 있지만 버튼을 클릭했을 때 처럼 프로그램적으로 Routing을 변경해야 하는 경우도 있을 수 있습니다. 이런경우는 Angular Router의 navigate method를 이용하시면 됩니다.import { Router } from '@angular/router';......constructor(private route:Router) { }......gotoBook() {    // Router객체에 대해 method호출    this.route.navigate(['book']);}현재까지 우리가 작성한 Angular Project에 대해 production build를 진행하실려면 다음과 같이 하시면 됩니다.  ng build --prod --base-href=/my-base-url/ 도서 검색 화면3개의 메뉴 중 Home 메뉴는 단일 페이지 이기 때문에 적절하게 수정해서 화면에 보여주면 됩니다. 먼저 최종적으로 만들어진 도서 검색 화면을 한번 보고 View을 어떻게 구성할지 개념적으로 확인하면 될 듯 싶습니다. 아래의 그림이 최종 만들어진 도서검색 화면입니다.총 4개의 View로 구성되어 있습니다. 파란색으로 되어 있는 가장 큰 View안에 검색결과를 보여주는 영역과 도서 종류를 선택하는 Select Box가 들어 있습니다. 부모 View안에 빨간색으로 되어있는 3개의 자식 View가 포함되어 있네요. 맨 위의 View는 검색어를 입력할 수 있는 View이고 제일 아래의 View는 검색어에 해당하는 책에 대한 리스트를 표현하는 View입니다. 가운데 View는 리스트에서 특정 책을 선택하면 그 책의 내용을 자세하게 출력해주는 View입니다.일단 화면을 만드는데 집중하고 실제 프로그램이 동작하는 로직에 관련된 부분은 나중에 service를 설명하면서 추가하도록 하겠습니다. AppComponent 수정이전에 만들어 놓은 mySearchProject를 수정하여 도서검색 화면을 만들고그에 따른 Component들을 생성, 등록까지 진행하도록 하겠습니다.src/app 폴더안에 app.component.ts 파일을 열면 다음과 같은 내용을 보실 수 있습니다.import { Component } from '@angular/core';@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css', './blog.css']})export class AppComponent {  title = 'app';}이 Component가 우리의 Root Component입니다.selector: 'app-root' 설정에 의해 이 Component는 template 코드내에서 &lt;app-root&gt;&lt;/app-root&gt;로 되어 있는 부분을 rendering 한다는 것을 알 수 있습니다.또한 templateUrl에 의해 app.component.html을 이용해 rendering한다는 것도파악할 수 있겠네요.index.html을 보시면 다음과 같이 &lt;app-root&gt;&lt;/app-root&gt;로 되어있는 부분이 보이고 이 부분이 우리 Component에 의해서rendering되게 됩니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;title&gt;MySearchProject&lt;/title&gt;  &lt;base href=\"/\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;  &lt;!-- Material Icon 설정. --&gt;  &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;  &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;결국 index.html안의 &lt;app-root&gt;&lt;/app-root&gt; 부분은 app.component.html의 내용으로 rendering된다는 것을 파악할 수 있습니다.이제 app.component.html의 코드를 보죠. 위에서 Routing Module을 이용했기 때문에 다음과 같은 코드가 나옵니다.Bootstrap 코드도 포함시켰습니다.&lt;div class=\"container\"&gt;  &lt;header class=\"blog-header py-3\"&gt;    &lt;div class=\"row flex-nowrap justify-content-between align-items-center\"&gt;      &lt;div class=\"col-4 pt-1\"&gt;      &lt;/div&gt;      &lt;div class=\"col-4 text-center\"&gt;        &lt;a class=\"blog-header-logo text-dark\" href=\"#\"&gt;my Search Project&lt;/a&gt;      &lt;/div&gt;      &lt;div class=\"col-4 d-flex justify-content-end align-items-center\"&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/header&gt;  &lt;div class=\"nav-scroller py-1 mb-2\"&gt;    &lt;nav class=\"nav d-flex justify-content-between\"&gt;      &lt;a class=\"p-2 text-muted\" routerLink=\"/\"&gt;Home&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" routerLink=\"/book\"&gt;도서 검색&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" routerLink=\"/movie\"&gt;영화 검색&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;    &lt;/nav&gt;  &lt;/div&gt;  &lt;div class=\"jumbotron p-3 p-md-5 text-dark rounded bg-warning\"&gt;    &lt;div class=\"col-md-12 px-0\"&gt;      &lt;router-outlet&gt;&lt;/router-outlet&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;Bootstrap을 이용했기 때문에 Style에 관련된 코드가 많네요. 여하간 Navigation Menu를 작성하고 각 Menu를클릭하면 Router에게 routerLink에 명시된 경로를 전달하게 됩니다. 그러면 Router는 해당 경로에 매핑되는 Component를찾게되고 해당 Component는 &lt;router-outlet&gt;&lt;/router-outlet&gt;위치에 View를 Rendering 하게 됩니다.결과적으로 도서 검색 메뉴를 클릭하면 &lt;router-outlet&gt;&lt;/router-outlet&gt; 부분에 book-search-main.component.html의내용이 rendering되게 되고 이제 그 내용을 수정해서 화면을 다시 구성합니다. View를 추가하기 위해 Component를 생성하는 작업을 진행해야 합니다. Component 추가book-search-main.component.html은 내부에 3개의 View 영역을 포함하고 있습니다.  첫번째 영역 : 검색 키워드를 입력하고 검색 버튼을 눌러 실행시키는 View 영역.  두번째 영역 : 검색된 책을 선택하면 책의 세부정보가 출력되는 View 영역.  세번째 영역 : 검색된 책들의 리스트를 출력하기 위한 View 영역.이렇게 3개의 View를 이용해서 화면을 구성할 것이고 3개의 Component를 추가하여 화면을 구성하려 합니다.Angular CLI를 이용하여 다음과 같이 실행해서 새로운 Component를 추가합니다.  ng generate component bookSearch/search-boxAngular CLI의 generate를 이용하여 Component 생성 시 Component를 구성하는 관련 파일들을 자동으로 손쉽게 생성할 수 있습니다. generate를 다 쓰지 않고 앞글자인 g 만 써도 됩니다. generate는 뒤에 어떤 요소를 생성할 것인지 그리고 요소명은무엇인지를 받아 특정 요소를 생성하게 됩니다. 즉, Component만 생성할 수 있는건 아닙니다.생성된 src/app/book-search/search-box 폴더 안에 있는 search-box.component.ts 파일을 열어서 selector를 확인해보니 app-search-box로 지정되어 있습니다. 우리가 template 코드에서 &lt;app-search-box&gt;&lt;/app-search-box&gt;을 이용하면이 Component가 해당 영역을 rendering하게 되겠네요.이와 유사하게 2개의 Component를 더 생성합니다. 다음과 같이 실행해서 새로운 Component를 추가합니다.  ng generate component bookSearch/detail-box  ng generate component bookSearch/list-box자 이제 생성된 각각의 Component에 대한 selector를 참조해 src/app/book-search/book-search-main 안의 book-search-main.component.html의 내용을 다음과 같이 수정합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"form-group col-md-4\"&gt;    &lt;label for=\"inputState\"&gt;도서 종류&lt;/label&gt;    &lt;select id=\"inputState\" class=\"form-control\"&gt;      &lt;option selected&gt;선택하세요...&lt;/option&gt;      &lt;option&gt;국내외도서&lt;/option&gt;      &lt;option&gt;국내도서&lt;/option&gt;      &lt;option&gt;국외도서&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;또한 src/app/book-search/book-search-main 안의 book-search-main.component.css의 내용을 다음과 같이 작성합니다. CSS에 대한 설명은 생략합니다..bookSearch-outer {  font-family: Georgia !important;  width: 70%;  text-align: center;  margin: 0 auto;} 각 Component의 View 작성이제 각각의 Component의 templateUrl에 명시된 html을 Angular Material을 이용해 우리가사용할 화면을 만들어 냅니다.제일 먼저 상단의 search-box 영역에 대한 HTML을 작성합니다.다음과 같이 src/app/book-search/search-box 폴더안의 search-box.component.html의 내용을 수정합니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : &lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput placeholder=\"Search Keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"&gt;Search!&lt;/button&gt;&lt;/div&gt;search-box.component.css의 내용은 다음과 같이 수정합니다..search-toolbar-style {  font-family: Georgia;  color: white;  background-color: teal;  margin-bottom: 20px;}Angular Material을 이용했기 때문에 해당 Element에 대한 Material Module을 book-search.module.ts안에import해 줍니다.다음은 book-search.module.ts 파일의 내용입니다.import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { BookSearchMainComponent } from './book-search-main/book-search-main.component';import { SearchBoxComponent } from './search-box/search-box.component';import { ListBoxComponent } from './list-box/list-box.component';import { DetailBoxComponent } from './detail-box/detail-box.component';import { MatFormFieldModule } from '@angular/material/form-field';import { MatInputModule } from '@angular/material';import { MatButtonModule } from '@angular/material/button';import { MatToolbarModule } from '@angular/material/toolbar';@NgModule({  imports: [    CommonModule,    MatFormFieldModule,    MatInputModule,    MatButtonModule,    MatToolbarModule  ],  declarations: [BookSearchMainComponent,                  SearchBoxComponent,                  ListBoxComponent,                  DetailBoxComponent]})export class BookSearchModule { }일단 여기까지 작성하고 실행을 시켜보면 다음과 같은 화면을 볼 수 있습니다.화면이 잘 나오나요? 아직 데이터 바인딩과 이벤트에 대한 내용은 설명하지 않았기 때문에 키워드를 입력하거나 버튼을 눌러도 아무런 반응을 하지 않습니다.이와 비슷하게 가운데 detail-box의 View는 다음과 같이 작성하시면 됩니다. list-box는 데이터 바인딩에 대한 내용을배워야지 사용할 수 있으니 list-box의 View는 데이터 바인딩에 대해 설명하고 작성하겠습니다.아래는 detail-box Component에 대한 각각의 코드입니다.detail-box.component.css 파일입니다. src/assets/images 폴더안에 book-icon.jpg 파일을 하나 넣어두셔야 합니다..example-card {  width: 500px;  margin: 0 auto;}.example-header-image {  background-image: url('/assets/images/book-icon.jpg');  background-size: cover;}.book-image {  width: 100px !important;}.detail-header-style {  font-family: Georgia;}detail-box.component.html 파일입니다.&lt;mat-card class=\"example-card\"&gt;  &lt;mat-card-header class=\"detail-header-style\"&gt;    &lt;div mat-card-avatar class=\"example-header-image\"&gt;&lt;/div&gt;    &lt;mat-card-title&gt;제목 : Angular 일주일 완성&lt;/mat-card-title&gt;    &lt;mat-card-subtitle&gt;저자 : 홍길동&lt;/mat-card-subtitle&gt;  &lt;/mat-card-header&gt;  &lt;img mat-card-image class=\"book-image\" src=\"\"&gt;  &lt;mat-card-content&gt;    &lt;p&gt;      ISBN : 123-456, 도서 가격 : 5000, 출판일 : 2017년 12월    &lt;/p&gt;  &lt;/mat-card-content&gt;  &lt;mat-card-actions&gt;    &lt;button mat-button mat-raised-button color=\"primary\"&gt;바로 구입&lt;/button&gt;  &lt;/mat-card-actions&gt;&lt;/mat-card&gt;Material Card Layout Component를 사용했기 때문에 해당 Module에 대한 처리를 book-search.module.ts에 해주어야 하겠죠?import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { BookSearchMainComponent } from './book-search-main/book-search-main.component';import { SearchBoxComponent } from './search-box/search-box.component';import { ListBoxComponent } from './list-box/list-box.component';import { DetailBoxComponent } from './detail-box/detail-box.component';import { MatFormFieldModule } from '@angular/material/form-field';import { MatInputModule } from '@angular/material';import { MatButtonModule } from '@angular/material/button';import { MatToolbarModule } from '@angular/material/toolbar';import { MatCardModule } from '@angular/material/card';@NgModule({  imports: [    CommonModule,    MatFormFieldModule,    MatInputModule,    MatButtonModule,    MatToolbarModule,    MatCardModule  ],  declarations: [BookSearchMainComponent,                  SearchBoxComponent,                  ListBoxComponent,                  DetailBoxComponent]})export class BookSearchModule { } 결과 화면지금까지 작성한 내용을 실행시켜보면 다음과 같은 화면을 보실 수 있습니다.이번 포스트에서는 Component를 추가하고 Angular Material을 이용해 View를 작성해보았습니다. 다음 포스트에서는데이터 바인딩에 대한 내용을 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-exercise-1"
    }
    ,
    
    "angular-lecture-material": {
        "title": "Angular 강좌(4) - Angular Material",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Angular MaterialMaterial Design은 모바일과 데스크탑 그리고 그 외 다양한 디바이스들의 application을 개발할 때 하나의 일관된 디자인을 적용하고자 Google이 공개한 design guideline입니다.  머티리얼 디자인(Material Design, 코드명: Quantum Paper)이란 플랫 디자인의 장점을 살리면서도 빛에 따른 종이의 그림자 효과를 이용하여 입체감을 살리는 디자인 방식을 말한다. 2014년 구글이 안드로이드 스마트폰에 적용하면서 널리 퍼지기 시작했다. 플랫 디자인과 마찬가지로 최소한의 요소만을 사용하여 대상의 본질을 표현하는 디자인 기법인 미니멀리즘(minimalism)을 추구한다.( 자료출처 : https://ko.wikipedia.org )제가 Design에 대한 관심과 지식이 상대적으로 많지 않아서 Material Design에 대한 정의는 위키에서 가져왔습니다.여하간 이런 Material Design에 대한 concept을 Angular application에 적용하기 위해 만든 Component가 바로 Angular Material입니다.우리의 예제는 이 Angular Material로 작성할 것이기 때문에 Angular Material을 어떻게 사용하는지에 대해서 먼저 알아볼 필요가 있습니다.  참고로 Angular Material은 정식버전이 나온지 얼마 되지 않았습니다. 해서 생각만큼 많은 Component와 기능을 지원하고있지 못합니다. Angular Material Official HomePage의 공식 문서 역시 아직은 좀 사용하기 불편합니다. 차차 나아지겠죠 ^^;;우리예제는 Bootstrap도 같이 이용합니다.Bootstrap에 대해서는 그 때 알아보기로 하겠습니다.자 그럼 Angular Material에 대해 알아보도록 하죠. Angular Material &amp; Angular Material CDK 설치제일 먼저 해야 할 일은 Angular Material과 Angular Material CDK를 설치하는 것입니다.우리가 만들어 놓은 mySearchProject에서 command 창을 열고 다음 명령을 수행시켜 package를 설치합니다. ( 현재 경로는 C:/mySearchProject 입니다. )  npm install --save @angular/material @angular/cdk--save option은 npm@5부터 기본 option으로 바뀌었습니다. 즉, --save는 생략하셔도 됩니다. 잘 아시겠지만 저 명령을 수행하면 package.json의 dependencies에 설치된 패키지와 버전 정보가 기록되게 됩니다.참고로 만약 개발 시에만 사용하는 package를 설치하실려면 --save-dev option을 주시면 됩니다. TypeScript와 같은것은사실 transpiler이기 때문에 개발시에만 필요하고 실제 배포까지 할 필요는 없으니 TypeScript같은 건 --save-dev로devDependencies에 포함시키는게 좋습니다. 그런데 우리는 그냥 전역으로 설치해서 쓰고 있죠 ^^;;여하간 약간의 시간이 지나면 package가 설치됩니다. Angular Animation Module 설치몇몇개의 Material Component는 Angular Animation Module에 의존성을 가지고 있습니다. 따라서 다음 명령을 수행시켜 Angular Animation Module을 설치해야 합니다.  npm install --save @angular/animations이 @angular/animations module은 내부적으로 WebAnimation API을 이용합니다. 그런데 모든 browser들이 이 API를 지원하는건 아닙니다. 만약 WebAnimation API를 지원하지 않는 browser를 이용할 경우는 여기를클릭해서 나온 내용에 따라 따로 처리해 주셔야 합니다.이제 우리 project에서 src/app 폴더 안에 있는 Root Module인 app.module.ts 파일을 열어 다음과 같이 수정합니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// BrowserAnimationsModule import 구문 추가import { BrowserAnimationsModule } from '@angular/platform-browser/animations';import { AppComponent } from './app.component';@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule,    BrowserAnimationsModule  // BrowserAnimationsModule 추가  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { } 사용할 Component import설치가 다 되었으니 이제 사용할 Angular Material Module을 import해야 합니다.사실 이부분은 나중에 View에 대한 HTML을 작성할 때 해야 되는 작업입니다. 어떤 Component를 이용하여 View를 구성할지결정이 되어야 import할 수 있기 때문이지요.나중에 추가할 내용이지만 일단 하나만 먼저 연습삼아 추가해보도록 하겠습니다. 여기서 사용할 것은 Material Table Component입니다. 해당 Component를 사용하기 위해 import하는 작업이 필요합니다.추후에 구현에 필요한 Component들이 더 추가되어야 하는데 이런 Component들은 실습을 진행하면서 추가하도록 하겠습니다.우리 project에서 src/app 폴더 안에 있는 Root Module인 app.module.ts 파일을 열어 다음과 같이 수정합니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// BrowserAnimationsModule import 구문 추가import { BrowserAnimationsModule } from '@angular/platform-browser/animations';// Material Table Component 사용을 위한 MatTableModule importimport { MatTableModule } from '@angular/material/table';import { AppComponent } from './app.component';@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule,    BrowserAnimationsModule,  // BrowserAnimationsModule 추가    MatTableModule            // MatTableModule 추가  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { } 사용할 Theme 설정application에 적용할 Theme를 설정해 보도록 하죠. 기본적으로 제공되는 built-in theme는 현재 4가지가 존재하는데 그 중 하나를 설정하시면 됩니다.우리는 Angular CLI를 이용하고 있기 때문에 src 폴더 안에 있는 styles.css 파일을열어서 다음의 코드를 넣어주면 됩니다. styles.css 파일은 우리 application 전역에 적용되는global CSS 파일입니다.@import '~@angular/material/prebuilt-themes/indigo-pink.css';만약 다른 theme를 이용하고 싶으면 여기를 참조해 다른 이름의 CSS 파일을 이용하시면 됩니다. Gestures 지원을 위한 HammerJS 설치사용자 Gestures를 지원하기 위해 몇몇개의 Material Component들은 HammerJS에 의존하고 있습니다. 그렇게 때문에 이 HammerJS 역시 설치하고 설정까지 잡아줘야 합니다.  npm install --save hammerjs설치가 끝나면 우리 application의 시작지점(entry point)인 main.ts 파일을 열어서 제일 상단에다음과 같은 코드를 추가해 줘야 합니다.// hammerjs import 추가import 'hammerjs'; Material Icon 사용을 위한 설정Material은 쉽게 사용할 수 있는 Icon을 제공해 줍니다. 마치 Font-Awesome처럼 사용할 수 있습니다. Material Icon을 사용하기 위해서는 index.html을 다음과 같이 수정합니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;title&gt;BookSearchAngular&lt;/title&gt;  &lt;base href=\"/\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;  &lt;!-- Material Icon 설정 --&gt;  &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;  &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;Material Icon의 사용방법에 대한 자세한 내용은 여기를 확인해 보시면 됩니다.Angular Material을 사용하기 위한 설정이 끝났습니다. 이제 Angular Material Official HomePage의 Components 메뉴를 클릭해 사용할 Component의 종류와 사용방법을 찾아 적절하게 작성만 해 주면 될 듯 싶습니다. 다음 포스트에서Angular Material을 이용해 화면구성과 Component 설정을 해 보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-material"
    }
    ,
    
    "angular-lecture-component": {
        "title": "Angular 강좌(3) - Component",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Component 개요Angular는 Front End Web Application Framework입니다.우리는 Angular로 Web Browser상에서 동작하는 Client가 사용하는 응용 프로그램을 만들어 낼 수 있습니다. 이런 프로그램은 사용자가 직접 접근할 수 있는 View라는 것을 가지고 동작합니다.전체 웹 어플리케이션 화면이 하나의 View가 될 수도 있고 어플리케이션 화면의 기능이나 목적에 따라 세부 View들로 분할 되어 웹 어플리케이션의 화면을 구성할 수 도 있습니다.예를 들면 다음과 같이 View를 분할해서 화면을 구성할 수 있습니다.( 이미지 출처 : https://msdn.microsoft.com )위의 그림에서 A는 로고영역, B는 사진에 대한 설명영역, C는 주 사진보기 영역, D는 컬렉션에 있는 다른 사진의 미리보기영역입니다.이렇듯 우리는 화면을 여러 View들로 분할해서 구성할 수 있다는 것이죠. 분할된 View들은 결국 Angular에서 Component의 단위가 됩니다.위의 그림은 View들이 화면을 분할하고 있는 형태입니다. 이렇게 할 수도 있지만 아래의 그림처럼 하나의 View안에 여러 View들을 넣어 화면을 구성 할 수도 있습니다. 파란색 View안에 2개의 빨간색 View가 들어가 있고 그 안에 다시 View들이구성되어 있는 형태입니다. 이렇게 View간의 포함관계가 성립될 수 있고 결국 View들간에 부모와 자식의 관계가 성립되게 됩니다.View는 결국 Component의 단위가 된다고 했으니 View들의 관계에 의해서 Component들도 부모와 자식간의 관계가 생기게 됩니다.이런 Component간의 관계가 크게 보면 tree모양으로 구성되게 되는데 이를 Component Tree라고 하는데 Angular의 중요한 개념 중 하나입니다.이 Component tree의 제일 위쪽에 위치한 Component를 우리는 Root Component라고 부릅니다.Component는 View를 rendering하는 주체가 되기 때문에 어떤 정보로 View를 rendering할 것인가에 대한 정보를 가지고 있어야 합니다. 이 정보를 우리는 Template이라고 합니다. TemplateTemplate은 View를 rendering하기 위해 필요한 HTML Element와 Angular의 문법요소 그리고 클라이언트 이벤트 처리 코드를 담고 있습니다.  Application 실행 시 Angular는 Component와 Template의 정보를 이용하여 View를 그리게 됩니다.( 이미지 출처 : https://angular.io/guide/architecture ) Component - class기존에 만들어 놓았던 MySearchProject를 살펴보면서 코드상으로 Component를 이해해보죠. WebStorm에서 우리가작성한 프로젝트를 보면 src 폴더가 보입니다. 이 src폴더를 보면 index.html 파일이 존재하는데 이 파일이 우리 Web application의 시작 HTML파일입니다. 즉, http://localhost:4200 으로 접속하면 rendering되는 파일이 바로 이 index.html입니다.아래의 내용은 index.html 입니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;title&gt;MySearchProject&lt;/title&gt;  &lt;base href=\"/\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;&lt;/head&gt;&lt;body&gt;  &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;&lt;app-root&gt;&lt;/app-root&gt;라는 태그 대신에 특정 내용이 화면에 보이는 구조이군요. 즉, &lt;app-root&gt;&lt;/app-root&gt;가 하나의 View라는 의미입니다. 당연히 그에 대응되는 Component가 존재하겠네요.src/app 폴더에 보면 app.component.ts 파일이 있습니다. Component를 정의한 파일이고 TypeScript로 작성되어 있기 때문에확장자는 .ts를 이용합니다. 파일을 열어보면 다음과 같은 내용이 들어있습니다.import { Component } from '@angular/core';@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css']})export class AppComponent {  title = 'app';}코드에서 맨 마지막에 나타나듯이 Component는 class입니다. 하지만 class를 선언한다고 해서해당 class가 무조건 Component가 되는것은 아닙니다. 이 class가 Component로 사용된다는 것을 Angular에게알려주어야 Angular가 Component로 동작을 시킬수 있을 겁니다. 그래서 특정 표현을 이용해 해당 class가 Component임을 Angular에게 알려주어야 합니다.@Component라고 표현되는 부분이 바로 Component decorator입니다. 무언가와 많이 비슷하죠? 의미상 Java의Annotation과 하는일이 유사하다고 보시면 됩니다. class상단에 Component decorator를 이용해 Angular가 해당 class를 Component로인지할 수 있도록 합니다.@Component를 이용하려면 당연히 Component decorator를 사용할 수 있는 상태여야 하고 이 Component decorator는@angular/core라고 표현되는 Angluar Core Module Package에서 제공합니다. 해서 아래와 같은 코드가 필요합니다.import { Component } from '@angular/core'; Component - Metadata위에서 Component decorator에 대해서 알아봤는데 이 Component decorator를 이용해 설정 정보를 Angular Framework에게전달할 수 있습니다. 이 설정정보를 Metadata라고 하며 다음과 같은 코드로 표현됩니다.@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css']})Component decorator안에 표현될 수 있는 Metadata는 상당히 종류가 많지만 필수요소는 없습니다. 하지만 selector와 template 정보는 존재하지 않으면 화면에 rendering이 되지 않기 때문에 필수요소라 볼 수 있습니다.      selector : template 코드안에서 해당 Component를 사용하고자 할 때 이용할 HTML Element명을 정의합니다. 위와 같은 경우 해당 Component는 &lt;app-root&gt;&lt;/app-root&gt; HTML Element로 사용될 수 있습니다.        template 정보 :  template 혹은 templateUrl을 이용할 수 있습니다. template은 View를 rendering할 때 필요한HTML을 inline형태로 직접 기술할 때 사용됩니다. templateUrl은 template code를 따로 HTML 파일로 분리해서 작성할 때 사용합니다.        style 정보 : styles 혹은 styleUrls을 이용할 수 있습니다. template 정보에 명시된 HTML에 대한 style을정의한 CSS가 inline형태 혹은 파일 형태로 포함될 수 있습니다. 여러 CSS 정의와 파일을 이용할 수 있기 때문에 배열형태로 표현합니다.   Module &amp; BootstrappingBootstrapping이란 browser에서 application이 최초로 실행될 때 진행되는 과정을 의미합니다. 우리가 작성한 Component는application이 bootstrapping될 때 Angular에 의해서 제어되게 됩니다.Angular에는 Module 개념이 있습니다. Module은 Application을 구성하는 단위로 관련된 요소를 하나로 묶어 놓은 것으로 생각하시면됩니다. Angular는 Module단위로 application 코드를 인식하기 때문에 모든 Angular application은 반드시 하나 이상의 Module을 가지게 되며 최상위 모듈을 우리는 Root Module이라고 부릅니다.  이러한 Module안에 Component와 같은 것들을 선언해 놓아야 비로소 사용할 수 있게 됩니다.Root Module은 관례상 AppModule이라 명하고 class로 표현하게 됩니다. src/app 폴더안에 app.module.ts 파일이 존재하는데이 파일안에 Root Module이 정의되어 있습니다.// BrowserModule은 Web Application인 경우 Root Module에서 // 반드시 import 처리를 해야 합니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { }  BrowserModule은 Web Browser를 위한 Module입니다. 지금 우리가 작성하는 프로젝트처럼 브라우저에서 동작하는Web Application인 경우 Root Module은 반드시 BrowserModule을 import해야 합니다.위의 코드에서처럼 AppModule class가 정의되어 있고상단에 @NgModule decorator를 이용하여 우리의 class가 Module임을 명시했습니다.import { AppComponent } from './app.component';위의 코드는 아까 살펴본 Component인 app.component.ts 파일로부터 AppComponent class를 import하는 부분입니다. 아까 위에서AppComponent class를 export 처리했던 걸 보셨을 텐데 이렇게 export된 class를 외부에서 import해서 사용할 수 있습니다..ts파일로부터 import를 할 경우 확장자인 .ts는 명시하지 않습니다. 이렇게 import한 class를 Module안에서 declarations를 이용해 선언해서 사용하게 됩니다.  declarations안에는 Component, Directive, Pipe에 대한 리스트가 선언됩니다. 이렇게 선언된요소만이 Module내에서 사용이 가능합니다.  imports안에는 의존 관계에 있는 Angular Library Module과 하위 Module, Routing Module,Ionic과 같은 Third Party Module이 포함됩니다.@NgModule decorator의 Metadata 중 bootstrap은 오직 Root Module만 가지고 있는 property입니다.application이 bootstrapping될 때 Root Module에 의해서 어떤 Component가 사용될 것인지를배열로 선언합니다. 즉, bootstrap은 browser가 최초로 index.html을 읽어들여 application을 시작할 때 사용할 Component를 명시하게 됩니다.@NgModule decorator의 Metadata에 사용되는 Component를 등록해 놓아야 우리가 작성한 Component의 TypeScript 코드를 browser에서 실행 가능한 JavaScript 코드로 compile해서 변환시킬 수 있습니다.마지막으로 src/main.ts 파일을 열어보면 다음과 같은 코드를 볼 수 있습니다.platformBrowserDynamic().bootstrapModule(AppModule)  .catch(err =&gt; console.log(err));Angular는 저 위의 코드로 AppModule을 읽어들이고 Module안에 등록된 여러 Component들을 JavaScript 코드로 compile하게되는 것 입니다.정리하자면 Root Module은 최상위 Module로 main.ts에 의해 bootstrap됩니다. 이 때 위에서 언급한 Component Tree의 최상위 Component인 Root Component가 Root Module에 의해서 bootstrap되는 것이지요. 따라서 모든 Angular 프로젝트는Root Module과 Root Component를 반드시 가지고 있어야 합니다.  지금까지 살펴본 것처럼 만약 Angular CLI를 이용하지 않으면 우리가 .ts 파일을 만들어서 등록하는 과정을 직접해야합니다. Angular CLI를 이용하면 기본 Skeleton 코드의 생성과 등록절차까지 자동으로 처리되게 됩니다. Component Tree사실 위에서 언급한 내용인데 중요한 부분이니 다시한번 정리하고 넘어가겠습니다.Angular application안에는 여러 View들이 존재할 수 있습니다. 개념적으로 하나의 View안에 여러개의 View들이 child형태로 존재할 수 있습니다. View는 Component와 대응된다고 했으니 결국 Component안에Component가 child형태로 구성될 수 있다는 의미겠네요.  이것을 우리는 Component Tree라고 합니다.그림으로 표현하자면 다음과 같이 표현될 수 있습니다.( 이미지 출처 : https://angular.io/guide/architecture )좀 어렵게 표현하자면 application의 화면구성을 끝내면 그 내용을 토대로 View를 결정해서 Component단위로 Modeling 해야합니다.이번 포스트에서는 Angular Component의 기본적인 사항에 대해서 알아보았습니다. 여기까지의 내용을 가지고 간단한 실습을 진행하면서 다른 사항들도 하나씩 알아보도록 하겠습니다. 실습을 진행하기에 앞서 Angular Material에 대해 먼저 알아보고 Material을 이용하여 우리 mySearchProject의 화면을 분할 하고 Component를 생성해 보는 실습을 진행하도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-component"
    }
    ,
    
    "angular-lecture-development-environment": {
        "title": "Angular 강좌(2) - 개발환경세팅",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Angular 개발환경 - Node.js, WebStorm, TypeScript이번 포스트에서는 Angualr의 개발환경을 세팅하고 Angular CLI를 이용하여 기본적인 Hello World App을 생성, 실행하는 것까지 진행하도록 하겠습니다.제일 먼저 해야 할 일은 Node.js를 설치하는 것입니다. Angular CLI와 TypeScript가 node module로 존재하기 때문에npm을 이용하여 이 두가지를 설치해야 합니다.먼저 Node.js사이트에 접속해 LTS 버전이나 최신버전 둘 중 하나를 선택해다운로드 합니다. (어떤것을 설치해도 상관없습니다.)저는 LTS 버전으로 다운로드 했습니다. 다운로드가 끝나면 기본 형태로 설치를 진행합니다. 설치가 끝나면C:/Program Files/nodejs 폴더가 만들어지게 됩니다.이제 command 창을 열어서 다음과 같은 명령어를 실행합니다.  npmnpm(Node Package Manager)이 정상적으로 동작하면 이제 npm을 이용해 typescript를 설치할 수 있습니다.설치는 local mode와 global mode로 설치가 가능합니다. 여기서는 편의상 global mode로 설치합니다.global mode로 모듈을 설치하면 모든 프로젝트에서 사용가능한 형태로 시스템에 설치됩니다. local mode로 설치하면해당 프로젝트에서만 사용가능한 형태로 모듈이 설치 되게 됩니다. (일반적으로는 local mode를 선호합니다.)command 창에서 다음의 명령어를 실행해 typescript를 global mode로 설치합니다.  npm install -g typescripttypescript 2.6.2가 설치되었습니다.  global mode로 설치하면 windows 시스템을 기준으로 $USER_HOME/AppData/Roaming/npm/node_modules에 설치됩니다.이제 사용할 IDE(Integrated Development Environment)를 설치합니다. 여기서는 WebStorm(유료)을 이용합니다.Visual Studio Code(무료)를 사용하셔도 됩니다. WebStorm은 유료이지만 30일 trial을 사용할 수 있고 Student 라이선스를이용하면 1년간 무료로 사용할 수 도 있습니다. 개인적으로는 비용이 좀 들지만 WebStorm을 추천합니다. Front End 개발은 역시WebStorm이 편합니다. ( 사실 손에 익어서 그렇습니다. Visual Studio Code를 이용해도 아무 문제 없습니다. )JetBrains 사이트로 접속한 후WebStorm을 다운로드 받습니다.다운로드가 완료되면 기본형태로 설치합니다. 설치가 끝나면 프로젝트를 생성할 수 있는 화면이 나오게 되는데 일단 이 화면에서 대기합니다.프로젝트는 Angular CLI를 이용해서 생성합니다. Angular 개발환경 - Angular CLI일반적으로 Framework를 도입할 때 가장 힘든점 중 하나는 개발환경 구축입니다. 기본적인폴더구조를 숙지해서 만들어야 하고 기본적으로 사용되는 설정 파일들도 다수 존재합니다. 처음에는 대부분 뭐가먼지 알기 힘들죠.코드를 작성한 후 Build 설정, Bundler 설정, 테스팅과 배포등 너무 많은 일을 해야하고 설정방법 또한 복잡합니다.Angular 역시 마찬가지입니다. Mike Brocchi( Angular CLI contributor )의 Twitter 설문을 예로 들어보죠. 설문에서나온것처럼 초기 환경 세팅과 복잡성을 가장 큰 문제 중 하나로 여기고 있는걸 볼 수 있습니다.다행스럽게 Angular는 Angular CLI를 제공함으로 이런 복잡함을 해결하고 있습니다. Angular CLI를 이용할 경우와 그렇지 않는 경우를 간단히 그림으로 표현하면 다음과 같습니다.( 이미지 출처 : https://www.quora.com/What-is-Angular-CLI )Angular Project를 쉽게 생성하고 프로젝트를 시작하기 위한 scaffolding을 포함해서 다양한 기능을 제공하는 것이 바로 Angular CLI입니다. 사실 쓰지 않을 이유가 없습니다.그럼 Angular CLI를 설치해보도록 하죠. command 창을 열어서 다음과 같이 실행합니다.  npm install -g @angular/clinpm을 이용하여 Angular CLI를 global mode로 설치합니다. 설치하는데 시간이 좀 걸립니다. 설치가 끝나면 다음과 같이 실행해서 Angular CLI의 버전을 확인해 보세요.  ng --version Angular 프로젝트 생성Angular CLI의 설치가 끝났으니 이제 Angular CLI를 이용하여 프로젝트를 하나 생성합니다. 프로젝트명은 mySearchProject로 하겠습니니다.프로젝트 폴더는 C:/mySearchProject로 생성할 것이기 때문에 저는 현재 command 창의 working directory를 C:/로 잡아놓고 다음과 같이 입력합니다.  ng new mySearchProject시간이 제법 오래 걸립니다. 필요한 의존 모듈들을 npm을 이용해 다운로드 받기 때문입니다. 프로젝트 생성이 끝나면자동으로 생성된 설정 파일과 기본 Skeleton 코드가 프로젝트 폴더안에 위치하게 됩니다. 만약 의존 모듈을 설치하지않고 프로젝트 기본 구조와 파일만 scaffolding할 목적이라면 --skip-install option을 이용하시면 됩니다.  Angular CLI는 나름대로의 Coding Convention을 가지고 있습니다. 그 규칙에 대해서는 나중에 다른포스트에서 알아보겠습니다.이렇게 Angular CLI를 이용해서 프로젝트를 생성할 수 있는데 이 프로젝트 구조와 Coding Convention이 Angular의 표준형태라고 보시면 됩니다.설정파일에 대한 내용은 나중에 다시 보기로 하고 일단 WebStorm으로 해당 프로젝트 폴더를 open합니다.아래의 그림처럼 WebStorm에서 프로젝트 폴더가 보이게 됩니다.기본적으로 Git Repository가 같이 생성됩니다. 꼭 그렇게 하실 필요는 없지만 가능한 Git과 GitHub를이용하여 Project의 버전관리를 하시는게 좋습니다. 개발환경 서버를 이용한 Angular 프로젝트 실행command 창을 열어 프로젝트 root로 working directory를 이동시킨 후 다음의 명령을 실행하면 Webpack을 이용하여 우리 소스를 bundling하고 로컬 웹서버를 이용하여 우리 프로젝트를 서비스하게 됩니다.  ng serve명령 수행이 끝나면 webpack: Compiled successfully. 메시지가 출력됩니다. 이제 browser를 실행시켜 다음 URL로 접속해 정상적으로 출력되는지 확인하시면 됩니다.  http://localhost:4200참고로 아래와 같이 --o option을 이용해서 ng serve를 실행시키면 default browser를 실행시켜서 해당 URL에 접속해 결과를 쉽게 확인할 수 있습니다.  ng serve --o이번 포스트에서는 Angular application을 개발하기 위한 개발환경을 구축했습니다. 우리 강좌에서는 Testing과 관련된 사항은 다루지 않을 예정입니다. Testing과 관련된 사항은추후에 다른 포스트에서 다루도록 하겠습니다.이제 기본으로 만들어진 MySearchProject application을 조금씩 수정하면서 우리의 Angular 프로그램을 완성해 나가면 될 듯 합니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-development-environment"
    }
    ,
    
    "angular-lecture-introduction": {
        "title": "Angular 강좌(1) - Introduction",
            "author": "angular",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle Angular VersionAngualr의 History와 개요부터 간단하게 살펴보겠습니다.Angular는 JavaScript based Open Source Front End Web Application Framework 입니다.초기 버전인 AngularJS는 2010년 발표되었습니다. 지금은 Angular 1이라고 표현하기도 합니다. 버전 정책이 AngularJS 1.x로 올라가는 것이죠. 그렇게 발전해오다가2016년 9월에 Angular 2가 정식으로 release되었습니다. 그러면서 Angular 2라고 명시하지 않고 Angular라는 이름으로 호명하기로결정합니다. 지금 우리가 Angular라고 부르는 것은 모두 Angular 2 이후 버전입니다. 2017년 3월에 Angular 4가 release되었고 현재(2018년 1월)기준으로 Angular 5 까지 나온 상태입니다.  2017년 12월 3일부로 다음의 사항들이 정식으로 release되었습니다.      Angular 5.1.0    Angular CLI 1.6.0    Angualr Material    Angular Material CDK(component dev kit)  정리를 하자면 AngularJS라고 표현되는 Angular 1은 버전이 AngularJS 1.0, AngularJS 1.1, AngularJS 1.2, … 이렇게 올라가고 Angular라고 표현되는 Angular 2는 버전이 Angular 2.x.x, Angular 3.x.x, Angular 4.x.x, … 이렇게 올라갑니다. Angular 3는 Router issue때문에 release가 최소되었습니다. 그래서 Angular 2 다음 Major 버전이 Angular 4가 됩니다. 2017년 11월에 release된 Angular 5는 Angular 2의 3번째 Major 배포판 이라는 말이지요.Angular는 유의적버전(SemVer)을 도입해서 버전 체계를 Major.Minor.Patch로 표현합니다. 즉, Angular 5.2.4 이렇게 표현하는 것이지요. 6개월을 기준으로 1회의 Major, 3회의 Minor 그리고 주단위로 패치가 실시되고 있습니다. Major Release는 Breaking Change가 포함될 수 있습니다. Breaking Change란 이전버전과 호환성이 없는 변화를 지칭합니다. 따라서 시간이 좀 지나면 지금의 Angular와또 많이 다른 모습의 Angular가 될 확률도 있습니다. 물론 Google에서는 가능한 그런 경우를 없앤다고 발표했지만 모를일이죠.기존의 AngularJS와 지금의 Angular는 Architecture측면이나 구현측면에서 큰 차이가 있습니다. 그렇기 때문에 Angular 2 architecture가 발표되었을 때 많은 AngularJS 개발자들이 황당해 했던것도 사실입니다. 여하간 AngularJS는 역사속으로 사라지고 있습니다. 사실 Google에서도 AngularJS 시절에는 내부적으로 AngulraJS를 사용하지 않았습니다. 하지만 Angular로 넘어오면서 자사의 개발자체도Angular로 진행하고 있고 Angular를 단지 web framework에서만 사용하는 기술이 아닌 모든 platform에 대응할 수 있는 형태로 발전시키고 있습니다.  다음은 기존의 AngularJS와 지금의 Angular의 중요 차이점 중 몇가지 입니다.      AngularJS의 Controller와 $scope 기반 개발방식에서 Angular의 컴포넌트 기반 개발방식(CBD, Component Based Development)으로 개발방법 변경되었습니다.    Angular의 주력 개발 언어로 TypeScript가 도입되었습니다.    Angular는 개발환경 지원도구인 Angular CLI를 제공합니다.  이외에도 더 많지만 일단 저 위의 3가지만 기억하시면 될 듯 합니다. 저 위의 3가지로 인해 개발 생산성과 성능면에서 큰 향상을이루었습니다. 하지만 결정적(?)인 단점이 있습니다. Angular는 대부분의 browser를 지원하고 있는데 IE의 경우 9버전 이상부터 지원합니다. 따라서 Cross Browsing의 issue를 가지고 있습니다.아참..로고도 바꾸었습니다. 테두리가 있는 방패모양의 로고에서 테두리를 빼고 A글자를 흰색으로 바꾸었습니다. ^^;;( 이미지출처 : http://nodesimplified.com/angularjs-to-angular/ )이 링크를 클릭해 보시면 Angular의 버전 업데이트에 대한 ChangeLog를 확인할 수 있습니다. 일 무지 열심히 하네요. 따라가기 힘들정도입니다. Angular 학습을 위한 pre-requisiteAngular는 Steep Learning Curve를 가집니다. 배우기가 힘들다는 거죠. 적어도 기본적인 JavaScript 개발에 대한 지식과TypeScript에 대한 지식, 그리고 객체지향개발(OOP)에 대한 지식을 필수로 요구합니다. 물론 Angular를 배우면서 같이 하면 되긴 하지만 힘든건 사실입니다.해서 Angular 강좌 역시 기본적으로 다음과 같은 선행지식을 필요로 합니다.  JavaScript  TypeScript  OOP(Object Oriented Programming)  Front End 개발 도구 ( npm, babel, webpack, gulp 등등)참고로 이 링크에 가보시면 현재 Front End 개발환경에 대한 간단한 포스트를 보실 수 있습니다. 또한 이 링크에 가보시면 TypeScript에 대한 강좌 역시 보실 수 있습니다.말은 어렵다고 했지만 하다보면 또 그냥 저냥 하게 됩니다. 일단 기본적인 소개는 이정도로 하고 개발환경부터세팅해 보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-introduction"
    }
    ,
    
    "typescript-class": {
        "title": "TypeScript 강좌(7) - Class",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Class기존의 JavaScript는 재사용 가능한 component를 만들기 위해 함수와 prototype에 기반한 상속을 이용했습니다. 하지만기존 객체지향에 익숙해 있는 개발자들에게는 상당히 생소한 개념이었죠. 그래서 ECMAScript 2015( ES6 )에서는 개발자들이 좀 더 쉽게 JavaScript Application을 구현할 수 있도록 전통적인 class 기반의 객체지향 개념을 도입했습니다.TypeScript 역시 이 class기반의 객체지향 기법을 이용해 Application을 개발할 수 있습니다.일단 ECMAScript 2015( ES6 )의 class는 다음과 같이 정의하고 사용할 수 있습니다.class Book {    constructor(btitle,bauthor) {        this.btitle = btitle;        this.bauthor = bauthor;    }    printInfo() {        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}let book = new Book('젊은 베르테르의 슬픔','괴테');book.printInfo();위의 코드는 data type의 정보를 포함하고 있지 않기 때문에 TypeScript로 변형하면 오류가 발생합니다.적절히 타입 정보를 포함해 코드를 수정하면 다음과 같습니다.class Book {    btitle: string;    bauthor: string;    constructor(btitle:string, bauthor:string) {        this.btitle = btitle;        this.bauthor = bauthor;    }    printInfo(): void {        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}let book:Book = new Book('젊은 베르테르의 슬픔','괴테');book.printInfo();위의 코드는 Java에서 우리가 익히 보아왔던 class의 형태입니다. 생성자를 표현하는 부분이 좀 생소하지만 쉽게이해할 수 있을 듯 합니다. Inheritance일반적인 객체지향언어의 Inheritance 개념 역시 TypeScript에도 사용할 수 있습니다. 다음의 코드를 보죠.class Book {    btitle: string;    bauthor: string;    // 상위 클래스의 생성자    constructor(btitle:string, bauthor:string) {        this.btitle = btitle;        this.bauthor = bauthor;    }    // 상위 클래스의 method    // 입력 인자가 있으면 사용하고 없으면 default 사용    printInfo(input:string = 'Initial'): void {        console.log(input);        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}// class의 상속class EBook extends Book {    btype: string;    constructor(btitle:string, bauthor:string, btype:string) {        // 상위 class 생성자 호출        super(btitle, bauthor);        this.btype = btype;    }    // method overriding    printInfo(): void {        // 상위 class의 method 호출        super.printInfo();        console.log(`제목: ${this.btitle},                      저자: ${this.bauthor},                     타입: ${this.btype}`);    }}// IS-A relationship에 의한 상위 class type 사용let book:Book = new EBook('젊은 베르테르의 슬픔','괴테',    'PDF');// dynamic binding에 의한 overriding method 호출.book.printInfo();기존 class를 확장하여 새로운 class를 정의하는 방법입니다. IS-A Relationship 역시 성립합니다. 그로 인한상위 타입으로 객체를 사용할 수 있습니다. 또한 위의 예에서 처럼 method overriding의 개념 역시 존재하고 dynamic binding 개념 역시 존재합니다. 물론 TypeScript에서는 공식적으로 저 용어를 사용하지는 않습니다.다만 우리가 Java언어에서 알고 있던 객체지향 개념이 그대로 TypeScript에도 일부 적용된다고 보시면 됩니다. Access ModifierTypeScript는 3가지 종류의 접근제어 연산자를 제공합니다. 우리에게 익숙한 public, protected, private 키워드로 제공되며 default값은 public입니다. 즉, Access Modifier를 명시하지 않으면 모두 public으로 간주됩니다.  public : 접근제한이 없습니다. class외부에서 자유롭게 접근이 가능합니다.  protected : class 외부에서 접근할 수 없습니다. 단, 상속받은 하위 class에서는 접근이 가능합니다.  privatre : class 외부에서 접근할 수 없습니다. 상속받은 하위 class에서도 접근이 불가능합니다.class Book {    protected btitle: string;    public constructor(btitle:string, private _bauthor:string) {        this.btitle = btitle;    }    public printInfo(): void {        console.log(`제목: ${this.btitle}, 저자: ${this._bauthor}`);    }    // private property인 _bauthor의 getter    get bauthor(): string {        return this._bauthor;    }    // private property인 _bauthor의 setter    set bauthor(value: string) {        this._bauthor = value;    }}class EBook extends Book {    private btype: string;    public constructor(btitle:string, bauthor:string, btype:string) {        super(btitle, bauthor);        this.btype = btype;    }    public printInfo(): void {        console.log(`제목: ${this.btitle},                      저자: ${this.bauthor},                     타입: ${this.btype}`);    }}let book:Book = new EBook('젊은 베르테르의 슬픔','괴테',    'PDF');book.printInfo();위의 예제에서는 다음의 코드를 주의해서 보아야 합니다. 생성자의 인자로 private _bauthor:string라고 선언된 부분이 보입니다.    protected btitle: string;    public constructor(btitle:string, private _bauthor:string) {        this.btitle = btitle;    }생성자에 인자를 명시할 때 access modifier를 같이 명시하면 위의 예처럼 명시적으로해당 property가 선언되어 사용할 수 있게 됩니다.일반적으로 private property의 이름은 앞에 _를 관용적으로 써주게 됩니다. 이렇게 사용하는 이유는관용적 coding convention 때문에 그렇습니다. ECMAScript에서는 개발자들이 private의 의미로 사용되는property에 일반적으로 _를 붙여서 사용했었습니다.또 다른 이유는 setter와 getter의 이름때문에 그렇습니다. 다음의 코드에서 보듯이 TypeScript에서 getter와 setter의 표현은 우리가 알고 있는 다른 언어의 getter, setter와 다릅니다. 그리고 이렇게선언된 getter와 setter가 어떻게 사용되는지도 유의해서 보시기 바랍니다.    // private property인 _bauthor의 getter    get bauthor(): string {        return this._bauthor;    }    // private property인 _bauthor의 setter    set bauthor(value: string) {        this._bauthor = value;    } Readonly Propertyclass의 property를 readonly로 지정할 수 있습니다. readonly로 지정되면 property가 선언될 때 혹은 생성자안에서반드시 초기화를 진행해야 합니다. 다음의 예제를 참고하시면 됩니다.class Book {    public readonly btitle: string;    constructor(btitle: string) {        this.btitle = btitle;    }}let book:Book = new Book('젊은 베르테르의 슬픔');book.btitle = '파우스트';   // 코드 에러다음의 예제처럼 생성자의 parameter를 readonly로 선언하면 따로 class의 property로 선언할 필요가 없습니다.class Book {    constructor(readonly btitle: string) {        this.btitle = btitle;    }}let book:Book = new Book('젊은 베르테르의 슬픔');console.log(book.btitle); Static Propertystatic 키워드 역시 사용할 수 있습니다. ECMAScript 2015에서는 static을 method에만 적용할 수 있었지만TypeScript는 property에도 적용할 수 있습니다. static property는 class의 이름으로 직접 access를 할 수 있습니다.class Book {    public btitle:string;    static count: number;    constructor(btitle: string) {        this.btitle = btitle;        Book.count++;    }}let book1:Book = new Book('젊은 베르테르의 슬픔');let book2:Book = new Book('파우스트');console.log(Book.count); Abstract Classabstract class는 하나이상의 abstract method를 가지고 있는 class를 의미합니다. method의 선언만을 가지고 있기때문에 직접적인 객체생성을 할 수 없고 상속을 이용해 하위 클래스에서 abstract method를 overriding해서 사용하게 됩니다.abstract class Book {    public btitle:string;    constructor(btitle: string) {        this.btitle = btitle;    }    abstract printInfo(): void;}class EBook extends Book {    printInfo(): void {        console.log(this.btitle);    }}let book:Book = new EBook('젊은 베르테르의 슬픔');book.printInfo(); interface의 의미로 class사용이 부분은 기존의 다른 언어와 다릅니다. class를 확장해서 interface를 정의할 수 있습니다. 다음의 코드를 참조하세요class Book {    btitle: string;}interface EBook extends Book {    bauthor: string;}let book:EBook = {    btitle: '파우스트',    bauthor: '괴테'};이번 포스트에서는 TypeScript의 class에 대해서 살펴보았습니다. 객체지향 언어의 class와 상당히 유사하면서도약간의 차이점이 있었습니다. 차이점 위주로 기억하시면 될 듯 합니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-class"
    }
    ,
    
    "front-end-ecosystem": {
        "title": "Front-End 발전 역사와 개발 생태계",
            "author": "javascript",
            "category": "",
            "content": "Introduction이번 포스트는 과거 JavaScript 탄생부터 시작해서 어떻게 발전해왔는지에 대한 내용과 현재 Front End 개발에 있어서 무엇을 알아야 하는 지에 대한 전반적인 기술 상황에 대해서 알아보겠습니다. JavaScript 탄생JavaScript라는 언어의 역사는 저의 다른 포스트에서도 볼 수 있지만 여기서도 간단하게 언급하고 넘어가겠습니다.JavaScript언어의 역사는 1995년 Netscape사의 Brendan Eich(브랜든 아이크)에 의해 개발된 Mocha라는 언어부터 시작됩니다.이 Mocha라는 언어는 “Prototype의 개념과 Functional Language(함수형 언어)의 특성을 가지고 Web에 동적으로 활용할 수 있는 언어를 만들어보자” 라는 취지로 2주일 이라는 굉장히 짧은 기간안에 만들어졌습니다.추후에 Mocha -&gt; LiveScript -&gt; JavaScript로 개명되었고 ECMA에 ECMA-262 기술규격으로 ECMAScript라는 이름으로 표준화를진행하게 됩니다. 이에 대응해 1996년 MicroSoft 측에서는 JScript라는 걸 만들어내서 자사의 IE 3안에 포함시켜 제공하기 시작했습니다.이런 JavaScript는 여러가지 문제점을 내포하고 있었는데 가장 큰 문제를 꼽자면  구현의 어려움  언어의 모호성  Cross Browsing의 한계정도를 들 수 있습니다. 즉, 사용자 입력값을 검사하는 용도, 사용자의 이벤트를 감지해서 처리하는 용도로는 사용할 수 있지만 언어 자체가 가지고 있는 근본적인 문제때문에 사용이 힘들었습니다. 구세주의 등장 - jQuery이 때 구세주가 등장합니다. 우리가 잘 알고 있는 jQuery library입니다.jQuery는 open source javascript library로 순수 javascript가 가지고 있었던 DOM처리의 어려움과 Cross Browsing에 대한 issue를해결하면서 JavaScript의 대표적 library로 사용되게 되었습니다. jQuery로 인해 JavaScript가 조금은 쓸만한 언어로 여기지면서사용되기 시작했습니다.그러면서 그냥 그냥 아주 소소하게 client web browser안에서 JavaScript 코드와 jQuery 코드가 이용되었던 거지요. 특별히 중요하지도 않은단위코드 위주로 사용이 되는 그런 수준이었습니다. 그러면서 우리 기억에도 “알면 좋고 몰라도 상관없는 언어”로 인식되었습니다.그렇게시간은 흘러갑니다.!!1997년 ECMAScript의 초판이 나오게 됩니다. ES1이라고 합니다. 그 후 1999년에 ES3가 나오게 됩니다. 여기까지 하고 한동안ECMAScript 표준은 쿨쿨 잠을 자게 됩니다. 다시 JavaScript에 날개를 달아보자 - HTML51999년 12월 W3C(World Wide Web Consortium)에서 하나의 발표를 합니다. 아시다시피 W3C는 HTML과 CSS의 표준을 관장하는 기구입니다. 이때까지 우리가 사용하는 HTML의 버전은 4.01버전이었습니다. W3C는 이 버전을 마지막으로 더 이상 HTML의 버전업은 없을 것이라고 공표하게 됩니다. 그때까지 잘 사용해왔던 HTML을 왜 버전업하지 하지 않겠다고 했을까요?여러가지 이유가 있지만 프로그래밍 언어의 측면에서 바라보면 HTML이란 언어는 다음과 같은 한계점이 있습니다.  정형성 : HTML언어는 정형성이 없기때문에 유지보수에 적합하지 않다.  확장성 : 정해진 Tag만 이용하기 때문에 언어자체에 대한 기능적 확장이 어렵다.W3C는 저 두가지 이유를 들어 HTML언어를 이대로 끌고 가기 보다는 좀 더 다른 수단을 강구해야 겠다고 판단합니다. W3C의 선택은바로 XML의 도입이었습니다. 즉, HTML이 가지는 두가지 문제점을 해결할 수 있는 XML을 도입해서 새로운 Web언어의 표준을끌고 나갈 생각이었습니다. 그 결과 2000년 들어오면서 HTML과 XML이 결합된 새로운 표준인 XHTML 1.0이 발표되게 됩니다.W3C의 이런 의도와는 다르게 몇몇개의 회사들이 모여서 조금 다른 접근을 모색합니다. XML을 도입하지 말고 순수하게 HTML을 기능을버전업시킬 수 있는 방법을 찾기 시작한 것이죠. 그래서 WHATWG(Web Hypertext Application Technology Working Group)이라는 Working Group이 만들어지고 이 안에서 기존의 HTML을 발전시킬 방법을 연구하게 됩니다. ( 사실 여기서 할 말이 많기 한데 자꾸 산으로 가는 느낌이라 적당히 짜르겠습니다. ) 이 WG에서 나온것이 바로 현재의 표준인 HTML5입니다. HTML을 이용해서 Web Application을 만들자는 취지입니다. 이 HTML5안에 Client Web Application을 작성할 수 있는 API가 포함되어 있는데 이게 JavaScript로되어 있습니다. 결국 HTML5가 issue화 되면서 JavaScript의 위상도 조금씩 더 올라가게 됩니다.그래서인지 쿨쿨 잠을자던 ECMAScript 개정판(ES5)이 2009년에 등장합니다. 참고로 4판(ES4)은 버려졌습니다. 이제 슬슬JavaScript에 대한 발전이 시작됩니다. JavaScript의 획기적 전환점 - Node.js2013년 Node.js가 출시됩니다. 아무리 HTML5라고 해도 이때까지의 JavaScript는 Browser안에서 동작하는 언어였습니다.우리가 알고 있는 Java, C#과 같은 언어가 될 수 없는 태생적 한계가 있는거죠. 이런 browser에 갇힌 JavaScript를browser 외부로 탈출하게끔 만들어준 일등공신이 바로 Node.js입니다. 결국 JavaScript로 다른 언어처럼 OS위에서 동작하는일반 application을 작성할 수 있는 길이 열린것이고 그에 따라 언어의 위상이 완전히 변했습니다.그에 발맞춰 ECMAScript도 빠르게 변화하기 시작했습니다. 2015년에 ECMAScript 2015(ES6)가 등장하면서 JavaScript 언어자체에아주 큰 변화들이 많이 생겼습니다. 현재 ECMAScript 2016(ES7)까지 나온 상태입니다. 조금 지나면 ES8이 표준화되어서 나오겠네요.거의 1년마다 새로운 배포판이 나올정도로 빠르게 변화하면서 언어적 측면에서 가지고 있던 많은 문제점들을 극복하려고 노력하고 있습니다.현재(2018년 1월) 대부분의 browser들은 ES6를 지원하고 있습니다. 여기에 접속해 보시면 특정 browser에 대해 각 ECMAScript의 버전 호환성을 보실 수 있습니다.  이제 IE는 고만쓰도록 해요. 제발….아직 완벽하게 Cross Browsing이 안되는데 어떻게 하느냐에 대한 문제는 Babel, TypeScript와 같은 transpiler를 이용해서 해결할 수 있습니다. Babel, TypeScript는 ES6(ES7) 문법으로 쓰여있는 JavaScript code를 ES5 형태의 JavaScript로 변환시켜주기 때문에 IE에서 ES6지원이 안됨에도 불구하고 ES5로 변환해서 사용할 수 있습니다. 변화의 속도가 너무 빠름그런데 문제는 기술의 발전 속도가 너무 빠르다는데 있습니다. 또한 알아야 할게 한두 가지가 아니구요. 과거 Back End에서 사용했던 프로그래밍 기술과 여러가지 개발 툴의 개념들이 다 Front End로 넘어왔기 때문입니다.너무 많은기술들이 빠르게 생기고 빠르게 사라지고 있습니다.사실 2-3년전에 자주 사용했던 JavaScript Library와 Framework들 중 많은 것들이 이미 다른 것으로 대체되었습니다. 그렇다고 손 놓고 있을 순 없으니 현재 상태에서 우리가 Front End 개발을 하기 위해 필수적으로 알아야 하는 것 몇가지만살펴보도록 하겠습니다. 이것정도는 알고 가자  Package Manager : NPM, Yarn외부 라이브러리를 사용할 경우 해당 라이브러리를 설치, 삭제, 의존성 관리등을 해야 하는데 이를 위한 도구가 몇몇 존재합니다. 그중 하나만 하자면 당연 npm입니다. Node Package Manager의 약자이고 Node.js를 살짝 맛보시면npm이 어떻게 동작하는지 아실 수 있습니다. 굳이 Node.js에 대해서 학습할 필요는 없습니다. 당연히 알면 좋지만요.  Transpiler : Babel, TypeScript( 이미지 출처 : http://news.softpedia.com/news )Cross Browsing을 위한 Transpiler입니다. 비교 대상은 아닙니다. 둘 다 알아둘 필요는 있지만 저는 TypeScript는 반드시 해야 한다고 생각합니다. 앞으로 TypeScript는 더 발전할 듯 보이거든요. 하지만 배우기 쉽지 않습니다. 언어적 측면을 파고 들면 내용이 꽤나 많습니다.다행히 TypeScript는 ECMAScript의 superset이니 ECMAScript 공부한다고 생각하시면 속 편합니다.또한 제 개인적인 생각과는 반대로 TypeScript언어의 단점도 분명히 존재합니다. 엄격한 type checking덕분에JavaScript가 가지는 프로그래밍의 유연함이 많이 떨어진다는 것이죠.  자동화 도구 : Grunt, Gulp빌드, 테스트, 배포등을 위한 자동화 도구입니다. 과거에는 Grunt를 많이 사용했지만 현재는 Gulp인듯 합니다. 시간 좀 지나면 Gulp도 Grunt와 마찬가지로 역사속으로 사라지게 되겠지만 지금은 Gulp가 대세입니다.  module bundler : webpack, rollup코드 재사용을 위한 모듈화 도구들과 bundler 역시 여러가지 있는데 요즘 많이 사용하는 건 webpack입니다.ES6 들어오면서 언어적 차원에서 Module을 지원하기 시작했고 이런 Module들을 하나로 모아 Packaing하는 작업이필요하게 되었습니다. 이를 위한 도구 역시 발전을 하고 있구요. 과거에는 Common.js, Require.js를 이용하여처리했다면 최근에는 webpack, rollup을 이용하여 처리합니다.  Framework &amp; Library : Angular, React, Vue.js우리의 목적은 사실 저 위의 3가지를 배우는 것입니다. 각기 나름대로의 장점과 특징들을 가지고 있습니다. 개인적으로는 블로그내에 저 세가지의 강좌를 개설하는게 2018년 상반기의 블로그 목표입니다. 대세는 Angular이지만 React의 성장세역시 가히 폭발적입니다. 아직까지(2018년 1월기준) Vue.js는 Angular와 React 만큼의 성장세는 보이지 않고 있지만 이 역시 어떻게 될지는모를일이죠 정리위에서 “이것정도는 알고가자”라고 했지만 그 내용을 전부 다 알고 있으면 상당한 경험과 실력을 가진Front End 개발자일 것입니다. 또 위에 포함을 안했지만  Git같은 것은 기본적으로 숙지해야 할 것이구요. 할게 너무 많네요천천히 하나씩 해보도록 하죠 머…그리고 “이것정도는 알고가자”에서 제가 강조한 것들은 제가 현재 사용하는 것들입니다.그것들이 더 좋다는 보장은 어디에도 없습니다. 자기 손에 익숙한게 최고입니다. ^^End.",
        "url": "/front-end-ecosystem"
    }
    ,
    
    "jekyll-travis-ci-public": {
        "title": "Jekyll 기반의 GitHub Page 생성(8)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Travis CI 활용(public Repository)CI ( Continuous Integration )의 개념에 대해서 잘 알지 못하시는 분은 여기를 클릭하셔서 간단하게 이해를 하고 오시면 됩니다.이 포스트에서는 Travis CI를 이용하여 Jekyll Source Folder안의 내용을 GitHub Repository에 commit했을 때 자동으로 GitHub Page에 블로그가 deploy되도록 하는 방법에 대해서 알아보겠습니다.일단은 사용하는 GitHub Repository는 모두 Public으로 되어 있다고 가정하고 진행합니다. 만약 Private Repository를 이용하실려면 좀 더 복잡한 처리와 돈이 들어갑니다. (Travis CI는 GitHub Public Repository에 대해서는 무료이지만 Private Repository에 대해서는 일정량의 금액을 지불해야 합니다.)그럼 천천히 한번 진행해 보도록 하죠 GitHub에 2개의 Repository 준비먼저 Jekyll Source Folder ( D:/blogmaker )에 대한 GitHub Repository를 준비합니다. Public으로 생성하셔야 합니다.저는 GitHubPageMaker라는 이름으로 Repository를 생성했습니다. 생성할 때 README.md 파일을 추가해서 생성하지 않습니다.  https://github.com/moon9342/GitHubPageMaker 형태로 생성되겠군요.그 다음은 GitHub Page에서 운영할 블로그에 대한 GitHub Repository를 준비합니다. 역시 마찬가지로 Public으로 생성하셔야 합니다.Repository의 이름은 형식이 정해져 있습니다. {GitHub ID}.github.io 로 Repository를 생성하셔야 합니다. 생성할 때 README.md 파일 하나 추가해서 생성합니다.  https://github.com/moon9342/moon9342.github.io 형태로 생성되겠네요. Local Git Repository 생성 및 Remote 연결GitHub에 원격 Repository가 생성되었으니 이번에는 로컬에 Repository를 생성합니다. D:/blogmaker 폴더에서 command 창을 열고다음을 입력합니다.  git initD:/blogmaker에 git Repository를 생성합니다. 이제 다음의 명령어를 이용해서 로컬 Repository에 파일을 추가하고 commit까지 진행합니다.  git add *  git commit -m “initial commit”자 이제 원격 Repository와 연결하는 작업을 수행합니다. 다음의 명령을 이용합니다.  git remote add origin https://github.com/moon9342/GitHubPageMaker.git현재의 로컬 Repository가 원격 Repository와 연결되었습니다. 연결상태를 확인하려면 다음과 같이입력하면 됩니다.  git remote -v Git Submodule 생성Jekyll Source Folder( D:/blogmaker )에 대한 Repository와 실제 블로그를 운영할 Repository를git submodule로 묶습니다. Submodule의 개념은 여기나 혹은 다른 블로그를 참조하세요.command 창에서 다음과 같이 입력합니다. ( command 창의 현재 경로는 D:/blogmaker 입니다.)  git submodule add https://github.com/moon9342/moon9342.github.io.git output현재 Repository의 하위에 output이라는 이름의 폴더가 만들어지고 해당 폴더는 moon9342.github.io Repository에 대한 로컬 git Repository가 됩니다. ( 내부적으로 git clone이 실행됩니다. )output이라는 이름은 다른 이름으로 변경하셔도 됩니다. 단 _config.yml에 있는 destination 속성의 값과 이 이름이 같아야 합니다.정상적으로 clone이 진행되어서 submodule이 생성되면 다음과 같이 입력합니다.  git submodule updategit은 submodule에 대한 삭제명령을 제공하지 않기 때문에 만약 기존의 submodule을 삭제하려면 다음과 같이 해야 합니다.  Repository 루트에 있는 .gitmodules 파일 수정  Repository 루트의 .git 폴더안의 config 파일 수정 ( [submodule “xxx”] 부분 수정)  git의 cache에서 submodule 삭제 ( git rm --cached module_path ) _config.yml 1차 수정Jekyll Source Folder( D:/blogmaker )에 있는 내용을 컴파일 하면 그 결과가 output 폴더에 들어가도록_config.yml을 수정합니다._config.yml의 destination 부분을 찾아 ./output/으로 수정합니다. Travis 사이트에 접속Travis 사이트에 접속해서 GitHub Repository에 대한 연결을 활성화 시킵니다.기본적으로 Public Repository만 사용할 수 있습니다. 만약 Private Repository를 사용하고 싶으면 별도의 비용을 지불해야 합니다. ( 비용이 좀 비싼편입니다. )  https://travis-ci.org =&gt; Public Repository를 위한 site입니다. GitHub 계정으로 로그인 합니다.  https://travis-ci.com =&gt; Private Repository를 위한 site입니다. GitHub 계정으로 로그인 합니다.그림에서와 같이 연동할 GitHub Repository를 선택해서 Enabled 시켜줍니다.잠깐 정리하자면, 연동된 GitHub Repository인 GitHubPageMaker에 push가 이루어지면 Travis CI가 .travis.yml 설정파일을찾아서 이를 이용해 특정 작업을 수행하게 됩니다. 당연히 GitHubPageMaker Repository에 .travis.yml 파일을 작성해서 넣어 놓아야합니다.우리는 이 .travis.yml과 Rakefile을 이용하여 output안에 있는 내용을 commit하고 push하게 될 것입니다. output은 GitHub Page와 연동되는 Repository이기 때문에 결국 Jekyll로 컴파일한 내용이 GitHub Page Repository로 들어가게 되는 겁니다. Token 생성Travis CI에서 다른 Repository로 push를 하기 위해서는 token이 필요합니다.GitHub에 접속해 Setting &gt; Developer settings &gt; Personal access tokens에 들어가서 Generate New Token을 클릭합니다.적당히 description을 작성하고 Select scopes 중 repo 선택하고 generate token을 클릭하면 새로운 token이 생성됩니다. 이 token을 바로 이용할 건 아니기 때문에 어딘가에 잘 저장해 둡니다.이 token값을 직접 Travis CI 설정파일( .travis.yml )에 직접 노출시키면 안되고 이 값을 암호화해서 사용해야 합니다.일단 command 창을 열어서 travis gem을 설치합니다.  gem install travis설치가 끝나면 다음의 명령을 이용해서 암호화를 진행합니다. 만약 로그인을 안했다는 메시지가 나오면 다음과 같이 로그인 후 진행하시면 됩니다. (ID/PW는 GitHub의 ID/PW를 이용합니다.)  travis login --pro  travis encrypt GITHUB_TOKEN=&lt;token&gt; -r &lt;repo-name&gt;여기서 &lt;token&gt;에는 아까 우리가 획득한 GitHub token을 넣어주시면 됩니다. &lt;repo-name&gt;부분에는 우리의Jekyll Source Folder에 대한 Repository이름을 주면 됩니다. 주의하실점은 {ID/RepoName} 형태로 사용하셔야 합니다. 저의 경우를 예로 들자면 다음과 같습니다.  travis encrypt GITHUB_TOKEN=123abc456xxx -r moon9342/GitHubPageMaker위의 과정을 거치면 암호화된 값을 얻을 수 있는데 이 값을 아래와 같이 .travis.yml안에 설정하시면 됩니다.env:  global:    secure: \"여기에 암호화된 값을 넣습니다.\"branches:  only:    - master 사용되는 파일 수정이제 _config.yml, .travis.yml, Rakefile 파일을 아래와 같이 적절하게 수정해야 합니다. Ruby언어로 작성된 script를 보는게 영 껄끄럽지만 어렵지 않는 내용이니 천천히 보시면 됩니다._config.yml 파일입니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 10# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Blog# 자신의 blog title.description: Development &amp; Technical Training# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: sunghoons-blog# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics:  # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]exclude: [vendor]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source: destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안으로 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.production_url:  https://moon9342.github.io/source_url:  https://github.com/moon9342/GitHubPageMaker/# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules는 포함시키자)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules.travis.yml 파일입니다.sudo: falselanguage: rubycache: bundlerrvm:- 2.4.2install:  # Install Jekyll and dependencies  - bundle installbefore_script:  - git config --global user.email &quot;moon9342@gmail.com&quot;  - git config --global user.name &quot;Moon Sung Hoon&quot;script: bundle exec rake site:deploy --quiet #--trace# Generate your secure token with the travis gem:# get Github token from your Travis CI profile page# gem install travis# GH_TOKEN from https://github.com/settings/tokens# travis encrypt &#39;GIT_NAME=&quot;YOUR_USERNAME&quot; GIT_EMAIL=&quot;YOUR_EMAIL&quot; GH_TOKEN=YOUR_TOKEN&#39;env:  global:    secure: &quot;xxxxxxxxxxxxxxxxxxxx&quot;branches:  only:    - masterRakefile 파일입니다.############################################################################### Modified version of jekyllrb Rakefile# https://github.com/jekyll/jekyll/blob/master/Rakefile##############################################################################require &#39;rake&#39;require &#39;date&#39;require &#39;yaml&#39;CONFIG = YAML.load(File.read(&#39;_config.yml&#39;))USERNAME = CONFIG[&quot;username&quot;]REPO = CONFIG[&quot;repo&quot;]SOURCE_BRANCH = CONFIG[&quot;branch&quot;]DESTINATION_BRANCH = &quot;master&quot;def check_destination  unless Dir.exist? CONFIG[&quot;destination&quot;]    sh &quot;git clone https://$GIT_NAME:$GITHUB_TOKEN@github.com/#{USERNAME}/#{REPO}.git #{CONFIG[&quot;destination&quot;]}&quot;  endendnamespace :site do  desc &quot;Generate the site&quot;  task :build do    check_destination    sh &quot;bundle exec jekyll build&quot;  end  desc &quot;Generate the site and serve locally&quot;  task :serve do    check_destination    sh &quot;bundle exec jekyll serve&quot;  end  desc &quot;Generate the site, serve locally and watch for changes&quot;  task :watch do    sh &quot;bundle exec jekyll serve --watch&quot;  end  desc &quot;Generate the site and push changes to remote origin&quot;  task :deploy do    # Detect pull request    if ENV[&#39;TRAVIS_PULL_REQUEST&#39;].to_s.to_i &gt; 0      puts &#39;Pull request detected. Not proceeding with deploy.&#39;      exit    end    # Configure git if this is run in Travis CI    if ENV[&quot;TRAVIS&quot;]      sh &quot;git config --global user.name $GIT_NAME&quot;      sh &quot;git config --global user.email $GIT_EMAIL&quot;      sh &quot;git config --global push.default simple&quot;    end    # Make sure destination folder exists as git repo    check_destination    sh &quot;git checkout #{SOURCE_BRANCH}&quot;    Dir.chdir(CONFIG[&quot;destination&quot;]) { sh &quot;git checkout #{DESTINATION_BRANCH}&quot; }    # Generate the site    sh &quot;bundle exec jekyll build&quot;    # Commit and push to github    sha = `git log`.match(/[a-z0-9]{40}/)[0]    Dir.chdir(CONFIG[&quot;destination&quot;]) do      # check if there is anything to add and commit, and pushes it      sh &quot;if [ -n &#39;$(git status)&#39; ]; then            git add --all .;            git commit -m &#39;Updating to #{USERNAME}/#{REPO}@#{sha}.&#39;;            git push https://$GITHUB_TOKEN@github.com/#{USERNAME}/#{USERNAME}.github.io.git #{DESTINATION_BRANCH} --quiet ;         fi&quot;      puts &quot;Pushed updated branch #{DESTINATION_BRANCH} to GitHub Pages&quot;    end  endend모든 설정이 끝났습니다. 이제 GitHub에 push작업을 해 보시면 Travis CI가 동작하면서 내부적으로 처리해서 결과를알려줍니다. 해보시면 아시겠지만 거의 스팸메일처럼 날라옵니다.Travis CI 사이트에 들어가면 CI Server가 어떻게 처리하는지를 실시간적으로 log를 출력해 보여주는데 그걸 보시면서 혹 문제가 있는 부분이 있으면 해결하시면 됩니다. Private Repository 사용우리는 두개의 Repository를 사용하고 있고 둘 다 Public으로 사용하고 있습니다. 당연한 말이지만이 중 중요한 것은 여러 설정과 실제 원본내용이 들어있는 Jekyll Source Folder에 대한 Repository인GitHubPageMaker Repository입니다. {GitHub ID}.github.io Repository는 Public으로 설정하고 Jekyll Source Folder는 Private으로 관리하고 싶은 경우는 위의 과정에서 약간만 손보시면 됩니다.  GitHub에서 해당 Repository를 Private으로 설정합니다.  travis-ci.com으로 접속하셔서 Private Repository에 대한 연결을 활성화 시킵니다.  획득한 token을 암호화 시키는 부분에서 다음과 같이 --pro 옵션을 추가합니다.  travis encrypt GITHUB_TOKEN=123abc456xxx -r moon9342/GitHubPageMaker --pro나머지 부분은 동일합니다. Travis CI를 이용할 경우 속도문제Travis CI를 돌려보면 알겠지만 내부적으로 bundle install을 매번 수행합니다. 이 간단한 것 하나 해결하는데2분가량의 시간이 걸리고 대부분의 시간이 설치시간입니다. 이 문제를 해결할 수 있는 방법 역시 있습니다.cache 처리인데요. 이 부분은 나중에 포스팅 할 예정입니다. 문제가 꼬리에 꼬리를 물면서 계속 튕겨 나오네요. 그러면서 배우는 거죠 머 ^^;일단 이런 문제가 있어요~ 라는 문제 제기만 하고 이번 글은 정리하도록 하겠습니다.End.",
        "url": "/jekyll-travis-ci-public"
    }
    ,
    
    "continuous-integration": {
        "title": "What is Continuous Integration?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionCI는 Continuous Integration의 약자로 우리나라 말로 굳이 번역하자면 “지속적인 통합” 정도가 되겠네요.여기서는 간단하게 Continuous Integration이 어떤 개념인지 살펴보도록 하겠습니다. CI(Continuous Integration)란 무엇인가?소프트웨에 개발은 다음과 같은 라이프 사이클을 가지고 있습니다.  계획 =&gt; 요구사항 분석 =&gt; 설계 =&gt; 코드화 =&gt; Build =&gt; Testing =&gt; Release =&gt; Deploywaterfall 방식으로 한 단계가 끝나면 다음 단계로 이동하기도 하지만 일반적으로는 프로젝트가진행되는 동안 이 안의 단계가 반복적으로 실행되게 됩니다.하지만 우리는 코드를 작성한 후 통합 Build작업과 통합 Test작업을 하지 않고 넘어가는 경우가 많습니다. 가장 큰 이유는 Build작업과 Test작업에 시간이 오래 걸리고 만약 중간에 문제가 발생하면 이걸 수정하는게 쉽지 않고 결국 또 시간을 잡아먹게 되기 때문이죠. 심한경우 프로젝트의 중반 이후에 개별적으로 작성한 코드를 통합 build하고 Test하는 경우도 있습니다. 이런 경우 소프트웨어 통합작업은 결국 산으로 올라가게 됩니다.Continuous Integration은 이런 문제점을 해결하기 위해 코드를 최대한 자주 통합하여 개발하는 소프트웨에 개발 방법론중의하나라고 볼 수 있습니다. 이런 CI를 도와주는 여러가지 툴들이 존재하는데 이를 이용하면 통합 시 필요한 여러가지 자잘한(?) 문제들을 자동화시켜서 최대한 빨리 오류를 발견하고 문제를 해결해 나갈 수 있습니다. 결과적으로는 상당히 품질이 좋은 소프트웨어를개발할 수 있게 되는 거지요.그림으로 표현하면 아래와 같이 단순하게 표현할 수 있겠네요.( 이미지 출처 : https://blog.snap-ci.com/categories/continuous-integration )사실 더 복잡하지만 위의 그림처럼 단순하게 바라보시면 될 듯 합니다. CI Server가 통합된 코드를 자동으로 Build-Test-Release-Deploy까지 진행하고 그 결과를 개발자나 다른 관련있는 사람에게 알려주게 됩니다.CI Server가 일련의 과정을 자동으로 처리해 줌으로써 개발자는 Business Logic 작성에 더 집중할 수 있고 오류에 대한 내용도 빨리수정을 할 수 있습니다. 일반적으로 Git과 같은 VCS(Version Control System)과 연계해서 사용하게 됩니다.현재 많이 사용되는 CI 제품들은 다음과 같습니다.      Jenkins : Java로 작성된 open source CI tool입니다. open source CI 진영에서는 압도적 사용자를 보유하고 있습니다. Java 개발자들에겐 진리입니다. 설치형이기 때문에 설정이 조금 복잡합니다.        Travis CI: Github와의 편한 연동 및 public repository에 대해서는 무료로 사용할 수 있다는 장점이 있습니다. 설정이 Jenkins만큼복잡하지 않고 Travis Server를 이용하여 동작시키는 것이기 때문에 편합니다. private repository에 대해서는 일정량의 비용을 지불해야합니다.        TEAMCITY, BAMBOO, GITLAB CI, CIRCLECI, CODESHIP 등등이 있습니다. 이놈들은 저도 써보질 않아서 할말이 없네요.  간단하게 CI의 개념에 대해서만 살펴보았습니다. Travis CI와 같은 것은 사용하기 그리 어렵지 않으니 한번 사용해 보시면 느낌이 확오실겁니다.End.",
        "url": "/continuous-integration"
    }
    ,
    
    "architecture-platform-terminology": {
        "title": "Library, Framework, Architecture, Platform",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionLibrary, Framework, Architecture, Platform은 우리가 너무나 많이 들어본 용어이고 그 의미도 대충 알고 있습니다. 하지만 명확하게 설명해봐!! 라고 한다면 주춤 주춤하게 만드는 용어이기도 합니다.이번 포스트는 저 위에 나열된 4개의 용어에 대한 간략한 정리입니다. Library가장 쉬운 개념입니다. 일반적으로 Library는 다른 프로그램에서 링크 되기 위해 사용되는 하나 이상의 function 혹은 class들의 집합이며 이들은 일반적으로 파일형태로 존재합니다.Library를 사용하는 가장 큰 목적은 코드의 재사용성을 높이기 위함이지요. 자주 사용되는 기능들은 매번 새롭게 작성하지 말고 function이나 class 형태로 만들어 놓고 필요할 때 그 기능을 쉽게 불러다가 사용하자는 개념입니다.      Library의 가장 간단한 예로는 jQuery가 있습니다. Front-End 작업을 할 때 DOM 구조에서 내가 원하는 Element를 빠르고 쉽게 찾아 DOM 에서 제거하고 싶을 때 jQuery Library를 이용하면 단 1줄에 해결할 수 있습니다. 순수 JavaScript로 작업하려면 많은 양의 복잡한 코드를 직접 작성해야 합니다.        Java에서 사용하는 여러 외부 class 역시 모두 Library입니다. Java에서 랜덤값을 얻고싶을 때 우리는 Random class를이용해 instance를 생성하고 method를 호출해서 간단하게 원하는 범위의 랜덤값을 도출할 수 있습니다. 만약 Library를이용하지 않고 랜덤값을 구할려면 역시나 복잡한 로직과 연산을 우리가 직접 구현해야 됩니다.        비슷한 예로 Java에서 JSON 데이터를 처리할 때 역시 특정 Library class를 이용하면 쉽게 처리할 수 있습니다. 가장 대표적인 Library는 Jackson이 아닐까 합니다. 이 Library class들을 이용하면 프로그램에서 JSON 데이터를 아주 쉽게 핸들링 할 수 있습니다.  이렇듯 Library는 프로그램을 작성할 때 필요한 단위 기능을 모아놓은 모듈이라고 볼 수 있습니다. PlatformPlatform은 “Software를 실행시킬 수 있는 실행환경(Runtime Environment)”을 의미합니다.예를 들어 보자면, 우리가 사용하는 모든 OS(Operation System)는 모두 Platform입니다. Windows Platform은windows 응용 프로그램을 실행시키기 위한 실행 환경이고 Linux Platform은 Linux 응용 프로그램을 실행시키기 위한실행 환경이란 말이지요.Java 배울 때 처음에 JVM(Java Virtual Machine)이란 걸 배우게 됩니다. 우리가 작성한 모든 Java 프로그램은 JVM위에서 동작하게 됩니다. 다시 말하면 JVM은 Platform입니다. Java 프로그램을 실행시켜 줄 수 있는 실행 환경이란 말이지요.개념적으로 본다면 우리가 사용하는 Web이라는 서비스 역시 Platform 범주에 들어가게 됩니다. 정확하게는 Web 이라는 서비스가 아닌Web Server와 Web Client(browser)로 구성되는 실행환경이 우리가 작성한 Front-End Web Application이 실행되는 Platform 이라볼 수 있습니다.Java의 예에서 알 수 있듯이 Platform은 Hierarchical 구조를 가질 수 있습니다. 제일 하단에 OS Platform이 있고 그 위에 JVM이실행되는 것이죠. 다시 JVM은 Java 프로그램을 실행시킬 수 있는 Platform이 되고 그 위에 사용자가 작성한 Java 프로그램이실행되는 것입니다. Architecture알고는 있지만 딱히 설명하라면 어버버하게 만드는 개념입니다. Architecture는 소프트웨어의 특징을 결정짓는 설계 구조입니다. 말이 좀 어렵습니다.Architecture는 다음과 같은 내용을 포함합니다.      소프트웨어의 주요 구성 요소에 대한 정의가 포함됩니다. 소프트웨어의 주요 구성 요소란 소프트웨어를 구성하고 있는 컴포넌트 혹은 모듈을 의미합니다. 어떤 기능의 컴포넌트들이 소프트웨어에 필요한지를 구상해서 구성 요소를 정의합니다.( View Component, Service Component, Database Component, Transaction component, Message Component 등등)        이런 소프트웨어 주요 구성 요소들 간에 어떤식의 구성이 이루어지고 있는지 정의합니다. 한 컴포넌트가 다른 컴포넌트와 어떤 관계로 연결되는지에 대한 정의를 지칭한다고 보시면 됩니다. 일반적으로 유지보수성을높이기 위해 Layered Model을 기반으로 컴포넌트간의 연결 관계를 정의합니다.        결국 소프트웨어의 주요 구성 요소들 간에 연관관계가 맺어지는데 이들 간의 상호 인터페이스는 어떻게 할지를 정의합니다. 어떤 값이 넘어가고 이 값을 받아서 결과값으로 어떤 값을 리턴해주는지에 대한 명세를 포함합니다.        소프트웨어의 주요 구성 요소가 하는 중요한 동작 방식을 정의합니다.  위와 같은 내용으로 Architecture를 이해하시면 됩니다. Architecture는 결국 소프트웨어의 주요 특징을 결정하기 때문에 개발에 미치는 영향이 아주 높은 상당히 중요한 부분이라 볼 수 있습니다.Architecture에 대해 한가지 더 기억하셔야 할 점은 Architecture는 구체적인 구현을 포함하지 않습니다. 즉, 어떤 프로그래밍 언어를 사용할 것인지, Library는 어떤것을 사용할 것인지, 개발 지원 프로그램은 어떤것들을 이용할 것인지에 대한 내용은 Architecture에는 포함되지 않습니다. 하지만 특수한 경우 Architecture안에 구체적인 표현이 포함 될 수는 있습니다. 하지만 본질적으로 Architecture는 기술적인 설계를 명시하는 것이지 구체적인 구현 방법은 포함하지 않습니다. FrameworkFramework은 소프트웨어 프로젝트가 개발 될 수 있는 뼈대 구조를 지칭합니다. 역시 말이 좀 어려운데요. 다음과 같은 사항을포함합니다.  소프트웨어 개발시 필요한 지원프로그램  Library (Framework은 Library를 포함하는 상위개념입니다.)  프로그래밍 언어  소프트웨어 구성 요소들을 연결시켜주고 동작시켜주는 소프트웨어(일반적으로 Container라고 합니다.)Framework은 소프트웨어 구성 요소들이 어떻게 동작하는지에 대한 규약이 정해져 있습니다. 이 규약대로프로그램은 진행이 될 것이고 프로그래머는 기능 구현에만 초점을 맞추어 빠르게 개발을 진행 시킬 수 있습니다.Framework 도입의 가장 큰 목적 중 하나는 바로 유지보수입니다. 정해진 규칙대로 프로그램이 동작하고 작성되어야 하다보니다른 사람이 프로그램을 분석하는데 시간이 오래 걸리지 않고 유지보수하는것도 상대적으로 쉽게 진행이 됩니다. Library를기반으로 하는 프로그램은 모든 로직을 개발자가 직접 구현하기 때문에 다른 개발자가 유지보수하기 쉽지 않은 것에 비해Framework은 이런 유지보수 측면에서 강점을 가질 수 있습니다.개발 시 기본 골격이 되는 프로그램 코드가 제공되는것이 일반적인데 이 또한 Framework의 특징이라고 할 수 있습니다.( Scaffolding 이라고 합니다. )Framework부분은 사실 더 써야 하는 사항이 많습니다. 하지만 차이점 위주로 살펴본 것이니 위의 내용 정도만이해해도 충분하지 않을까 합니다.End.",
        "url": "/architecture-platform-terminology"
    }
    ,
    
    "browser-detect-script": {
        "title": "클라이언트 Browser 확인방법",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction사이트에 접속한 Client Web Browser의 종류를 알아내는 방법입니다. Client Browser를 확인하기 위한 JavaScript code제 블로그는 Chrome 전용입니다. IE를 이용하면 화면이 보란듯이 깨지게됩니다. 그래서 접속한 client의 browser를 알아내서 만약 chrome이 아니면 안내를 해 줄 필요가 있습니다.  실제 업무에서는 당연히 cross browsing을 염두에 두고 작업을 해야되겠죠?다음과 같은 JavaScript 코드를 이용하시면 됩니다.var agent = navigator.userAgent.toLowerCase();if (agent.indexOf(\"chrome\") != -1) {        alert(\"Chrome browser\");}if (agent.indexOf(\"safari\") != -1) {        alert(\"Safari browser\");}if (agent.indexOf(\"firefox\") != -1) {    alert(\"FireFox browser\");}JavaScript의 navigator객체를 조사하면 browser의 종류를 판별할 수 있습니다. IE 10까지는 저 위의 방법으로 알아낼 수 있으나 Edge와 그 이후 버전은 이름이 또 바뀌어서 다른 식으로 판단해야 합니다. 전 IE는 관심밖이라… userAgent 객체의 값 확인위의 방법은 가장 간단한 방법 중 하나입니다. Mobile browser까지 생각한다면 경우의 수가 훨씬 더 많아지겠죠.특정 사이트와 Chrome 확장 프로그램을 이용하면 간단하게 어떤 browser로 접속했을 때 userAgent객체에 어떤데이터가 들어가는지 확인해 볼 수 있습니다.그럼 간단히 한번 해 볼까요?먼저 크롬 웹 스토어에 접속해서user-agent switcher로 검색합니다. 확장 프로그램이 검색되는데 다음 그림과 같은 것을 설치합니다. (전 이미 설치되어 있습니다.)확장 프로그램이 설치되면 Chrome browser 우측 상단에 안경 모양의 아이콘이 보이실 겁니다. 그걸 누르면 다른 browser로 switching할 수 있습니다.자 이제 링크로 접속해 보시면 userAgent 객체의 값을보실 수 있습니다. user-agent switcher를 이용하여 다른 browser로 바꾸어서 접속하면 browser마다 userAgent값이 바뀌는 것을확인할 수 있습니다.아래 그림은 iPhone6로 browser를 switch한 후 사이트에 접속한 결과 화면입니다.추가적으로 해당 구현에 대한 소스코드까지 프로그래밍 언어별로 제공하고 있으니 필요하면 다운로드 받아서 사용하면 될 듯 싶습니다.여하간 제 블로그는 Chrome 전용이기 때문에 제가 사용하는 Jasper2 theme의 head.html에 저 위의 코드를적당히 수정해서 이용중입니다. 언제까지 이런 cross browsing issue에 시달려야하는지 안타깝습니다. ㅎㅎEnd.",
        "url": "/browser-detect-script"
    }
    ,
    
    "css-fontawesome-list": {
        "title": "Font Awesome Icon List",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction블로그나 사이트 작성 시 icon 이미지들이 많이 필요하게 되는데 이 아이콘을 마치 폰트처럼 사용할 수 있도록서비스를 제공하는 곳이 있습니다. Font Awesome이라는 곳인데 이 곳에서 제공하는 icon 리스트입니다. Font Awesome블로그나 사이트 작성 시 icon 이미지들이 많이 필요하게 됩니다. 과거에는 이미지를 찾아서 수정해서 쓰는 형식으로이용하였으나 근래에는 icon들을 font와 비슷하게 만들어서 마치 font처럼 icon을 사용할 수 있도록 제공하고 있습니다.이런 icon font는 Vector 이미지이기 때문에 크기에 상관없이 항상 선명한 화질을 보장받을 수 있고 font처럼 사용되다 보니 색상도 자유롭게 변경할 수 있다는 장점이 있습니다.이런 특징을 가지는 icon font를 제공하는 대표적인 사이트 중 하나가 바로 Font Awesome 입니다. Font Awesome의 폰트는 GPL 라이선스입니다. 사용방법자 그럼 우리 블로그에 어떻게 사용하면 되는지 한번 알아보도록 하죠제일 먼저 할일은 제공된 CDN을 이용해 style에 대한 링크를 걸어줍니다. &lt;head&gt; tag안에 명시하면 되겠죠? 제공된 CDN은 다음과 같습니다.&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"&gt;이제 적절한 style을 만들고 우리가 적용할 곳에 해당 style을 설정하면 됩니다. 아래의 style은 Font Awesome을 사용하기 위한 일반적인 예제 style입니다. 적절히 수정해서 사용하시면 됩니다..element {    position: relative;} .element:before {    content: \"\\f000\";    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    text-decoration: inherit;        color: #000;    font-size: 18px;    padding-right: 0.5em;    position: absolute;    top: 10px;    left: 0;} 아이콘 리스트위쪽 css의 content property에 명시하게 될 아이콘의 value값 입니다.만약 태그로 표현하고자 한다면 다음과 같은 형식을 이용합니다.&lt;i class=\"fa fa-glass\"&gt;&lt;/i&gt; fa-glass\"\\f000\" fa-music\"\\f001\" fa-search\"\\f002\" fa-envelope-o\"\\f003\" fa-heart\"\\f004\" fa-star\"\\f005\" fa-star-o\"\\f006\" fa-user\"\\f007\" fa-film\"\\f008\" fa-th-large\"\\f009\" fa-th\"\\f00a\" fa-th-list\"\\f00b\" fa-check\"\\f00c\" fa-times\"\\f00d\" fa-search-plus\"\\f00e\" fa-search-minus\"\\f010\" fa-power-off\"\\f011\" fa-signal\"\\f012\" fa-cog\"\\f013\" fa-trash-o\"\\f014\" fa-home\"\\f015\" fa-file-o\"\\f016\" fa-clock-o\"\\f017\" fa-road\"\\f018\" fa-download\"\\f019\" fa-arrow-circle-o-down\"\\f01a\" fa-arrow-circle-o-up\"\\f01b\" fa-inbox\"\\f01c\" fa-play-circle-o\"\\f01d\" fa-repeat\"\\f01e\" fa-refresh\"\\f021\" fa-list-alt\"\\f022\" fa-lock\"\\f023\" fa-flag\"\\f024\" fa-headphones\"\\f025\" fa-volume-off\"\\f026\" fa-volume-down\"\\f027\" fa-volume-up\"\\f028\" fa-qrcode\"\\f029\" fa-barcode\"\\f02a\" fa-tag\"\\f02b\" fa-tags\"\\f02c\" fa-book\"\\f02d\" fa-bookmark\"\\f02e\" fa-print\"\\f02f\" fa-camera\"\\f030\" fa-font\"\\f031\" fa-bold\"\\f032\" fa-italic\"\\f033\" fa-text-height\"\\f034\" fa-text-width\"\\f035\" fa-align-left\"\\f036\" fa-align-center\"\\f037\" fa-align-right\"\\f038\" fa-align-justify\"\\f039\" fa-list\"\\f03a\" fa-outdent\"\\f03b\" fa-indent\"\\f03c\" fa-video-camera\"\\f03d\" fa-picture-o\"\\f03e\" fa-pencil\"\\f040\" fa-map-marker\"\\f041\" fa-adjust\"\\f042\" fa-tint\"\\f043\" fa-pencil-square-o\"\\f044\" fa-share-square-o\"\\f045\" fa-check-square-o\"\\f046\" fa-arrows\"\\f047\" fa-step-backward\"\\f048\" fa-fast-backward\"\\f049\" fa-backward\"\\f04a\" fa-play\"\\f04b\" fa-pause\"\\f04c\" fa-stop\"\\f04d\" fa-forward\"\\f04e\" fa-fast-forward\"\\f050\" fa-step-forward\"\\f051\" fa-eject\"\\f052\" fa-chevron-left\"\\f053\" fa-chevron-right\"\\f054\" fa-plus-circle\"\\f055\" fa-minus-circle\"\\f056\" fa-times-circle\"\\f057\" fa-check-circle\"\\f058\" fa-question-circle\"\\f059\" fa-info-circle\"\\f05a\" fa-crosshairs\"\\f05b\" fa-times-circle-o\"\\f05c\" fa-check-circle-o\"\\f05d\" fa-ban\"\\f05e\" fa-arrow-left\"\\f060\" fa-arrow-right\"\\f061\" fa-arrow-up\"\\f062\" fa-arrow-down\"\\f063\" fa-share\"\\f064\" fa-expand\"\\f065\" fa-compress\"\\f066\" fa-plus\"\\f067\" fa-minus\"\\f068\" fa-asterisk\"\\f069\" fa-exclamation-circle\"\\f06a\" fa-gift\"\\f06b\" fa-leaf\"\\f06c\" fa-fire\"\\f06d\" fa-eye\"\\f06e\" fa-eye-slash\"\\f070\" fa-exclamation-triangle\"\\f071\" fa-plane\"\\f072\" fa-calendar\"\\f073\" fa-random\"\\f074\" fa-comment\"\\f075\" fa-magnet\"\\f076\" fa-chevron-up\"\\f077\" fa-chevron-down\"\\f078\" fa-retweet\"\\f079\" fa-shopping-cart\"\\f07a\" fa-folder\"\\f07b\" fa-folder-open\"\\f07c\" fa-arrows-v\"\\f07d\" fa-arrows-h\"\\f07e\" fa-bar-chart\"\\f080\" fa-twitter-square\"\\f081\" fa-facebook-square\"\\f082\" fa-camera-retro\"\\f083\" fa-key\"\\f084\" fa-cogs\"\\f085\" fa-comments\"\\f086\" fa-thumbs-o-up\"\\f087\" fa-thumbs-o-down\"\\f088\" fa-star-half\"\\f089\" fa-heart-o\"\\f08a\" fa-sign-out\"\\f08b\" fa-linkedin-square\"\\f08c\" fa-thumb-tack\"\\f08d\" fa-external-link\"\\f08e\" fa-sign-in\"\\f090\" fa-trophy\"\\f091\" fa-github-square\"\\f092\" fa-upload\"\\f093\" fa-lemon-o\"\\f094\" fa-phone\"\\f095\" fa-square-o\"\\f096\" fa-bookmark-o\"\\f097\" fa-phone-square\"\\f098\" fa-twitter\"\\f099\" fa-facebook\"\\f09a\" fa-github\"\\f09b\" fa-unlock\"\\f09c\" fa-credit-card\"\\f09d\" fa-rss\"\\f09e\" fa-hdd-o\"\\f0a0\" fa-bullhorn\"\\f0a1\" fa-bell\"\\f0f3\" fa-certificate\"\\f0a3\" fa-hand-o-right\"\\f0a4\" fa-hand-o-left\"\\f0a5\" fa-hand-o-up\"\\f0a6\" fa-hand-o-down\"\\f0a7\" fa-arrow-circle-left\"\\f0a8\" fa-arrow-circle-right\"\\f0a9\" fa-arrow-circle-up\"\\f0aa\" fa-arrow-circle-down\"\\f0ab\" fa-globe\"\\f0ac\" fa-wrench\"\\f0ad\" fa-tasks\"\\f0ae\" fa-filter\"\\f0b0\" fa-briefcase\"\\f0b1\" fa-arrows-alt\"\\f0b2\" fa-users\"\\f0c0\" fa-link\"\\f0c1\" fa-cloud\"\\f0c2\" fa-flask\"\\f0c3\" fa-scissors\"\\f0c4\" fa-files-o\"\\f0c5\" fa-paperclip\"\\f0c6\" fa-floppy-o\"\\f0c7\" fa-square\"\\f0c8\" fa-bars\"\\f0c9\" fa-list-ul\"\\f0ca\" fa-list-ol\"\\f0cb\" fa-strikethrough\"\\f0cc\" fa-underline\"\\f0cd\" fa-table\"\\f0ce\" fa-magic\"\\f0d0\" fa-truck\"\\f0d1\" fa-pinterest\"\\f0d2\" fa-pinterest-square\"\\f0d3\" fa-google-plus-square\"\\f0d4\" fa-google-plus\"\\f0d5\" fa-money\"\\f0d6\" fa-caret-down\"\\f0d7\" fa-caret-up\"\\f0d8\" fa-caret-left\"\\f0d9\" fa-caret-right\"\\f0da\" fa-columns\"\\f0db\" fa-sort\"\\f0dc\" fa-sort-desc\"\\f0dd\" fa-sort-asc\"\\f0de\" fa-envelope\"\\f0e0\" fa-linkedin\"\\f0e1\" fa-undo\"\\f0e2\" fa-gavel\"\\f0e3\" fa-tachometer\"\\f0e4\" fa-comment-o\"\\f0e5\" fa-comments-o\"\\f0e6\" fa-bolt\"\\f0e7\" fa-sitemap\"\\f0e8\" fa-umbrella\"\\f0e9\" fa-clipboard\"\\f0ea\" fa-lightbulb-o\"\\f0eb\" fa-exchange\"\\f0ec\" fa-cloud-download\"\\f0ed\" fa-cloud-upload\"\\f0ee\" fa-user-md\"\\f0f0\" fa-stethoscope\"\\f0f1\" fa-suitcase\"\\f0f2\" fa-bell-o\"\\f0a2\" fa-coffee\"\\f0f4\" fa-cutlery\"\\f0f5\" fa-file-text-o\"\\f0f6\" fa-building-o\"\\f0f7\" fa-hospital-o\"\\f0f8\" fa-ambulance\"\\f0f9\" fa-medkit\"\\f0fa\" fa-fighter-jet\"\\f0fb\" fa-beer\"\\f0fc\" fa-h-square\"\\f0fd\" fa-plus-square\"\\f0fe\" fa-angle-double-left\"\\f100\" fa-angle-double-right\"\\f101\" fa-angle-double-up\"\\f102\" fa-angle-double-down\"\\f103\" fa-angle-left\"\\f104\" fa-angle-right\"\\f105\" fa-angle-up\"\\f106\" fa-angle-down\"\\f107\" fa-desktop\"\\f108\" fa-laptop\"\\f109\" fa-tablet\"\\f10a\" fa-mobile\"\\f10b\" fa-circle-o\"\\f10c\" fa-quote-left\"\\f10d\" fa-quote-right\"\\f10e\" fa-spinner\"\\f110\" fa-circle\"\\f111\" fa-reply\"\\f112\" fa-github-alt\"\\f113\" fa-folder-o\"\\f114\" fa-folder-open-o\"\\f115\" fa-smile-o\"\\f118\" fa-frown-o\"\\f119\" fa-meh-o\"\\f11a\" fa-gamepad\"\\f11b\" fa-keyboard-o\"\\f11c\" fa-flag-o\"\\f11d\" fa-flag-checkered\"\\f11e\" fa-terminal\"\\f120\" fa-code\"\\f121\" fa-reply-all\"\\f122\" fa-star-half-o\"\\f123\" fa-location-arrow\"\\f124\" fa-crop\"\\f125\" fa-code-fork\"\\f126\" fa-chain-broken\"\\f127\" fa-question\"\\f128\" fa-info\"\\f129\" fa-exclamation\"\\f12a\" fa-superscript\"\\f12b\" fa-subscript\"\\f12c\" fa-eraser\"\\f12d\" fa-puzzle-piece\"\\f12e\" fa-microphone\"\\f130\" fa-microphone-slash\"\\f131\" fa-shield\"\\f132\" fa-calendar-o\"\\f133\" fa-fire-extinguisher\"\\f134\" fa-rocket\"\\f135\" fa-maxcdn\"\\f136\" fa-chevron-circle-left\"\\f137\" fa-chevron-circle-right\"\\f138\" fa-chevron-circle-up\"\\f139\" fa-chevron-circle-down\"\\f13a\" fa-html5\"\\f13b\" fa-css3\"\\f13c\" fa-anchor\"\\f13d\" fa-unlock-alt\"\\f13e\" fa-bullseye\"\\f140\" fa-ellipsis-h\"\\f141\" fa-ellipsis-v\"\\f142\" fa-rss-square\"\\f143\" fa-play-circle\"\\f144\" fa-ticket\"\\f145\" fa-minus-square\"\\f146\" fa-minus-square-o\"\\f147\" fa-level-up\"\\f148\" fa-level-down\"\\f149\" fa-check-square\"\\f14a\" fa-pencil-square\"\\f14b\" fa-external-link-square\"\\f14c\" fa-share-square\"\\f14d\" fa-compass\"\\f14e\" fa-caret-square-o-down\"\\f150\" fa-caret-square-o-up\"\\f151\" fa-caret-square-o-right\"\\f152\" fa-eur\"\\f153\" fa-gbp\"\\f154\" fa-usd\"\\f155\" fa-inr\"\\f156\" fa-jpy\"\\f157\" fa-rub\"\\f158\" fa-krw\"\\f159\" fa-btc\"\\f15a\" fa-file\"\\f15b\" fa-file-text\"\\f15c\" fa-sort-alpha-asc\"\\f15d\" fa-sort-alpha-desc\"\\f15e\" fa-sort-amount-asc\"\\f160\" fa-sort-amount-desc\"\\f161\" fa-sort-numeric-asc\"\\f162\" fa-sort-numeric-desc\"\\f163\" fa-thumbs-up\"\\f164\" fa-thumbs-down\"\\f165\" fa-youtube-square\"\\f166\" fa-youtube\"\\f167\" fa-xing\"\\f168\" fa-xing-square\"\\f169\" fa-youtube-play\"\\f16a\" fa-dropbox\"\\f16b\" fa-stack-overflow\"\\f16c\" fa-instagram\"\\f16d\" fa-flickr\"\\f16e\" fa-adn\"\\f170\" fa-bitbucket\"\\f171\" fa-bitbucket-square\"\\f172\" fa-tumblr\"\\f173\" fa-tumblr-square\"\\f174\" fa-long-arrow-down\"\\f175\" fa-long-arrow-up\"\\f176\" fa-long-arrow-left\"\\f177\" fa-long-arrow-right\"\\f178\" fa-apple\"\\f179\" fa-windows\"\\f17a\" fa-android\"\\f17b\" fa-linux\"\\f17c\" fa-dribbble\"\\f17d\" fa-skype\"\\f17e\" fa-foursquare\"\\f180\" fa-trello\"\\f181\" fa-female\"\\f182\" fa-male\"\\f183\" fa-gratipay\"\\f184\" fa-sun-o\"\\f185\" fa-moon-o\"\\f186\" fa-archive\"\\f187\" fa-bug\"\\f188\" fa-vk\"\\f189\" fa-weibo\"\\f18a\" fa-renren\"\\f18b\" fa-pagelines\"\\f18c\" fa-stack-exchange\"\\f18d\" fa-arrow-circle-o-right\"\\f18e\" fa-arrow-circle-o-left\"\\f190\" fa-caret-square-o-left\"\\f191\" fa-dot-circle-o\"\\f192\" fa-wheelchair\"\\f193\" fa-vimeo-square\"\\f194\" fa-try\"\\f195\" fa-plus-square-o\"\\f196\" fa-space-shuttle\"\\f197\" fa-slack\"\\f198\" fa-envelope-square\"\\f199\" fa-wordpress\"\\f19a\" fa-openid\"\\f19b\" fa-university\"\\f19c\" fa-graduation-cap\"\\f19d\" fa-yahoo\"\\f19e\" fa-google\"\\f1a0\" fa-reddit\"\\f1a1\" fa-reddit-square\"\\f1a2\" fa-stumbleupon-circle\"\\f1a3\" fa-stumbleupon\"\\f1a4\" fa-delicious\"\\f1a5\" fa-digg\"\\f1a6\" fa-pied-piper\"\\f1a7\" fa-pied-piper-alt\"\\f1a8\" fa-drupal\"\\f1a9\" fa-joomla\"\\f1aa\" fa-language\"\\f1ab\" fa-fax\"\\f1ac\" fa-building\"\\f1ad\" fa-child\"\\f1ae\" fa-paw\"\\f1b0\" fa-spoon\"\\f1b1\" fa-cube\"\\f1b2\" fa-cubes\"\\f1b3\" fa-behance\"\\f1b4\" fa-behance-square\"\\f1b5\" fa-steam\"\\f1b6\" fa-steam-square\"\\f1b7\" fa-recycle\"\\f1b8\" fa-car\"\\f1b9\" fa-taxi\"\\f1ba\" fa-tree\"\\f1bb\" fa-spotify\"\\f1bc\" fa-deviantart\"\\f1bd\" fa-soundcloud\"\\f1be\" fa-database\"\\f1c0\" fa-file-pdf-o\"\\f1c1\" fa-file-word-o\"\\f1c2\" fa-file-excel-o\"\\f1c3\" fa-file-powerpoint-o\"\\f1c4\" fa-file-image-o\"\\f1c5\" fa-file-archive-o\"\\f1c6\" fa-file-audio-o\"\\f1c7\" fa-file-video-o\"\\f1c8\" fa-file-code-o\"\\f1c9\" fa-vine\"\\f1ca\" fa-codepen\"\\f1cb\" fa-jsfiddle\"\\f1cc\" fa-life-ring\"\\f1cd\" fa-circle-o-notch\"\\f1ce\" fa-rebel\"\\f1d0\" fa-empire\"\\f1d1\" fa-git-square\"\\f1d2\" fa-git\"\\f1d3\" fa-hacker-news\"\\f1d4\" fa-tencent-weibo\"\\f1d5\" fa-qq\"\\f1d6\" fa-weixin\"\\f1d7\" fa-paper-plane\"\\f1d8\" fa-paper-plane-o\"\\f1d9\" fa-history\"\\f1da\" fa-circle-thin\"\\f1db\" fa-header\"\\f1dc\" fa-paragraph\"\\f1dd\" fa-sliders\"\\f1de\" fa-share-alt\"\\f1e0\" fa-share-alt-square\"\\f1e1\" fa-bomb\"\\f1e2\" fa-futbol-o\"\\f1e3\" fa-tty\"\\f1e4\" fa-binoculars\"\\f1e5\" fa-plug\"\\f1e6\" fa-slideshare\"\\f1e7\" fa-twitch\"\\f1e8\" fa-yelp\"\\f1e9\" fa-newspaper-o\"\\f1ea\" fa-wifi\"\\f1eb\" fa-calculator\"\\f1ec\" fa-paypal\"\\f1ed\" fa-google-wallet\"\\f1ee\" fa-cc-visa\"\\f1f0\" fa-cc-mastercard\"\\f1f1\" fa-cc-discover\"\\f1f2\" fa-cc-amex\"\\f1f3\" fa-cc-paypal\"\\f1f4\" fa-cc-stripe\"\\f1f5\" fa-bell-slash\"\\f1f6\" fa-bell-slash-o\"\\f1f7\" fa-trash\"\\f1f8\" fa-copyright\"\\f1f9\" fa-at\"\\f1fa\" fa-eyedropper\"\\f1fb\" fa-paint-brush\"\\f1fc\" fa-birthday-cake\"\\f1fd\" fa-area-chart\"\\f1fe\" fa-pie-chart\"\\f200\" fa-line-chart\"\\f201\" fa-lastfm\"\\f202\" fa-lastfm-square\"\\f203\" fa-toggle-off\"\\f204\" fa-toggle-on\"\\f205\" fa-bicycle\"\\f206\" fa-bus\"\\f207\" fa-ioxhost\"\\f208\" fa-angellist\"\\f209\" fa-cc\"\\f20a\" fa-ils\"\\f20b\" fa-meanpath\"\\f20c\" fa-buysellads\"\\f20d\" fa-connectdevelop\"\\f20e\" fa-dashcube\"\\f210\" fa-forumbee\"\\f211\" fa-leanpub\"\\f212\" fa-sellsy\"\\f213\" fa-shirtsinbulk\"\\f214\" fa-simplybuilt\"\\f215\" fa-skyatlas\"\\f216\" fa-cart-plus\"\\f217\" fa-cart-arrow-down\"\\f218\" fa-diamond\"\\f219\" fa-ship\"\\f21a\" fa-user-secret\"\\f21b\" fa-motorcycle\"\\f21c\" fa-street-view\"\\f21d\" fa-heartbeat\"\\f21e\" fa-venus\"\\f221\" fa-mars\"\\f222\" fa-mercury\"\\f223\" fa-transgender\"\\f224\" fa-transgender-alt\"\\f225\" fa-venus-double\"\\f226\" fa-mars-double\"\\f227\" fa-venus-mars\"\\f228\" fa-mars-stroke\"\\f229\" fa-mars-stroke-v\"\\f22a\" fa-mars-stroke-h\"\\f22b\" fa-neuter\"\\f22c\" fa-genderless\"\\f22d\" fa-facebook-official\"\\f230\" fa-pinterest-p\"\\f231\" fa-whatsapp\"\\f232\" fa-server\"\\f233\" fa-user-plus\"\\f234\" fa-user-times\"\\f235\" fa-bed\"\\f236\" fa-viacoin\"\\f237\" fa-train\"\\f238\" fa-subway\"\\f239\" fa-medium\"\\f23a\" fa-y-combinator\"\\f23b\" fa-optin-monster\"\\f23c\" fa-opencart\"\\f23d\" fa-expeditedssl\"\\f23e\" fa-battery-full\"\\f240\" fa-battery-three-quarters\"\\f241\" fa-battery-half\"\\f242\" fa-battery-quarter\"\\f243\" fa-battery-empty\"\\f244\" fa-mouse-pointer\"\\f245\" fa-i-cursor\"\\f246\" fa-object-group\"\\f247\" fa-object-ungroup\"\\f248\" fa-sticky-note\"\\f249\" fa-sticky-note-o\"\\f24a\" fa-cc-jcb\"\\f24b\" fa-cc-diners-club\"\\f24c\" fa-clone\"\\f24d\" fa-balance-scale\"\\f24e\" fa-hourglass-o\"\\f250\" fa-hourglass-start\"\\f251\" fa-hourglass-half\"\\f252\" fa-hourglass-end\"\\f253\" fa-hourglass\"\\f254\" fa-hand-rock-o\"\\f255\" fa-hand-paper-o\"\\f256\" fa-hand-scissors-o\"\\f257\" fa-hand-lizard-o\"\\f258\" fa-hand-spock-o\"\\f259\" fa-hand-pointer-o\"\\f25a\" fa-hand-peace-o\"\\f25b\" fa-trademark\"\\f25c\" fa-registered\"\\f25d\" fa-creative-commons\"\\f25e\" fa-gg\"\\f260\" fa-gg-circle\"\\f261\" fa-tripadvisor\"\\f262\" fa-odnoklassniki\"\\f263\" fa-odnoklassniki-square\"\\f264\" fa-get-pocket\"\\f265\" fa-wikipedia-w\"\\f266\" fa-safari\"\\f267\" fa-chrome\"\\f268\" fa-firefox\"\\f269\" fa-opera\"\\f26a\" fa-internet-explorer\"\\f26b\" fa-television\"\\f26c\" fa-contao\"\\f26d\" fa-500px\"\\f26e\" fa-amazon\"\\f270\" fa-calendar-plus-o\"\\f271\" fa-calendar-minus-o\"\\f272\" fa-calendar-times-o\"\\f273\" fa-calendar-check-o\"\\f274\" fa-industry\"\\f275\" fa-map-pin\"\\f276\" fa-map-signs\"\\f277\" fa-map-o\"\\f278\" fa-map\"\\f279\" fa-commenting\"\\f27a\" fa-commenting-o\"\\f27b\" fa-houzz\"\\f27c\" fa-vimeo\"\\f27d\" fa-black-tie\"\\f27e\" fa-fonticons\"\\f280\"",
        "url": "/css-fontawesome-list"
    }
    ,
    
    "jekyll-gist": {
        "title": "Jekyll 기반의 GitHub Page 생성(7)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 GitHub Gist 활용GitHub의 Gist에 대해서 잘 알지 못하시는 분은 여기를 클릭하셔서 간단하게 Gist에 대한 이해를 하고 오시면 됩니다.그럼 설치부터 천천히 알아보도록 하죠.먼저 gist를 사용할 수 있도록 gem을 설치해야 합니다. 아래와 같이 command 창에서 명령어를 입력합니다.  gem install jekyll-gistgem 설치가 끝나면 _config.yml을 수정해야 합니다.아래의 코드는 저의 _config.yml입니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 10# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Blog# 자신의 blog title.description: Development &amp; Technical Training# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: sunghoons-blog# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics:  # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]exclude: [vendor]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source: destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안으로 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.production_url:  https://moon9342.github.io/source_url:  https://github.com/moon9342/GitHubPageMaker/# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules는 포함시키자)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules위의 코드는 gist를 이용하여 불러온 코드입니다.중간쯤에plugins: [jekyll-paginate, jekyll-feed, jekyll-gist]부분처럼 설치한 jekyll-gist를추가시킵니다.그리고 포스트를 하나 생성해서 다음과 같은 구문을 이용하여 gist를 불러오면 됩니다.gist를 불러올 때 JavaScript 링크를 붙였넣는것이 아닙니다. 만약 불러올 링크가 아래와 같으면&lt;script src=\"https://gist.github.com/moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e.js\"&gt;&lt;/script&gt;여기에서moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e부분만 이용합니다. 즉, 아래와 같이 불러오시면 됩니다.{% gist moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e %} 오류 해결한방에 된다면 좋겠지만 잘 안될 수 있습니다.가장 많이 나는 오류는 SSL_connect 오류입니다. Windows 10 사용자들은 다음과 같은 오류가 높은 확률로 발생합니다.  SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed에러 메시지를 보니 그냥 해결할 수 있는 종류가 아닌 듯 보입니다. Stack Overflow 사이트에서 찾아보면 몇가지 해결 방안을 발견할 수 있습니다.command 창을 열고 다음과 같이 하나하나 실행 하시면 됩니다.  gem update --system  gem install rubygems-update  update_rubygems위의 과정은 RubyGem을 최신으로 upgrade 시키는 작업입니다.그런 다음 링크를 클릭해서 파일 하나를 다운로드 받습니다. 이 파일은 .pem 파일로 certificate 역할을 하는 파일입니다.파일을 다운로드해서 적절한 위치에 복사합니다. (원하는 폴더에 저장해놓으면 됩니다.)저는 D:/myRuby 폴더를 생성하고 이 안에 해당 파일을 복사해 넣었습니다. 파일이름은 cacert.pem이라고 했습니다.이제 시스템 환경변수를 하나 생성합니다. 환경변수 이름은 SSL_CERT_FILE로 하셔야 하며 환경변수의 값으로파일에 대한 절대경로를 넣어줍니다. 저같은 경우는 D:/myRuby/cacert.pem로 설정해야 겠네요.여기까지 진행했으면 command 창을 다시 열어서(환경변수가 변경되었으니 다시 열어야죠!) 블로그를 다시 build 하시면 됩니다.SSL_connect 문제에 대한 보다 자세한 설명은 링크에서 확인하실 수 있습니다.위와 같이 해서 Code Snippet을 원하는 곳에 붙여 사용할 수 있습니다. gist에서 제공하는default theme가 맘에 안드시면 다음의 CUSTOMIZING GITHUB GISTS를 방문해 보세요. 조금만 살펴보시면 원하는 style로 gist를 사용하실 수 있습니다.End.",
        "url": "/jekyll-gist"
    }
    ,
    
    "github-gist": {
        "title": "What is GitHub Gist?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionCode Snippet을 관리하기 위한 도구입니다. 블로그로 IT 관련 포스팅을 하는 사람들에게는 굉장히 유용한 도구로사용이 됩니다. Gist는 우리나라말로 “지스트”라고 발음하며 GitHub에서 서비스 하고 있습니다.만일 Gist에 대해서는 알고 있고 jekyll기반의 GitHub Page에서 사용하는 방법에 대해서 알고 싶으신 분은 여기를 참조하세요! Code Snippet 관리IT 개발관련 블로그를 운영하다보면 여러 코드조각들을 블로그에 같이 올리게됩니다. 어떤 경우는 말 그대로 완성되지 않은“코드조각” 형태의 코드를 올리기도 하고 어떤 경우는 완성된 형태의 코드를 올리기도 합니다.텍스트 형태로 그냥 포스팅을 하면 보기가 너무 좋지 않으니 일반적으로 Syntax Highlighter를 많이 이용하게 됩니다. 다양한 종류의 Syntax Highlighter가 있고 이를 이용하면 보기 좋게 코드들을 블로그에 올릴 수 있습니다.설명을 하기 위한 코드조각들은 일반적으로 수정이나 공유의 빈도가 상대적으로 적기 때문에 그냥 Rouge와 같은Syntax Highlighter를 이용하여 올리면 편합니다. 하지만 완성된 코드를 포스팅하는 경우 추후에 기능의 보완이라든지오류에 대한 수정같은 이슈가 생길 수 있고 이렇게 변경된 코드는 다른 사람과 공유할 때 문제가 발생할 수 밖에 없습니다.하나의 완성된 코드를 블로그 여기저기에서 가져다가 쓰는 경우 역시 마찬가지의 이슈가 발생할 수 있겠죠.결국 “YouTube에 동영상을 올리고 블로그에 삽입하는 것처럼 이런 코드조각들도 그렇게 관리하고 공유하면 편하겠다” 라고 사람들이 생각하게 되고 이를 위한 온라인 서비스도 여러 개 생기게 되었는데 그 중 하나가 GitHub에서 제공하는 Gist입니다.결론적으로 Gist는 Code Snippet을 관리하고 공유하도록 도와주는 서비스라고 생각하시면 됩니다. 사용방법사용방법은 상당히 간단합니다. 일단 GitHub에 로그인해서 노란색 영역을 클릭하시면다음과 같은 화면을 보실 수 있습니다.New gist 메뉴를 선택하면 Code Snippet을 생성할 수 있는 화면으로 전환됩니다.코드 내용을 입력하고 public 혹은 secret 형태로 gist를 생성합니다.생성이 되면 아마 다음과 같은 화면을 보실 수 있을텐데 이렇게 작성된 gist를 블로그에올리려면 Embed라고 되어있는 JavaScript link code를 가져다가 블로그에 삽입하면 됩니다.실제로 한번 작업해 보시면 자신이 작성한 Code Snippet을 블로그에 쉽게 포함 시킬 수있으실 겁니다.저는 Jekyll기반의 GitHub Page에서 블로그를 운영하고 있기 때문에 조금 다른 방식을 이용합니다.Liquid template을 이용해서 블로그에 포함시키는 방법을 이용합니다.이 방식에 대해서는 여기를 참조하세요!End.",
        "url": "/github-gist"
    }
    ,
    
    "i18n-l10n": {
        "title": "What is i18n, l10n?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction국제화와 지역화 작업을 의미하는 i18n과 l10n에 대해서 알아보도록 하겠습니다. i18n, l10ni18n은 internationalization(국제화)를 표현한 것입니다. 첫글자인 i와 마지막 글자인 n사이에 18개의 글자가 있다고해서 저렇게 표현한 겁니다. 아마 IT쪽에 관심이 있는 사람이라면 i18n이 어떤 약자인지는 몰랐어도 국제화라는걸 알고는 있었으리라생각됩니다.l10n역시 마찬가지로 localization(현지화)를 표현한 것입니다. 첫글자인 l과 마지막 글자인 n사이에 10개의 글자가 있다라는 것이겠죠?일반적으로 우리가 작성한 프로그램을 다른 언어로 출시할때는 당연히 해당 언어로 현지화를 진행해야 합니다. 내용의 번역부터 시작해서각종 단위(통화단위, 도량형 단위, 숫자의 표현, 날짜표현 양식 등)의 변환등을 의미하겠죠. 하지만 현지화의 가장 중요한 점은 타겟문화에 맞도록 컨텐츠를 조절하는 것입니다. 이게 힘든 작업이죠. 개발자에게 맡기면 산으로 갑니다. (^^)여하간 이런 현지화를 다른 여러 타겟(여러 나라)를 대상으로 우리의 프로그램을 조정하는 작업이 바로 i18n support라고 불리는 국제화작업이라고 보시면 될 듯 합니다.그냥 그렇다구요.i18n 작업을 할 때 주의해야 할 점에 대해서는 다른 훌륭한 포스트들을 참조해주세요~ 사실 저도작업 경험이 딱 한번 있습니다. (하고 싶지 않아요.. 할 생각도 없구요)End.",
        "url": "/i18n-l10n"
    }
    ,
    
    "typescript-interface": {
        "title": "TypeScript 강좌(6) - Interface",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Interfaceinterface는 우리가 알고 있는 Java의 interface와 문법적으로 유사합니다. 하지만 객체지향에서 말하는 interface와는의미적으로 좀 차이가 있습니다. 그 부분은 예제 중간중간에 살펴보기로 하고 지금은 TypeScript의 interface 에 대해서만 살펴보도록 하겠습니다.TypeScript에서 interface는 새로운 데이터 타입을 만드는 추상 데이터 타입(abstract data type)으로 사용이 되며일반 변수, 함수, 클래스의 type check를 위해 사용됩니다. interface 이용하여 타입을 선언하면 interface안에 명시된 property의 선언과 method의 구현이 강제되기 때문에 프로그래밍의 일관성을 확보할 수 있습니다.참고로 ES6는 interface를 지원하지 않습니다. TypeScript만 지원합니다. 그렇기 때문에 interface를 컴파일 한 결과물을 보면 interface의 내용은 나타나지 않게됩니다. Basic Exam그럼 간단한 예를 통해 알아보도록 하겠습니다.interface IBook {    bookName: string;    bookAuthor: string;}let myBook: IBook;myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};console.log(myBook);해당 .ts 파일을 컴파일 한 결과 .js 파일을 살펴보면 다음과 같습니다.\"use strict\";var myBook;myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};console.log(myBook);위에서 언급한 대로 interface에 대한 내용은 포함되어 있지 않습니다. TypeScript의 interface는 type check를 위한용도로 사용되게 됩니다. Parameter Type Check비슷한 용도로 함수의 인자를 넘길 때 인자의 type으로 interface를 이용할 수 있습니다. 아래의 예를 한번 살펴보죠.interface IBook {    bookName: string;    bookAuthor: string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);}let myBook: IBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};printBookInfo(myBook);굳이 설명할 것도 없는거 같습니다. printBookInfo()의 인자로 interface type의 객체가 전달되어사용된 것이죠.여기까지는 별 문제 없이 이해할 수 있습니다. 이제 그 다음이 살짝 이상합니다. Duck Typing아래의 코드에서 문법 오류가 일어날까요?interface IBook {    bookName: string;    bookAuthor: string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);}let myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\",    bookPrice: 3000};printBookInfo(myBook);원래 예상대로라면 이 코드는 문제가 있는 것이 맞습니다. myBook이라는 객체는 IBook interface type으로 지정되지 않고 parameter로 전달이 되었거든요. 하지만 이 코드는 에러없이 컴파일이 진행됩니다.왜 이런 현상이 발생할까요?TypeScript의 중요한 원칙 중 하나는 가지고 있는 값들의 형태를 가지고 type-checking을 수행한다는 것입니다. 말이 좀 어렵네요. 풀어서 설명하자면 TypeScript에서 type-checking은 선언된 타입만을 비교하는것이 아니라 실제 이용될 수 있는 형태의 값들을 가지고 있느냐 그렇지 않느냐를 가지고 한다는 의미입니다.위의 예제에서 myBook 객체는 비록 IBook interface type은 아니지만 IBook interface type을 모두 커버할 수 있는 값들의 형태를가지고 있습니다. 이런 경우 myBook 객체는 IBook interface 타입으로 간주한다는 말이지요.이런걸 동적 typing의 한 종류인 duck typing이라고 합니다. TypeScript는 duck typing을 지원하는 언어입니다. 일반적으로말하자면 class의 상속이나 interface의 구현으로 타입을 구분하는 것이 아니라 객체가 특정 타입에 걸맞는 property와 method를 가지고 있으면 해당 type으로 간주한다는 의미로 받아들이시면 됩니다.해서 저 위의 코드는 에러없이 사용할 수 있습니다. Optional PropertiesTypeScript interface의 모든 property와 method는 구현하는 클래스 혹은 구현 객체에서 기본적으로 모두 재정의되어야 합니다. 하지만 Optional Property( property 중 ? 가 붙어있는 property를 의미합니다. )를 이용하면 해당 property는 재정의하지 않아도 상관없습니다. 즉, 선택적으로 구현여부를 결정할 수 있는 property가 optional property입니다.아래의 예를 가지고 살펴보겠습니다.interface IBook {    bookName: string;    bookAuthor: string;    bookISBN?: string;   // Optional Property    getName(): string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);    console.log(paramBook.getName());}let myBook: IBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\",    getName: function() {       return this.bookName;    }};printBookInfo(myBook); Readonly Propertiesreadonly keyword를 이용해 객체가 처음 생성되는 시점에만 property들을 수정가능하도록 설정할 수 있습니다.한번 값이 세팅되면 그 후에는 수정할 수 없게됩니다.interface Point {    readonly x: number;    y: number;}let p1: Point = { x: 10, y: 20 };p1.x = 100;    // 오류 발생TypeScript는 또 ReadonlyArray&lt;T&gt; 형태의 Array를 지원합니다. 이름에서 의미하는 것처럼 생성된 후에는Array를 변경할 수 없습니다.let arr: number[] = [1, 2, 3, 4];let roArray: ReadonlyArray&lt;number&gt; = arr;roArray[0] = 100;   // 코드 에러roArray.push(100);  // 코드 에러arr = roArray;             // 코드 에러arr = roArray as number[]; // 가능위의 코드도 쉽게 이해할 수 있습니다. 마지막 코드 정도만 주의하면 될 듯 합니다.이렇게 readonly property는 const와 비슷한 역할을 하게됩니다. 단 const는 변수의 선언에사용되며 readonly는 property 지정에 사용된다는 점만 기억하시면 됩니다. Function Typesinterface는 function의 type을 지정하는데 사용할 수 있습니다. 이 경우 parameter의 리스트와리턴타입만을 가지고 있는 함수의 선언과 비슷한 형태를 가지게 됩니다. 아래의 예를 보죠.interface myInterface {    (myName: string, myAge: number): void;}let myFunc: myInterface = function(myName:string, myAge:number): void {    console.log(`이름 : ${myName}, 나이 : ${myAge}`);};myFunc(\"홍길동\",30); Indexable TypesJavaScript의 객체를 사용하기 위해서는 일반적으로 \".\" operator를 이용합니다. 일반적인 객체지향언어에서객체를 사용하는 방식이죠. JavaScript는 추가적으로 객체를 사용하는 방법으로 배열방식을 이용할 수 있습니다.다음과 같이 사용합니다.아래의 코드는 JavaScript 코드입니다.let obj = {    myName: '홍길동',    myAddress: '서울'};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}위의 코드는 문법에러가 발생하지 않고 결과도 잘 출력이 됩니다. obj 객체에 접근할 때[ ] 형태를 이용해서 key값에 접근해서 value값을 출력하는 간단한 예제입니다.하지만 이 코드를 TypeScript로 작성하면 코드에러가 발생합니다. 해당 파일에 대한 확장자만.js에서 .ts로 변경해보면 obj[keys[i]에서 다음과 같은 에러가 발생하는 것을 볼 수 있습니다.Element implicitly has an 'any' type because type '{ myName: string; myAddress: string; }' has no index signature.쉽게 말하면 index signature를 이용하지 않았기 때문에 property에 접근할 때 어떤 타입인지를 확인할 수 없어서 묵시적으로 any 타입을 이용하게 된다는 의미입니다. 하지만 우리는 TypeScriptcompiler 옵션 중 noImplicitAny 속성을 true로 해 놓았기 때문에 문제가 발생하는 것입니다.(noImplicitAny: true가 default로 설정됩니다.)해결하기 위해서는 컴파일러 옵션을 수정하던지 아니면 interface를 이용하여 index signature를 설정해 type을명시적으로 알려주면 됩니다.컴파일러 옵션을 수정하는 방법은 tsconfig.json 설정에서 \"noImplicitAny\": false 옵션을 추가하시면 됩니다. 하지만 좋지 않습니다. any 타입은 특별한 이유가 있지 않는 한 가능한 사용하지 않는게 좋고 명시적으로 타입을 지정해서 사용하셔야 합니다.좀 더 좋은 해결책은 interface로 index signature를 설정해서 사용하는 것입니다. 이걸 Indexable Type이라고 합니다.아래의 코드처럼 interface를 이용해 index signature를 설정합니다.interface IObj {    [idx: string]: string;}let obj: IObj = {    myName: '홍길동',    myAddress: '서울'};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}추가적으로 union type을 이용한 다음의 코드도 살펴보시면 됩니다.interface IObj {    [idx: string]: string | number;    [index: number]: string | number;    myName: string;    myAddress: string;    myAge: number}let obj: IObj = {    myName: '홍길동',    myAddress: '서울',    myAge: 30};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}마지막으로 앞에서 나온 readonly property를 이용하면 ReadonlyArray처럼 사용할 수 있습니다.interface ReadonlyStringArray {    readonly [index: number]: string;}let myArr: ReadonlyStringArray = [\"홍길동\", \"강감찬\"];myArr[2] = \"이순신\"; // 코드 오류( readonly ) Class Typesinterface의 가장 일반적인 사용법은 Java나 C#언어처럼 class의 구현을 명시적으로 강제하는 것입니다.아직 class에 대해서는 배우지 않았지만 Java같은 객체지향 언어를 해 보신 분이라면 쉽게 이해하실거라 생각됩니다.interface IPerson {    [idx: string]: string | number | Function;    myName: string;    myAddress: string;    myAge: number;    printInfo(obj:IPerson): void;}class Person implements IPerson {    [index: string]: string | number | Function;    myName: string;    myAddress: string;    myAge: number;    constructor(name:string, address:string, age:number) {        this.myName = name;        this.myAddress = address;        this.myAge = age;    }        printInfo(obj: IPerson): void {        Object.keys(obj).forEach(t =&gt; console.log(obj[t]));    }}const obj = new Person(\"홍길동\", \"서울\", 30);obj.printInfo(obj);위와 같은 일반적인 경우가 사실은 대부분입니다. ^^; 여기에 추가적인 몇가지만 살펴보겠습니다. 이전 강좌에서 일급함수(first class function)개념에 대해서 언급했었는데기억하시나요? 한마디로 요약하자면 “JavaScript는 함수를 값으로 취급한다” 입니다. 그래서 함수를변수에 저장하거나 함수를 다른 함수의 인자로 넘기거나 함수의 리턴값으로 함수를 활용할 수 있는 것이지요.그래서 다음의 JavaScript코드는 정상적으로 동작합니다.const PersonFactory = {    getInstance: function(construct,name,age) {        return new construct(name,age);    }};class Person {    constructor(name, age) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();위의 코드에서 Person 생성자를 PersonFactory.getInstance 함수의 인자로 넘겨서사용했습니다. JavaScript에서는 문제없이 잘 동작합니다. 하지만 이 코드를 그대로TypeScript에서 작성하면 코드에러가 발생합니다.일단 타입지정부터 엉망이니 좀 수정해서 보면 TypeScript코드는 다음과 같게 됩니다.const PersonFactory = {    getInstance: function(construct:any,name:string,age:number) {        return new construct(name,age);    }};class Person {    myName: string;    myAge: number;    constructor(name:string, age:number) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();데이터 타입을 적절하게 지정해서 일단 코드 오류는 제거했습니다. 그런데 문제가 하나 있습니다.const PersonFactory = {    getInstance: function(construct:any,name:string,age:number) {        return new construct(name,age);    }};위의 코드에서 생성자를 인자로 받아올 때 타입을 어떻게 지정해야 할지 몰라 일단 모든 타입에 대응되는any로 설정했습니다. any로 설정하면 문제없지만 우리는 any를 사용하지 않습니다. 좀 심하게 표현하자면 any를사용할꺼면 굳이 TypeScript를 할 필요가 없습니다. 여하간 이 any를 없애고 정확한 타입을 명시하려 합니다. 그런데 어떤 타입을 써야하나요? any대신 만만한 Function을 이용해 보면 다음과 같은 오류를 보실 수 있습니다.Cannot use 'new' with an expression whose type lacks a call or construct signatureconstruct signature 없이 new를 사용할 수 없답니다. 그럼 이 construct signature를 어떻게 만들어야 할까요?저 위에서는 index signature라는 걸 interface를 이용해서 선언하고 사용했습니다. 기억하시죠? 이와 비슷합니다.interface를 이용해 생성자의 signature를 지정해 줄 수 있습니다. 다음과 같이 사용합니다.interface IPersonConstructor {    new (n:string, a:number): Person;}const PersonFactory = {    getInstance: function(construct:IPersonConstructor,                          name:string,                          age:number) {        return new construct(name,age);    }};class Person {    myName: string;    myAge: number;    constructor(name:string, age:number) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();이렇게 사용하는 interface를 constructor interface 라고 표현하기도 합니다. 중요한 것은interface로 constructor의 타입을 지정해 줄 수 있다는 것이고 construct signature라는 표현으로interface내에 정의해서 사용합니다. interface의 확장하나의 interface는 다른 interface로 부터 상속받아서 확장될 수 있습니다. Java와 유사합니다. 다음의 코드로이해하시면 됩니다.interface Shape {    color: string;}interface Square extends Shape {    sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;let square = &lt;Square&gt;{}; 에서 &lt;Square&gt; 부분이 어떤것인지 기억하시나요? 그렇습니다. Type assertions이죠.위의 코드는 크게 어렵지 않을 듯 보입니다. 하지만 Java와 다른점이 있습니다. 동시에 여러 interface로 부터 상속을받을 수 있다는 것이죠. 하지만 여기서 상속이라는 표현은 맞지 않습니다. 상속은 객체지향 언어에서 나오는 특성입니다.여기서는 단지 interface의 확장일 뿐입니다.interface Shape {    color: string;}interface PenStroke {    penWidth: number;}interface Square extends Shape, PenStroke {    sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0;interface는 type check를 위해 사용되기 때문에 interface로는 객체를 생성할 수 없습니다.일단 이 정도만 알아두어도 될 듯 보입니다. 내용이 생각보다 많은데 생각보다 많이 어렵지는 않습니다. 단지 헷갈릴 뿐이죠 ^^여러번 정독하면서 쓰임새를 알아두고 실제 코드에서 활용하면서 익히셔야 합니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-interface"
    }
    ,
    
    "javascript-babel": {
        "title": "Babel을 사용해보자",
            "author": "javascript",
            "category": "",
            "content": "Introduction아무 생각없이 Babel을 쓰고 있지만 예전부터 궁금했던 Babel이란 이름이 내가 알고 있는 그 바벨탑의 바벨인가? 라는 의문에 이름의 근원을 찾아보고 이왕 찾아본 김에 Babel의 간단한 사용법 정도만 정리해 보도록 하겠습니다.( 도데체 이런게 왜 궁금한건대? ) Babel이란 이름의 기원결론적으로 Babel Official HomePage 에서는 이름에 대한 근원을 찾을수는 없었습니다. 어딘가에 숨어있는지는 모르겠지만요. 여하간 Babel은 성경 영어로 구약성서 창세기에 그 근원을 두고 있습니다.( 왠지 산으로 가는 느낌입니다. )노아의 홍수 이후로 인간은 다시 번성하기 시작했고 그 당시에는 전 세계의 언어가 하나였다고 합니다. 하나님은 인간들에게흩어져 살 것을 명하셨지만, 사람들은 하나님의 말씀에 불순종하여 Shinar 라는 곳에 모여 살았답니다. 그리고 그들은자신들을 위해 하나의 도시를 건설하고 하늘에까지 닿는 높은 탑도 같이 세워 자신들의 이름을 높이고 흩어지지 않겠다는 의미로하나의 높은 탑을 건설하게 되었는데 이게 그 Babel(바벨탑)이랍니다.하지만 인간들의 그러한 동기를 아시는 하나님께서 그들이 탑을 세우지 못하고 전 세계로 흩어지게끔 그들의 언어를 여러개로나누셔서 서로간의 의사소통이 되지 않도록 하셨답니다. 서로 말이 통하지 않자 탑 공사는 중단되고 결국 언어가 맞는 사람끼리 뿔뿔히흩어져 살게되었다라는 이야기지요.그래서 Babel의 사전적 의미는 “와글와글”, “바벨탑”, “거대한 탑” 의 의미를 가지게 되었다고 합니다. Babel의 목적Babel은 JavaScript transpiler입니다. 공식 홈에는 compiler라고 표현했지만 사실 compiler보다는 transpiler라는 용어가더 맞지 않나 싶습니다. 여하간 Babel의 입력은 JavaScript이고 출력 역시 JavaScript입니다.잘 알다시피 ES5 표준은 2009년도에 표준화되었습니다. 그리고 한동안 변경이 없다가 2015년에 ES6가 표준화가 됩니다.현재 시점은 ES7 이 최신표준이지만 아직까지 ES6가 대세라고 볼 수 있습니다. 이 ES6에 들어와서는 여러가지 획기적인변화가 생기게 되었습니다.변화된 내용 중 대표적인 것들은 다음과 같습니다.  class  arrow function  template string  generator  destructuring  let &amp; const문제는 이런 최신의 문법들로 쓰여진 JavaScript 코드를 런타임 환경인 browser가 인식하고 실행할 수 있는냐는 것입니다. browser는 최신 ECMAScript 문법을 다 지원하지 못하거든요. 특히 구형 browser나 IE같은 경우는 그 정도가 심합니다.하지만 생산성과 유지보수성등의 이유로 코드자체는 ECMAScript 최신버전으로 구현하는게 당연히 좋습니다. 즉, 구현과 실행환경과의 버전차이가 생기게 됩니다. Babel은  ECMAScript 6,7 으로 작성된 코드를 browser가 인식할 수 잇는 문법(ES5)으로변환시켜주는 transpiler입니다.한가지 주의해야 할 점은 Babel을 사용한다고 해서 모든 최신의 JavaScript함수를 다 사용할 수 있는건 아닙니다. Babel은문법만 변환시켜 주는 역할만 할 뿐입니다. 따라서 프로그램이 처음에 시작될 때 browser에서 지원하지 않는 함수를 검사해 처리해주는작업이 이루어져야 하고 이 부분은 babel-ployfill이 runtime에 담당하게 됩니다. ( 이 기능을 사용하기 위해서는 추가적인 설정이 필요합니다. ) Babel의 사용자 그럼 실제 사용하는 예를 알아보도록 하겠습니다.Babel역시 다른 node module과 마찬가지로 npm으로 설치하면 됩니다.npm install --save-dev babel-cli babel-preset-es2015package.json에 다음과 같이 npm script 작성{  ...  ...  \"scripts\": {    \"build\": \"babel babelTest.js -d lib\",    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"  },  ...  ...}ES6로 다음과 같은 코드 작성하고 babelTest.js로 저장합니다.let [a,,b] = [1,2,3];let myName = \"홍길동\";console.log(`Hello ${myName}`);class Student {    constructor(sName) {        this.sName = sName;    }}let stu = new Student(\"Moon\");console.log(stu.sName);다음과 같이 .babelrc 파일을 작성합니다.{  \"presets\": [    \"es2015\"  ]}다음과 같이 npm script를 실행시켜 lib폴더에 생성된 컴파일된 결과 파일을 확인합니다.npm run build결과로 생성된 ES5 파일의 내용\"use strict\";function _classCallCheck(instance, Constructor) {     if (!(instance instanceof Constructor)) {         throw new TypeError(\"Cannot call a class as a function\");     } }var _ref = [1, 2, 3],    a = _ref[0],    b = _ref[2];var myName = \"홍길동\";console.log(\"Hello \" + myName);var Student = function Student(sName) {    _classCallCheck(this, Student);    this.sName = sName;};var stu = new Student(\"Moon\");console.log(stu.sName);여기서는 Babel이 어떤 역할을 하고 어떻게 사용하는 것인지에 대해서 간단하게 알아보았습니다.이 포스트의 내용은 Babel Official Home Page을 참조했습니다.조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!End.",
        "url": "/javascript-babel"
    }
    ,
    
    "javascript-use-strict": {
        "title": "JavaScript의 strict mode란 무엇인가?",
            "author": "javascript",
            "category": "",
            "content": "Introduction\"use strict\"는 ES5에서 새롭게 나온 directive입니다. 실제 수행 문장이 아니라 literal expression이기 때문에 이전 버전의 JavaScript에서는 무시됩니다.일반적으로 JavaScript 코드 최 상단에 이 “use strict”가 위치하는데 이 의미에 대해서 간단하게 정리해 봤습니다. “use strict”를 써야하는 이유“use strict”의 목적은 우리의 코드가 strict mode로 실행되게끔 지시하는 것입니다. 여기서 말하는 strict mode란 프로그램 실행 시 예외를 발생시킬 만한 몇가지 특이한 동작을 수행할 수 없도록 엄격한 제한이 걸려있는 실행 context를 지칭합니다. 즉, 일반적으로 동작하는 코드를 “use strict”를 이용하면 에러가 발생할 수 있다는 말이지요.“use strict”는 함수별로 따로 지정할 수 있습니다. 즉, 함수내부에 “use strict”를 선언하면해당 함수는 strict mode로 실행되게 됩니다.몇가지 예를 들어보죠.\"use strict\";x = 100;        // x가 선언되지 않았기 때문에 error 발생console.log(x);x = 3.14;       // strict mode가 아니기 때문에 에러 아님.function myFunction() {    \"use strict\";    y = 3.14;   // y가 선언되지 않았기 때문에 에러 발생}myFunction();\"use strict\";var x = 3.14;delete x;   // strict mode에서는 delete를 사용할 수 없다.   \"use strict\";var public = 1500;   // strict mode에서는 키워드로 변수명을 쓸수 없다.그 외의 예로는 함수의 매개변수의 리스트에서 중복된 부분이 있을 때 오류를 발생시키고 동일한 라이브러리를 중복해서로딩하는 경우 에러를 발생시킵니다. (예를 들면, jQuery library 중복로딩 )결론적으로 잠재적인 오류가 발생할 수 있는 여지를 막아주도록 코드에 대한 문법 사항을 엄걱하게 지키도록 하는directive정도로 인식하시면 될 듯 합니다.  결론은 고민하지 말고 무조건 써야된다!! 입니다. ^^이 포스트의 내용은 w3schools.com을 참조했습니다.조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!End.",
        "url": "/javascript-use-strict"
    }
    ,
    
    "typescript-destructuring": {
        "title": "TypeScript 강좌(5) - Destructuring",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Destructuring이번 포스트의 내용은 Destructuring 입니다. Destructuring은 ECMAScript 2015 문법인데 TypeScript에서도 지원합니다.  아래의 예제를 정상적으로 실행해보실려면 tsconfig.json에서 compilerOptions의 target 속성을es6로 해 주셔야 합니다.일반적으로 Destructuring Assignment(비구조할당)라고 하는데 쉽게 말하자면 배열의 요소나 객체의 속성을 배열 literal 혹은 객체 literal과 유사한 형태의 문법을 이용하여변수에 할당하는 기법입니다. 잘 알아두면 코드를 좀 더 쉽게 작성할 수 있습니다. Array Destructuring다음과 같이 배열이 있을 경우 각 배열의 원소값을 가지는 변수를 만들려고 합니다. 아마도 코드는 다음처럼 써야 할 듯 보입니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let first: string = myArr[0];let second: string = myArr[1];let third: string = myArr[2];console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력console.log(third);     // \"Moon\" 출력이 코드를 Destructuring Assignment(비구조할당)를 이용하면 다음과 같이 표현할 수 있습니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let [first, second, third] = myArr;console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력console.log(third);     // \"Moon\" 출력위의 코드에서 [first, second, third] 형태를 Destructuring Array(비구조배열)이라고 합니다.즉, let [first, second, third] 구문은 변수 선언과 동시에 Destructuring Array(비구조배열)을 생성한 것입니다.만약 Destructuring Array(비구조배열)에 data type을 지정하고 싶은경우는 다음과 같이 하시면 됩니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let [first, second, third]: string[] = myArr;간단한 응용을 보도록 하죠. 두개의 변수에 대한 swap처리입니다. 기본적으로는 임시변수가 있어야 두 변수의 값을 swap처리할 수 있지만 Destructuring Assignment를 이용하면 보다 간단하게 할 수 있습니다.let myArr: string[] = [\"Hello\", \"World\"];let [first, second] = myArr;console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력[second, first] = [first, second];   // swap 처리console.log(first);     // \"World\" 출력console.log(second);    // \"Hello\" 출력이런 방식은 함수에 parameter를 전달할 때도 사용할 수 있습니다.function myFunc([x, y]: [number, number]): void {    console.log(`x의 값은 ${x}`);    console.log(`y의 값은 ${y}`);}myFunc([10,20]);나머지 몇몇 응용에 대해서 알아보겟습니다. ...을 이용하면 다음과 같은 형태로 서브배열을생성할 수 있습니다.let myArr: number[] = [1, 2, 3, 4];let [first, ...others] = myArr;console.log(first);    // 1 출력console.log(others);   // [2, 3, 4] 출력 ( 서브배열 )다음과 같은 형태로 Destructuring Array를 이용할 수 있습니다.let myArr: number[] = [1, 2, 3, 4];let [first] = myArr;let [,second, ,fourth] = myArr;console.log(first);     // 1 출력console.log(second);    // 2 출력console.log(fourth);    // 4 출력 Object Destructuring이번에는 객체를 비구조할당을 통해 이용해 보도록 하겠습니다.let obj = {    key1 : \"Hello World\",    key2 : 100,    key3 : \"TypeScript\"};let { key1:a, key2:b } = obj;console.log(a);    // Hello World 출력console.log(b);    // 100 출력새로운 변수 a와 b가 생성되고 obj.key1의 값의 key1:a에 의해서 a 변수에 대입됩니다.마찬가지로 obj.key2의 값이 key2:b에 매칭되서 b 변수에 값이 할당되는 것이구요. obj.key3는 당연히 무시됩니다.변수를 선언할 때 [ ]가 아닌 { }를 이용한다는 것에 주의하셔야 합니다.만약 객체의 Key( 위의 예제에서는 key1, key2, key3 )가 비구조 객체에 쓰이는 변수의 이름과 동일하다면간소화된 형태로 이용할 수 있습니다. 아래의 예처럼 말이죠.let obj = {    key1 : \"Hello World\",    key2 : 100,    key3 : \"TypeScript\"};let { key1, key2 } = obj;console.log(key1);    // Hello World 출력console.log(key2);    // 100 출력그러면 다음과 같이 표현할 수 도 있겠네요.let { a, b } = { a: \"Hello World\", b: 100 };console.log(a);    // Hello World 출력console.log(b);    // 100 출력조금 헷갈리긴 하지만 익숙해지면 할 만 합니다. ^^;아까 위에서 나왔던 ...을 기억하시나요? 배열의 나머지를 가지고 서브배열을 생성할 때 사용했었습니다. Object Destructuring에서도 ...을 이용할 수 있습니다. 아래의 코드를 살펴보도록 하죠.let obj = {    myName: \"홍길동\",    myAddress: \"서울\",    myAge: 30};let { myName, ...otherInfo} = obj;console.log(`이름은 : ${myName}`);console.log(`나이는 : ${otherInfo.myAge}`);객체의 property의 이름을 다른 것으로 바꿀 수 있습니다. 아래의 코드를 보시죠let obj = {    a: \"홍길동\",    b: \"서울\",    c: 30};let { a:myName, b:myAddress } = obj;console.log(`이름은 : ${myName}`);     // 홍길동 출력console.log(`주소는 : ${myAddress}`);  // 서울 출력위의 코드에서 주의해야 할 점은 a:myName, b:myAddress에서 :의 의미가 data type을 지정하는 것으로 사용된 것이 아니라는 것입니다. 만약 데이터 타입을 지정해서 사용하려면 다음과 같이 사용하셔야 합니다.let obj = {    a: \"홍길동\",    b: \"서울\",    c: 30};let { a:myName, b:myAddress }: {a:string, b:string} = obj;console.log(`이름은 : ${myName}`);     // 홍길동 출력console.log(`주소는 : ${myAddress}`);  // 서울 출력점점 복잡해 지는군요. 한가지 주의해야 할 점은 ECMAScript 2015(ES6)에서의 Destructuring과 TypeScript의Destructuring이 완벽하게 똑같지는 않다는 것입니다.이번에 살펴볼 것은 default 값입니다. Destructuring하려는 속성이 존재하지 않을 때를 대비해서 default값을지정할 수 있습니다. 아래의 예를 보시죠.let obj: {myName:string, myAge?:number} = {    myName : \"홍길동\",};let { myName:uNmae, myAge:uAge = 30 } = obj;console.log(uNmae);  // 홍길동console.log(uAge);   // 30위의 예에서 myAge?:number 부분의 ?의 의미는 해당 property가 있을 수도 있고 없을 수도 있다는것을 의미합니다.myAge:uAge = 30 부분이 default value를 사용한 부분입니다. 어디에 쓰면 좋을까요?간단하게 Destructuring이 무엇인지를 살펴보았는데 그럼 도데체 이걸 어디에 써 먹어야 할까요?이런식의 응용이 가능하구나 하는 정도로 가볍게 보시면 될 듯 합니다.첫번째로 생각할 수 있는 응용은 ECMAScript 2015에서 제공되는 Iteration Protocol과의 연계사용입니다.아주 쉽게 생각하면 Map사용에 응용할 수 있다 정도로 보시면 됩니다. Map 자료구조는 key와 value의 쌍으로데이터를 저장하는 구조이고 다음과 같은 형태로 Destructuring과 함께 이용할 수 있습니다.let map = new Map();map.set(\"myName\",\"홍길동\");map.set(\"myAddress\",\"서울\");map.set(\"myAge\",30);for(let [key, value] of map) {    console.log(`${key} 의 값은 ${value} 입니다.`);}for(let [key] of map ) {    // 모든 key 값만을 출력할 수 있습니다.    console.log(`${key}`);}for(let [,value] of map ) {    // 모든 value 값만을 출력할 수 있습니다.    console.log(`${value}`);}두번째는 함수의 리턴값에 응용하는 것입니다. 리턴값이 두개 이상 필요할 때 우리는 배열형태나 객체형태로 리턴을 받게 되는데 Destructuring을 이용하면 편합니다.다음은 배열을 리턴받는 경우입니다.function myFunc(): string[] {    let arr: string[] = [];    // 로직처리 ...    arr[0] = \"첫번째 결과값\";    arr[1] = \"두번째 결과값\";    return arr;}let [result1, result2] = myFunc();console.log(result1);console.log(result2);다음은 객체를 리턴받는 경우입니다.function myFunc(): {result1:string, result2?:number} {    let obj = {        result1 : \"\",        result2 : 0    };    // 로직처리 ...    obj.result1 = \"첫번째 결과값\";    obj.result2 = 100;    return obj;}let {result1:first, result2:second} = myFunc();console.log(first);console.log(second);꼭 사용해야 할 필요는 없지만 알아두면 편하고 좋은 Destructuring에 대해서 알아보았습니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-destructuring"
    }
    ,
    
    "typescript-variable": {
        "title": "TypeScript 강좌(4) - 변수 선언",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Variable Declarations이번 포스트에서는 var, let, const에 대해서 알아보겠습니다. let은 var과 유사하지만 var이가지고 있는 우리에게 익숙치 않은 몇가지 사항들을 피하도록 도와줍니다. const는 이름에서 의미하다시피 변수에재할당을 금지하는 목적으로 사용하는 것이구요.결론을 미리 말하자면 TypeScript는 let과 const를 이용합니다.먼저 var에 대해서 알아보고 그 다음에 let, const에 대해서 알아보도록 하겠습니다. var코드로 설명하자면 다음과 같이 변수를 선언할 수 있습니다.var myVar = 100;당연한 말이지만 함수내에서도 선언할 수 있습니다.function myFunc() {    var message = \"Hello World\";    return message}JavaScript는 함수안에 다른 함수를 선언할 수 있습니다. 그러한 경우 내부 함수가 외부 함수가 가지고 있는변수를 참조할 수 있습니다. 또한 JavaScript는 1급 함수(first-class function)를 지원합니다. 쉽게 말하면JavaScript의 함수는 값의 의미로 사용될 수 있다는 것입니다. 함수가 값의 역할을 하다보니 다음과 같은 형태의코드가 가능합니다.  함수를 변수에 저장.  함수를 다른 함수의 인자로 전달.  함수를 다른 함수의 리턴값으로 사용.위와 같은 형태의 함수를 이용할 때는 함수의 이름이 특별히 필요하지 않기 때문에 이런 함수는 특별히 이름을 명시하지 않고 사용합니다.이런 함수를 우리는 익명함수( Anonymous function )라고 하죠. 다른 표현으로는 람다( Lambda )라고도 합니다.( 사실 Lambda에 대한 내용은 조금 더 파고 들어야 합니다. 나중에 다른 포스트에서 정리해볼께요 )위의 내용으로 간단한 예를 들자면 아래와 같습니다.function outerFunc() {    var a = 100;    return function() {        var b = a + 100;        return b;    }}var myFunc = outerFunc();console.log(myFunc());    // 200 출력사실 위의 예제는 좀 이상합니다. 아니 많이 이상하죠.다음과 같은var myFunc = outerFunc();코드에서 outerFunc()함수는 수행이 종료되었기때문에 그 안에 선언된 변수 a는 사실 사용할 수 없어야 합니다. 우리가 익히 알고 있는 다른 프로그래밍 언어의 변수 scope 개념으로 본다면 말이죠.하지만 JavaScript의 var 변수 scope는 좀 다릅니다. outerFunc() 함수의 호출이 끝났음에도 불구하고 a 변수값이 유지됩니다. 즉, outerFunc()에 대한 참조가 남아있는 한 메모리에 계속 유지하게 되는 구조입니다.( outerFunc() 함수가 실행중인 상태로 간주한다는 의미이기도 합니다. ) 그렇기 때문에 위에서 myFunc()를 호출했을 때 a 변수를 이용할 수 있는 것입니다.조금 다른 예제를 살펴보겠습니다.function myFunc(init) {    if (init) {        var x = 10;    }    return x;}console.log(myFunc(true));  // 10 출력위의 코드는 JavaScript 코드입니다. var 변수는 if block 안에서 선언되었음에도 불구하고 block 외부에서도 사용이 가능합니다. 위에서 언급했듯이 JavaScript의 var 변수 scope가 좀 독특해서 그렇습니다. var로 선언된 변수는 block에 상관없이 function 내에서 사용이 가능합니다.  이런 특성을 var은 function-scoping을 가진다 라고 표현합니다.var에 대해서 마지막 하나만 더 살펴보고 정리하겠습니다.다음과 같은 setTimeout을 이용한 코드가 있을 때 실행결과가 어떻게 출력될까요?for (var i = 0; i &lt; 10; i++) {    setTimeout(        function() { console.log(i); },        1000    );}   결과는 다음과 같이 출력됩니다.10101010101010101010JavaScript를 알고 있는 사람들에게는 꽤나 익숙한 코드형태이자 결과일겁니다. setTimeout은 두번째 인자로 들어가는시간을 delay로 첫번째 인자의 함수를 호출해 주는 역할을 하는 함수입니다. (내부 Thread로 동작하겠죠)for문은 순식간에 수행될 것이고 1초뒤에 다음 코드가function() { console.log(i); }10번 호출되게 됩니다. 이 때 i변수는상위 for문의 scope를 참조하게 되므로 실제 console.log(i)가 수행될 때 i값을 참조하면 10이라는 값을 가지고 있을테니화면에 10이 10번 출력되게 됩니다.그러면 0부터 9까지 순차적으로 출력하려면 어떻게 해야 할까요? 이 작업을 수행하기 위해 IIFE을 이용합니다.  IIFE는 Immediately Invoked Function Expression을 의미합니다.코드를 아래와 같이 수정합니다.for (var i = 0; i &lt; 10; i++) {    (function(tmp) {        setTimeout(            function() { console.log(tmp); },            1000        );    })(i);}즉시 실행되는 함수 표현법(IIFE)를 이용하여 새로운 function scope를 생성해서 i값을 capture하는 방식으로 처리하면 될 듯 합니다.이 부분을 정확히 이해하기 위해서는 free variable, scope chain, Closure에 대한 이해가 있어야 합니다. 너무 이야기가산으로 가니 이 부분은 JavaScript 관련 포스트에서 따로 정리해 보도록 하겠습니다. let위에서 언급한 var의 모호성을 let을 이용해 해결할 수 있습니다. 변수를 선언할 때 단순히 var대신 let을 이용하면됩니다.let myVar: string = \"Hello World!!\";let은 우리에게 친숙한 block-scoping을 가집니다. ( lexical-scoping 이라고도 합니다. )function myFunc(input: boolean) {        let a = 100;    if (input) {        let b = a + 1;   // a에 접근이 가능합니다.        return b;    }    return b;            // 코드 에러( b에 접근할 수 없습니다. )}let의 또 다른 특징은 변수의 중복 선언이 안된다는 것입니다. 사실 프로그래밍 언어에서는 거의 당연시 여겨지는 것이지만var는 중복선언이 가능합니다. 다음과 같이 말이죠.function f() {        var x;    var x;          // JavaScript의 var은 같은 변수를 중복선언할 수 있습니다.         if (true) {        var x;    }}자 그럼 아까 var로 선언했을 때 이상하게 동작했던 setTimeout을 이번에는 let을 이용해서처리하면 어떻게 될까요?for (let i = 0; i &lt; 10; i++) {    setTimeout(        function() { console.log(i); },        1000    );}  0123456789var로 선언했을 때와 다른 결과를 볼 수 있습니다.  결론적으로 let은 우리가 익히 알던 (다른 언어의) 변수 특징을 가지는 변수를 선언하기 위한 keyword라고 생각하시면 됩니다. const변수를 선언하기 위한 또 다른 방법은 const를 이용하는 것입니다. 하지만 const로 선언된 변수에는재 할당(re-assign)이 불가능 합니다. 아래의 예처럼 말이죠.const myName: string = \"홍길동\";myName = \"강감찬\";   // 코드 에러const를 사용할 때 한가지만 주의하시면 됩니다. 만약 const 변수가 객체를 지칭하게 되면 다른 객체로 reference를바꾸지는 못하지만 현재 reference하고 있는 객체의 속성에 대해서는 값을 변경할 수 있습니다.아래의 예처럼 말이죠.const count: number = 100;const myProfile = {    myName: \"홍길동\",    myAddress: \"서울\",    myCount: count};myProfile = {                  // 코드 에러 ( re-assign 안됨 )    myName: \"강감찬\",    myAddress: \"인천\",};                   myProfile.myName = \"강감찬\";   // 가능myProfile.myAddress = \"인천\";myProfile.myCount = 10;변수 선언에 대한 keyword에 대해서는 이정도 알아두시면 될 듯 보입니다. 다음 주제는 Destructuring(디스트럭쳐링)입니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-variable"
    }
    ,
    
    "typescript-datatype-2": {
        "title": "TypeScript 강좌(3) - Data Type(Part 2)",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Data Type  any  void  null &amp; undefined  never  type assertions이전 포스트에서 기본적인 data type을 알아보았으니 이번에는 조금 더 색다른 data type을 살펴보도록 하겠습니다. anyApplication을 작성하는 시점을 기준으로 할 때 어떤 변수의 data type을 결정할 수 없는 경우가 아주 간혹 있습니다.가장 쉬운 예로 3rd party library를 이용해 dynamic content를 로딩해 저장하는 변수를 생각하시면 됩니다.즉, 동적으로 로딩되는 데이터의 타입이 runtime에 결정되므로 컴파일 타임에 data type을 지정할 수 없는 경우입니다.(하지만 사실 우리는 대부분 데이터 타입을 정해놓고 구현을 진행하긴 합니다. ^^)이런 경우 “어떠한 data type도 될 수 있다”라는 의미로 any data type을 이용할 수 있습니다.data type에 구애받지 않고 쉽게 코드를 작성할 수 있도록 만들어주지만 위에서 언급한 특정 목적을 제외하고는당연히 사용하지 않는것이 좋습니다.아래의 코드를 살펴보죠.let myVar: any = 100;myVar = \"Hello World!!\"; // 가능myVar = true;            // 가능 배열의 data type으로 any를 이용하여 서로 다른 data type으로 배열을 이용하는게 가능해집니다.아래의 코드처럼 말이죠.let myArr: any[] = [100, \"Hello\", true]; void어디서 많이 본 것입니다. 일반적으로 void는 함수가 리턴값이 없을 때 함수의 리턴 type으로 이용합니다. 아래의 코드를 보시죠.function myFunc(name: string) : void {    console.log(`Hello, ${name}!!`);}myFunc(\"Moon\");일반 변수를 만약 void로 선언하면 어떻게 될까요? 변수를 void type으로 선언하면 해당 변수에는 null 혹은 undefined만 assign이 가능합니다. 이렇게 사용할 일이 과연 있을까 싶네요.let myVar: void;myVar = 100;       // 불가능(코드 에러)myVar = \"Hello\";   // 불가능(코드 에러)myVar = null;      // 가능myVar = undefined; // 가능  여기서 주의해야 할 점은 tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": false option을설정해야 한다는 것입니다. null &amp; undefinedTypeScript에서 null과 undefined는 값이자 하나의 data type입니다. 그렇기 때문에 다음과 같이 사용해야 합니다.let myNull: null = null;let myUndefined: undefined = undefined;하지만 null과 undefined는 다른 모든 type의 subtype입니다. 쉽게 말하면 다른 모든 type에 null과 undefined 값을 assign할 수 있다는 말입니다.여기서 주의해야 할 점은 만약 --strictNullChecks flag를 이용해 .ts파일을 컴파일 할 경우 null과 undefined는 void 혹은자신의 data type에만 assign될 수 있게됩니다.(tsconfig.json파일안에서 \"strictNullChecks\": true로 설정한 경우를 의미 )  tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": false option 적용한 경우let myName: string = \"홍길동\";let myVoid: void;let myNull: null;let myUndefined: undefined;myName = null;            // 가능myName = undefined;       // 가능myVoid = null;            // 가능myVoid = undefined;       // 가능myNull = null;            // 가능myNull = undefined;       // 가능myUndefined = null;       // 가능myUndefined = undefined;  // 가능  tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": true option 적용한 경우let myName: string = \"홍길동\";let myVoid: void;let myNull: null;let myUndefined: undefined;myName = null;            // 불가능myName = undefined;       // 불가능myVoid = null;            // 불가능myVoid = undefined;       // 가능myNull = null;            // 가능myNull = undefined;       // 불가능myUndefined = null;       // 불가능myUndefined = undefined;  // 가능 nevernever type은 일반적으로 함수의 리턴 타입으로 사용됩니다. 만약 함수의 리턴 type으로 never가 사용되면 해당함수는 항상 exception을 발생시키던가 혹은 절대 return되지 않는다는 것을 의미합니다. 절대 return되지 않는다는것은 무한 loop에 빠지는 것등을 의미합니다.코드상으로 이해하자면 다음과 같은 경우입니다.function error(message: string): never {    throw new Error(message);}error(\"Something Wrong!!\");function infiniteLoop(): never {    while (true) {            }} Type assertionsType assertions는 컴파일러에게 “이 타입 사용이 맞아!!”라는 의미를 전달하는 것입니다. Type assertions은 type casting과 같은 의미로 사용되지만 실제 특별한 체크작업이나 데이터 재구조화 작업이 발생하지 않습니다.TypeScript는 프로그래머가 특정한 type check를 진행했다고 가정한 후 컴파일을 진행합니다.( TypeScript가 따로 검증하지 않는다는 거죠. )Type assertions을 하는 방법은 2가지가 있습니다. angle-bracket syntax(&lt;&gt;)를 이용하는 방법과 as syntax를이용하는 방법입니다. 아래의 코드를 보죠.let myVar: any = \"Hello World\";let myVarCount: number = (&lt;string&gt;myVar).length;myVarCount = (myVar as string).length;console.log((&lt;number&gt;myVar).toFixed());  // runtime errorany data type과 함께 사용되는 경우가 많으며 데이터 타입을 한정지어서 사용할 수 있도록 도와주는 역할을 합니다.여기까지가 TypeScript의 기본 data type입니다. 다음 포스트는 변수를 선언하기 위한 키워드인 var, let, const에 대해서 알아보도록 하겠습니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-datatype-2"
    }
    ,
    
    "typescript-datatype-1": {
        "title": "TypeScript 강좌(2) - Data Type(Part 1)",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Data Type  boolean  number  string  Array  Tuple  enum프로그래밍 언어를 배울 때 가장 먼저 학습하는 부분이 바로 Data Type입니다. 이전에도 언급했듯이TypeScript는 JavaScript의 superset이기 때문에 JavaScript의 data type을 그대로 이용합니다. 거기에추가적인 데이터 타입이 더 존재합니다.그럼 하나하나 예를 들면서 보도록 하죠. boolean우리가 알고있는 boolean type입니다. true와 false keyword를 사용할 수 있습니다.TypeScript에서는 변수선언시 var을 사용하지 않습니다. var는 전통적으로 javascript의 변수를 선언하기 위한 keyword로 사용되고 있지만몇가지 우리를 힘들게 하는 특징이 있습니다. 이부분은 나중에 다시 포스팅하기로 하겠습니다.여하간 TypeScript에서는 var대신 const와 let을 이용합니다. 다음과 같이 boolean type의 변수를 선언할수 있습니다.let myVar: boolean = false;WebStorm에서는 다음그림처럼 확인하시면 편합니다. 왼쪽창에는 .ts파일, 오른쪽 창에는 변환된 .js파일을열어서 .ts가 어떻게 .js로 변환되는지를 확인해보세요.JavaScript에는 생성자 함수라는게 있습니다. 원래 JavaScript는 객체지향언어가 아닙니다. Prototype기반의 함수형 언어입니다.그래서 JavaScript 초기버전에는 class가 도입되지 않았습니다. class는 ECMAScript 2015(ES6)에 도입되었습니다. class가 도입되기 이전에는 함수를 이용해서 객체를 생성하는 생성자 함수라는걸 사용했습니다. 지금도 역시 사용하고 있구요. 우리가 알고있는 new Date(); 이런게 다 생성자 함수를 이용한 객체의 생성입니다.그 중 특수한 생성자 함수들이 있습니다. 바로 primitive type에 대한 생성자 함수들 입니다. 이런것들을 우리는 흔히 Wrapper라고 부릅니다. JavaScript에도 Wrapper Object가 존재합니다. Boolean과 같은 생성자 함수를 이용해서 object를 만들면 우리는 그걸 primitive wrapper object라고 하는거지요.let myVar: boolean = false;let myBooleanVar: Boolean = new Boolean(true);   이제 아래의 코드를 살펴보죠.let myVar: boolean = false;let myBooleanVar: Boolean = new Boolean(true);console.log(myVar.valueOf());console.log(myBooleanVar.valueOf());위와 같은 코드는 좀 이상합니다. myVar는 primitive type임에도 불구하고 method를 호출했습니다.그럼에도 이상없이 실행이 잘 됩니다. 그 이유는 자동형변환이 일어나기 때문입니다. autoboxing이라고 하죠.let myVar: boolean = new Boolean(true);    // 코드 에러console.log(myVar.valueOf());위의 코드는 에러입니다. boolean type의 변수에 Boolean wrapper object를 assign할 수 없다는 오류가 발생합니다.혼용해서 사용하는건 좋지 않습니다. JavaScript할 때야 그냥 막(?) 했지만 TypeScript는 data type을 정확히 명시하는습관을 들이셔야 합니다.  결론적으로 booelan / Boolean 이 존재하는군요. 하나는 primitive data type이고 다른 하나는 primitive wrapper object를만들기 위한 생성자 함수입니다. data type 용도로 사용할 경우는 boolean을 이용하셔야 합니다.(나머지 data type에 대해서도동일합니다. - 권장사항) numberTypeScript는 정수와 실수를 구분하지 않습니다. 모두 다 실수( floating point values )입니다. data type으로는number를 사용합니다. 대응되는 wrapper 생성자 함수는 Number가 되겠네요.기본적인 10진수, 16진수에 더해 ECMAScript 2015에서 2진수, 8진수의 사용도 추가되었습니다.let decimal: number = 6;     let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;console.log(octal.valueOf()); string문자열을 지칭합니다. 기본적으로 double quotes (\") 와 single quotes (') 둘 다 이용할 수 있습니다. 일반적으로는single quotes (')를 이용합니다. 대응되는 wrapper 생성자 함수는 String 입니다.한가지 더 기억해야 할 것이 있는데 template string이라는 걸 사용할 수 있습니다. backquote ( ` ) 를 이용하여여러줄에 걸쳐 문자열을 입력할 수 있고 ${ expr } 형태로 embedded expression을 사용할 수 있습니다.let myStr: string = \"Hello\";let myNumber: number = 100;let myTemplateString = `this isasampleText =&gt; ${ myNumber + 100 }myStr : ${ myStr }`;console.log(myTemplateString);실행결과는 다음과 같습니다.this isasampleText =&gt; 200myStr : Hello ArrayTypeScript는 JavaScript와 마찬가지로 Array를 지원합니다. 배열은 primitive data type이 아닌 객체입니다.배열은 두가지 방식으로 사용할 수 있습니다. 일반적인 방식은 다음과 같습니다.let myArr: string[] = [\"Hello\", \"Hi\", \"안녕하세요\"];console.log(myArr);또 다른 방식은 Array Interface와 generic을 이용하는 방법입니다. 자세한 설명은 다른 포스트에서 진행합니다. 여기서는 어떻게 배열을 선언하고 사용하는지만 보시면 됩니다.let myNumArr: Array&lt;number&gt; = [1, 2, 3, 4];console.log(myNumArr); TupleTuple은 배열입니다. 특수한 형태의 배열로 인식하시면 됩니다. 배열의 각 원소에 대해 각기 다른 data type을 허용합니다.다음과 같은 코드를 가지고 이해해보죠let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능myTuple = [\"Hello\", \"World\"]; // 에러위의 코드의 제일 마지막 문장인myTuple = [\"Hello\", \"World\"];코드는 Tuple의 type선언에 맞지 않기때문에 Error가 발생합니다.다음의 코드를 살펴보죠let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능console.log(myTuple[0]);  // \"Hello\" 출력console.log(myTuple[1]);  // 100 출력console.log(myTuple[2]);  // undefined 출력위에서 언급했듯이 배열로 사용합니다. 2칸짜리 배열을 만들고 첫번째 칸에는 string, 두번째 칸에는 number를 data type으로가지는 배열입니다.JavaScript의 배열은 크기를 동적으로 늘릴 수 있습니다. 3번째 칸( myTuple[2] )에 데이터를 입력해 보겠습니다.let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능myTuple[2] = \"World\"; // 가능myTuple[2] = 200;     // 가능myTuple[2] = true;    // 불가능( 코드 에러 )3번째 칸에 string과 number는 assign이 되는것을 확인할 수 있습니다. 하지만 boolean은 들어가지 않는군요.정리하자면 현재 사용할 수 있는 index를 넘어가는 곳에 데이터를 입력할 때는 Tuple선언에서 사용한 data type의union type을 이용합니다. 쉽게 말하면 string 혹은 number가 되어야 한다는 말입니다. enumenum을 이용할 수 있습니다. C#의 enum과 동일합니다. 숫자 대신 친숙한 이름으로 설정하기 위해서 이용합니다.다음의 코드를 이용해서 살펴보죠enum Color { Red, Green, Blue }let myColor: Color = Color.Red;console.log(myColor);   // 0 출력별다른 설명이 필요없습니다. 이번에는 다음의 코드를 보죠enum Color { Red = 1, Green, Blue = 4 }let myColor: Color = Color.Green;console.log(myColor);   // 2 출력myColor = Color.Blue;console.log(myColor);   // 4 출력Color.Red의 값을 1로 설정하면 그 다음 원소들은 당연히 1부터 1씩 증가합니다. Color.Blue는 4로 명시적으로 지정했네요.아래의 예제는 좀 특이합니다. string 변수에 enum을 대입한 후 결과를 출력합니다.enum Color { Red = 1, Green, Blue }let myColorStr: string = Color.Green;  // 코드 에러( 문자열에 숫자대입 안됨 )let myColor: string = Color[3];        // 가능( 배열로 처리 - index에 주의 )console.log(myColor);                  // \"Blue\" 출력위의 코드에서let myColorStr: string = Color.Green;코드는 에러가 발생합니다. 문자열 type에 숫자를 넣으려 했기 때문이죠.또한 enum은 배열형태로 사용이 가능한 데 이런 경우 해당 문자열을 바로 이용할 수 있습니다.여기까지는 아마 우리가 알고있던 JavaScript와 거의 동일하니 이해하는데 어려움은 없을 듯 보입니다.나머지 data type은 다음 포스트에서 이어가도록 하죠.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-datatype-1"
    }
    ,
    
    "typescript-introduction": {
        "title": "TypeScript 강좌(1) - Introduction",
            "author": "typescript",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript 개요 및 WebStorm 개발환경 설정TypeScript는 Microsoft에서 개발하여 2012년에 발표한 오픈 소스 프로그래밍 언어입니다. 대규모 JavaScript application 개발을 목적으로 만들어졌습니다.TypeScript의 특징은 다음과 같습니다.  TypeScript는 JavaScript의 Superset입니다. TypeScript는 JavaScript의 모든 기능을 포함하고 그 외 추가적인 기능들을 가지고 있습니다.  TypeScript는 컴파일 언어이지만 컴파일 결과가 machine code가 아닌 JavaScript 코드가 나옵니다.( 이런 프로그래밍을 메타프로그래밍 이라고 하죠. ) 그렇기 때문에 compile 대신에 transpile 이라고도 합니다.  TypeScript는 compile 시점에 type checking이 일어나는 정적 타입 언어입니다. TypeScript 개발환경 설정여기서는 Node.js를 이용하여 npm(Node Package Manager)을 설치하고 이 npm을 이용해 TypeScript를 설치하고 사용하는 방법에 대해서 알아보겠습니다.먼저 Node.js사이트에 접속해 LTS 버전이나 최신버전 둘 중 하나를 선택해다운로드 합니다. (어떤것을 설치해도 상관없습니다.)저는 LTS 버전으로 다운로드 했습니다. 다운로드가 끝나면 기본 형태로 설치를 진행합니다. 설치가 끝나면C:/Program Files/nodejs 폴더가 만들어지게 됩니다.이제 command 창을 열어서 다음과 같이 명령어를 실행해봅니다.  npmnpm(Node Package Manager)이 정상적으로 동작하면 이제 npm을 이용해 typescript를 설치할 수 있습니다.설치는 local mode와 global mode로 설치가 가능합니다. 여기서는 편의상 global mode로 설치합니다.(일반적으로는 local mode를 선호합니다.)command 창에서 다음과 같이 명령어를 이용해 typescript를 global로 설치합니다.  npm install -g typescripttypescript 2.6.2가 설치되었습니다.  global mode로 설치하면 windows 시스템을 기준으로 $USER_HOME/AppData/Roaming/npm/node_modules에 설치됩니다.이제 사용할 IDE(Integrated Development Environment)를 설치합니다. 여기서는 WebStorm(유료)을 이용합니다.Visual Studio Code(무료)를 사용하셔도 됩니다. WebStorm은 유료이지만 30일 trial을 사용할 수 있고 Student license로1년간 무료로 사용할 수 도 있습니다.JetBrains사이트로 접속한 후 WebStorm을 다운로드 받습니다.다운로드가 완료되면 기본형태로 설치합니다. 설치가 끝나면 프로젝트를 생성할 수 있는 화면이 나오게 되는데 폴더 하나를 생성해서 프로젝트를 생성합니다. (폴더명이 프로젝트명이됩니다.) 저는 D:/TypeScriptTestApp 폴더를 생성하면서 프로젝트를 하나 만들었습니다.이제 WebStorm 설정을 해야 합니다.  Files - Settings - Languages &amp; Frameworks - TypeScript 를 선택하면 아래와 같은 화면을 볼 수 있습니다.사실 WebStorm에 TypeScript가 bundle되어 들어있기 때문에 TypeScript를 따로 설치 안해도 됩니다. 하지만 어떻게 설치하는지는 알아둘 필요는 있으니 한번 설치해 본거죠. 그리고 아래의 그림처럼 Compiler 옵션부분을check합니다.컴파일을 할 때 tsconfig.json을 참조해 compile option을 설정한다고 해 놓았습니다. 우리는 아직 tsconfig.json이 없으니 하나 생성해 줍니다. WebStorm의 하단에 있는 Terminal을 클릭해서 Terminal창을 열고 다음을 입력합니다.  tsc --init프로젝트를 살펴보면 tsconfig.json이 생성되어 있는것을 볼 수 있고 안에 무언가가 많이 들어있는것을 확인할 수 있습니다.compiler option에 대해서는 다른 포스트에서 알아보기로 하고 이제 간단한 ts 파일(typescript file)을 하나 생성합니다.이름을 hello.ts라고 하죠.다음과 같은 코드를 입력합니다.class Greeting {    greeting: string;    constructor(message: string) {        this.greeting = message;    }    sayHello() {        return \"Hello \" + this.greeting;    }}let tmp = new Greeting(\"World!!\");console.log(tmp.sayHello());내가 알고있던 javascript가 아니라서 당황스럽지요? 별로 어렵지 않습니다. 객체지향 언어를 알고 있으면더욱 더 쉽게 접근할 수 있습니다. 여하간 이렇게 코딩을 하고 저장하면 자동적으로 컴파일을 진행하고 그 결과파일(.js)을 생성해 줍니다.마지막으로 coding convention을 지정할 수 있는 tslint를 설치하도록 하겠습니다. 반드시 설치해야하는건 아니지만발생할 수 있는 오류를 미리 감지하고 coding convention을 맞추기 위해서 사용하는 것이 일반적입니다.WebStorm에서 다시 터미널을 열고 다음과 같이 입력하여 tslint를 설치합니다. 역시 global mode로 설치합니다.  npm install -g tslint그리고 다시 설정으로 들어갑니다.  Files - Settings - Languages &amp; Frameworks - TypeScript - TSLint 를 선택하면 아래와 같은 화면을 볼 수 있습니다.Enable를 check합니다. tslint.json을 찾아서 Cofiguration file로 이용한다는 군요.tslint.json 파일이 있어야 하니 Terminal을 열어서 다음과 같이 입력해서 tslint.json도 생성해 줍니다.  tslint --init이제 우리가 작성한 hello.ts 파일을 다시 열어보면 여러가지 알수없는(?) 빨간색들이 산재해 있는것을 보실 수 있습니다.에러는 아니지만 tslint에 의해서 coding convention에 위배되는 것들입니다.적절하게 수정해야 합니다. 설정해야 하는 것이들 많이 있지만 연습삼아 한가지만 설정하겠습니다. console에 대한 tslint 오류를 없애보도록 하죠.수정한 tslint.json파일은 다음과 같습니다.{    \"defaultSeverity\": \"error\",    \"extends\": [        \"tslint:recommended\"    ],    \"jsRules\": {},    \"rules\": {        \"no-console\": false    },    \"rulesDirectory\": []}오류를 수정한 최종 hello.ts파일은 다음과 같습니다.class Greeting {    private greeting: string;    constructor(message: string) {        this.greeting = message;    }    public sayHello() {        return \"Hello \" + this.greeting;    }}let tmp = new Greeting(\"World!!\");console.log(tmp.sayHello());여기까지해서 TypeScript를 학습하기 위한 기본적인 환경설정을 잡으시면 됩니다.  tslint는 실 개발시에는 필요하지만 처음 TypeScript를 공부할 때는 끄고 하시는게 정신건강에 이로울 수 있습니다.사실 쓸데없는 coding convention도 많거든요.End.",
        "url": "/typescript-introduction"
    }
    ,
    
    "what-is-metaprogramming": {
        "title": "What is Meta Programming?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introduction특정 형태의 코드를 작성한 후 컴파일하면 그 코드가 의미하는 다른언어의 코드( Java나 C++ )가 생성되는 프로그래밍을 지칭합니다. 메타프로그래밍 이란?메타프로그래밍( template metaprogramming )이라고 불리는 프로그래밍 기법은 template을 기반으로 compiler에게 다른 언어의 프로그램 코드를 생성하도록 하는 방식을 지칭합니다. 결과물이 machine code가 아닌다른 프로그래밍언어로 전환되는 것이기 때문에 compiler라는 용어대신에 transpiler라는 표현을 쓰기도 합니다. 장점과 단점이런 Meta Programming은 다음과 같은 장점과 단점을 가지고 있습니다.Advantage  컴파일 타임에 최적화가 이루어지고 결과적으로 실행 시 수행속도가 빨라질 수 있습니다.  일반화 프로그래밍( Generic Programming )이 가능합니다. 프로그래머는 처리할 구조와 데이터에 집중하고 컴파일러에 의해 특정 언어로 변환이 되는 구조이기 때문입니다.  결과로 도출되는 언어가 갖지 못하는 여러가지 개념들을 template에 정의해서 작성하고 이를결과언어로 적절하게 표현하여 기능상의 확장을 손쉽게 가져올 수 있습니다.Disadvantage  일반적으로 Template Metaprogramming은 또 다른 형식으로 프로그래밍 하기 때문에코드 자체가 더 난해합니다. 즉, Readability에 문제가 있습니다.  compiler에 의해서 새로운 코드가 생성되는 구조이기 때문에 compiler에 대한 의존도가 상당히 높습니다. 따라서 이식성의 문제가 발생할 여지를 가지고 있습니다.End.",
        "url": "/what-is-metaprogramming"
    }
    ,
    
    "what-is-yaml": {
        "title": "What is YAML?",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "IntroductionYAML은 JSON이나 XML처럼 데이터를 표현하는 하나의 양식입니다. 처음에는 좀 다른 의미였지만 현재는데이터를 표현하는 목적으로 사용됩니다. YAML 이란?YAML은 데이터를 사람이 쉽게 읽을 수 있는 형태로 표현하는데 사용되는 데이터 직렬화 양식입니다.데이터 직렬화(Data Serialization)란 구조화된 데이터를 특정 format으로 변환하는 개념입니다.단, 변환된 format은 본래 구조화된 데이터로 복구될 수 있어야 하고 변환된 format 형태로 공유 혹은 저장되는 것을 허용해야 합니다.YAML과 마찬가지로 우리가 자주 사용하는 XML이나 JSON 역시 데이터 직렬화 양식입니다.YAML 이라는 이름은 원래 Yet Another Markup Language(또 다른 마크업 언어)의 약어였으나 YAML의 실제 사용이마크업이 아닌 데이터 중심으로 사용되기 시작하자 YAML Ain’t Markup Language(YAML은 마크업 언어가 아니다)라는재귀적인 이름으로 변경되었습니다.우리나라 말로는 야믈 이라고 발음합니다.일반적으로 Ruby나 Python 개발자는 property파일로 많이 이용하고 있지만 C#이나 Java 개발자에게는 좀 생소합니다.Spring Boot도 현재 YAML을 지원하고 있습니다.일단 YAML은 property 형태로 어떻게 사용된다라는 식으로만 알고 있어도 충분할 듯 싶습니다. 혹시 나중에 YAML을본격적으로 사용하게 되는 날이 오면 그 때 조금 더 자세히 알아보도록 하겠습니다.(그런데 사실.. 그런날은 올거 같지 않습니다.)End.",
        "url": "/what_is_yaml"
    }
    ,
    
    "kramdown-image-resize": {
        "title": "GitHub Page에서 Image Resize 방법",
            "author": "fragmentary-knowledge",
            "category": "",
            "content": "Introductionkramdown에서 image를 표현할 때 resize하는 방법입니다.기본 markdown에서 이미지를 사용하는 방법은 다음과 같습니다.![이미지 텍스트](https://github.com/favicon.ico)GitHub Page는 현재 markdown engine으로 kramdown을 사용할 수 있습니다. kramdown에서는다음의 문법으로 이미지를 원하는 사이즈로 resizing 할 수 있습니다.![이미지 텍스트](https://github.com/favicon.ico){: height=\"100px\" width=\"100px\"}조금 더 일반화 시켜서 말하자면 {: height=\"100px\" width=\"100px\"} 부분은 Tag로 변환될 때 특정 속성을 붙이는 역할을 합니다. 만약 {: class=\"myStyle\" }이라고 했다면만들어지는 Tag에 class=\"myStyle\"이라는 속성이 붙게됩니다.End.",
        "url": "/kramdown-image-resize"
    }
    ,
    
    "jekyll-sitemap": {
        "title": "Jekyll 기반의 GitHub Page 생성(6)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Google Search Console 활용이번에는 우리의 GitHub Page를 Google 검색엔진에 노출시켜 작성한 글이 다른 사람에게 쉽게 노출되도록 처리해 보겠습니다. 이 작업을 하지 않으면 작성된 글이 웹에 노출될 확률이 현저하게 떨어집니다.Google이 제공하는 Google Search Console을 이용하여 내 GitHub Page의 domain을 등록시키고 sitemap.xml을생성해 Google Search Console에 제출하면 됩니다. sitemap.xml을 등록해 두면 Google 검색 크롤러가 주기적으로페이지를 크롤링하여 indexing하게 됩니다.그럼 간단히 시작해 보겠습니다.  먼저 D:/blogmaker 폴더 아래에 robots.txt 파일을 생성합니다.정확히 말하면 GitHub Page의 root밑에 robots.txt가 존재하면 됩니다.User-agent: *Allow: /Sitemap: https://moon9342.github.io/sitemap.xmlGitHub Page를 이용하기 때문에 모든 검색엔진을 다 설정했습니다. 만약 특정 위치가 크롤링이 되지 않게끔설정하려면 다음과 같이 처리하면 됩니다.User-agent: *Allow: /User-agent: *Disallow: /privateData/Sitemap: https://moon9342.github.io/sitemap.xmlrobots.txt에 대한 조금 더 자세한 설명을 보실려면 여기를 클릭하세요.그런다음 sitemap.xml을 작성해야 합니다. sitemap.xml 역시 GitHub Page의 root밑에 존재해야 하며추후에 Google Search Console에 제출해야 합니다.  D:/blogmaker 폴더 아래에 sitemap.xml 파일을 생성합니다.다음과 같은 형태로 작성합니다.---layout: null---&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd&quot;        xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;    {% for post in site.posts %}    &lt;url&gt;        &lt;loc&gt;{{ site.url }}{{ post.url }}.html&lt;/loc&gt;        {% if post.lastmod == null %}        &lt;lastmod&gt;{{ post.date | date_to_xmlschema }}&lt;/lastmod&gt;        {% else %}        &lt;lastmod&gt;{{ post.lastmod | date_to_xmlschema }}&lt;/lastmod&gt;        {% endif %}        {% if post.sitemap.changefreq == null %}        &lt;changefreq&gt;weekly&lt;/changefreq&gt;        {% else %}        &lt;changefreq&gt;{{ post.sitemap.changefreq }}&lt;/changefreq&gt;        {% endif %}        {% if post.sitemap.priority == null %}        &lt;priority&gt;0.5&lt;/priority&gt;        {% else %}        &lt;priority&gt;{{ post.sitemap.priority }}&lt;/priority&gt;        {% endif %}    &lt;/url&gt;    {% endfor %}&lt;/urlset&gt;작성이 끝났으면 이제 Google Search Console에 접속합니다. 아래 처럼 자신의 Github page url을 입력합니다.정상적으로 등록되면 아래와 같은 화면을 보실 수 있습니다.왼쪽 메뉴의 크롤링 - Sitemaps를 선택해 sitemap.xml을 추가합니다. 먼저 테스트를 진행한 다음 이상이 없으면 sitemap.xml 파일을 추가합니다. 정상적으로 처리되면 다음과 같은 화면을 보실 수 있습니다.  추후에 site:moon9342.github.io을 브라우져 주소창에 넣고 접속하면 현재 indexing이 어떻게 되어 있나를 확인할 수 있습니다.End.",
        "url": "/jekyll-sitemap"
    }
    ,
    
    "jekyll-search": {
        "title": "Jekyll 기반의 GitHub Page 생성(5)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 lunr.js를 이용한 Search 기능 추가Jekyll은 정적 사이트 generator이기 때문에 검색 기능이 따로 없습니다. 여러가지 방법을 동원해서 만들 수 있긴 하지만 최종적으로 2가지 방법이 적당할 듯 보입니다.하나는 Google Custom Search를 이용하여 블로그내 검색 기능을 추가하는 것입니다. 쉽고 편하게 검색 기능을 붙이수는 있으나 다음과 같은 단점이 있습니다.  광고가 뜬다 ( 참을 수 있습니다. )  style을 조절하기가 쉽지 않다. ( 참기 힘듭니다. 안 예뻐요! )Google Custom Search는 일단 제외하고 조금 찾아보니 lunr.js를 이용하면 검색 기능을 어렵지 않게 붙일 수 있을 듯 보였습니다. lunr.js는 client side full-text search engine입니다. 검색 기능을 붙이는 방식은 아래의두 사이트를 참고 하였습니다.  Jekyll search using lunr.js  한글 검색 패치Jasper2 theme가 가지고 있는 subscribe 화면을 수정해서 search 기능을 구현해 보겠습니다.Jasper2 theme는 subscribe 기능을 위한 링크를 가지고 있습니다.해당 링크를 누르면 다음과 같은 그림을 볼 수 있습니다.흠.. 새로운 포스트가 등록될 때마다 메일로 전송해주는 것이군요. 당연히 외부 기능을 제공받아야 사용할 수 있습니다.Jasper2 theme는 말 그대로 theme입니다. 모양만 제공해 주는것이지요.저는 이 화면을 검색 화면으로 대체해서 사용했습니다.먼저 _includes/site-nav.html파일을 열어 블로그 안에서 표현되는 Subscribe라는 글자를 Search로 변경합니다.&lt;div class=\"site-nav-right\"&gt;        &lt;div class=\"social-links\"&gt;            {% if site.facebook %}                &lt;a class=\"social-link social-link-fb\"                    href=\"https://facebook.com/{{ site.facebook }}\"                    target=\"_blank\"                    rel=\"noopener\"&gt;{% include facebook.html %}&lt;/a&gt;            {% endif %}            {% if site.twitter %}                &lt;a class=\"social-link social-link-tw\"                    href=\"https://twitter.com/{{ site.twitter }}\"                    target=\"_blank\"                    rel=\"noopener\"&gt;{% include twitter.html %}&lt;/a&gt;            {% endif %}        &lt;/div&gt;        {% if site.subscribers %}            &lt;a class=\"subscribe-button\" href=\"#subscribe\"&gt;Search&lt;/a&gt;        {% endif %}    &lt;/div&gt;맨 아래쪽&lt;a class=\"subscribe-button\" href=\"#subscribe\"&gt;Search&lt;/a&gt;라고 보이는 부분을 수정했습니다.(단순히 Subscribe라는 글자를 Search로 변경했습니다.)그 다음은 화면을 검색 페이지에 맞게 수정하는 것입니다._layouts/default.html을 열어서 검색 화면으로 수정합니다.{% if site.subscribers %}        &lt;div id=\"subscribe\" class=\"subscribe-overlay\"&gt;            &lt;a class=\"subscribe-overlay-close\" href=\"#\"&gt;&lt;/a&gt;            &lt;div class=\"subscribe-overlay-content\"&gt;                {% if site.logo %}                    &lt;img class=\"subscribe-overlay-logo\"                          src=\"{{ site.baseurl }}{{ site.logo }}\"                          alt=\"{{ site.title }}\" /&gt;                {% endif %}                &lt;h1 class=\"subscribe-overlay-title\"&gt;Search {{ site.title }}&lt;/h1&gt;                &lt;p class=\"subscribe-overlay-description\"&gt;                lunr.js를 이용한 posts 검색 &lt;/p&gt;                {% include subscribe-form.html placeholder=\"keyword\" %}            &lt;/div&gt;        &lt;/div&gt;{% endif %}그 다음으로 _includes/subscribe-form.html을 열어서 수정했습니다.코드는 아래와 같습니다.&lt;span id=\"searchform\" method=\"post\" action=\"/subscribe/\" class=\"\"&gt;    &lt;input class=\"confirm\" type=\"hidden\" name=\"confirm\"  /&gt;    &lt;input class=\"location\" type=\"hidden\" name=\"location\"  /&gt;    &lt;input class=\"referrer\" type=\"hidden\" name=\"referrer\"  /&gt;    &lt;div class=\"form-group\"&gt;        &lt;input class=\"subscribe-email\" onkeyup=\"myFunc()\"                id=\"searchtext\" type=\"text\" name=\"searchtext\"                 placeholder=\"Search...\" /&gt;    &lt;/div&gt;    &lt;script type=\"text/javascript\"&gt;        function myFunc() {            if(event.keyCode == 13) {                var url = encodeURIComponent($(\"#searchtext\").val());                location.href = \"/search.html?query=\" + url;            }        }    &lt;/script&gt;&lt;/span&gt;기존 코드를 수정한것이기 때문에 불필요한 코드도 좀 들어가 있습니다. 중요한 내용은입력상자에서 검색어를 입력하고 enter를 누르면 search.html페이지로 이동하면서검색 결과가 search.html에 출력된다는 정도입니다.이제 검색 결과가 표현될 D:/blogmaker/search.html을 생성해서 다음과 같은 코드를 삽입합니다.---layout: pagecurrent: searchtitle: Search Resultnavigation: truelogo:class: page-templatesubclass: &#39;post page&#39;---&lt;form action=&quot;/search&quot; method=&quot;get&quot; hidden=&quot;hidden&quot;&gt;    &lt;label for=&quot;search-box&quot;&gt;&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;search-box&quot; name=&quot;query&quot;&gt;&lt;/form&gt;&lt;ul class=&quot;mylist&quot; id=&quot;search-results&quot;&gt;&lt;/ul&gt;&lt;script&gt;    window.store = {    {% for post in site.posts %}    &quot;{{ post.url | slugify }}&quot;: {        &quot;title&quot;: &quot;{{ post.title | xml_escape }}&quot;,            &quot;author&quot;: &quot;{{ post.author | xml_escape }}&quot;,            &quot;category&quot;: &quot;{{ post.category | xml_escape }}&quot;,            &quot;content&quot;: {{ post.content | strip_html | strip_newlines | jsonify }},        &quot;url&quot;: &quot;{{ post.url | xml_escape }}&quot;    }    {% unless forloop.last %},{% endunless %}    {% endfor %}    };&lt;/script&gt;&lt;script src=&quot;assets/js/lunr.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/search.js&quot;&gt;&lt;/script&gt;이제 마지막 단계만 남았습니다. 사용되는 lunr.js와 search.js를 assets/js 폴더 안에 복사해 주어야 합니다.lunr.js는 https://lunrjs.com/에서 받으실 수 있습니다. CDN을 이용하셔도 됩니다.search.js는 다음과 같은 코드로 작성합니다.(function() {    function displaySearchResults(results, store) {        var searchResults = document.getElementById(&#39;search-results&#39;);        if (results.length) { // Are there any results?            var appendString = &#39;&#39;;            for (var i = 0; i &lt; results.length; i++) {  // Iterate over the results                var item = store[results[i].ref];                appendString += &#39;&lt;li&gt;&lt;a href=&quot;&#39; + item.url + &#39;&quot;&gt;&lt;h6&gt;&#39; + item.title + &#39;&lt;/h6&gt;&lt;/a&gt;&#39;;                appendString += &#39;&lt;p&gt;&#39; + item.content.substring(0, 150) + &#39;...&lt;/p&gt;&lt;/li&gt;&#39;;            }            searchResults.innerHTML = appendString;        } else {            searchResults.innerHTML = &#39;&lt;li&gt;검색 결과가 없습니다.&lt;/li&gt;&#39;;        }    }    function getQueryVariable(variable) {        var query = window.location.search.substring(1);        var vars = query.split(&#39;&amp;&#39;);        for (var i = 0; i &lt; vars.length; i++) {            var pair = vars[i].split(&#39;=&#39;);            if (pair[0] === variable) {                return decodeURIComponent(pair[1].replace(/\\+/g, &#39;%20&#39;));            }        }    }    function trimmerEnKo(token) {        return token            .replace(/^[^\\w가-힣]+/, &#39;&#39;)            .replace(/[^\\w가-힣]+$/, &#39;&#39;);    };    var searchTerm = getQueryVariable(&#39;query&#39;);    if (searchTerm) {        document.getElementById(&#39;search-box&#39;).setAttribute(&quot;value&quot;, searchTerm);        // Initalize lunr with the fields it will be searching on. I&#39;ve given title        // a boost of 10 to indicate matches on this field are more important.        var idx = lunr(function () {            this.pipeline.reset();            this.pipeline.add(                trimmerEnKo,                lunr.stopWordFilter,                lunr.stemmer            );            this.field(&#39;id&#39;);            this.field(&#39;title&#39;, { boost: 10 });            this.field(&#39;author&#39;);            this.field(&#39;category&#39;);            this.field(&#39;content&#39;);        });        for (var key in window.store) { // Add the data to lunr            idx.add({                &#39;id&#39;: key,                &#39;title&#39;: window.store[key].title,                &#39;author&#39;: window.store[key].author,                &#39;category&#39;: window.store[key].category,                &#39;content&#39;: window.store[key].content            });            var results = idx.search(searchTerm); // Get lunr to perform a search            displaySearchResults(results, window.store); // We&#39;ll write this in the next section        }    }})();잘 동작하는지 한번 실행시켜보겠습니다.검색 결과 화면에 대한 css는 취향에 맞게 설정해 사용하면 됩니다.!!End.",
        "url": "/jekyll-search"
    }
    ,
    
    "jekyll-rouge": {
        "title": "Jekyll 기반의 GitHub Page 생성(4)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 rouge를 이용한 syntax highlightingrouge는 pure-ruby syntax highlighter입니다. 이를 이용하면 블로그에 코드를 붙여넣을 때 간단하게 syntax highlighting 기능을 이용할 수 있습니다.Jekyll은 syntax highlighting을 위해 Pygments도 지원했었는데 Jekyll 3(2016년 02월)부터 Pygments를지원하지 않습니다._config.yml 설정 파일에 다음과 같이 설정한 부분이 있습니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가......._config.yml에 설정은 잡아놨는데 실제 설치는 아직 안했습니다. gem을 이용하여 rouge를 설치합니다.command 창을 열어서 다음과 같이 입력합니다.  gem install rougerouge는 특정 style을 가진 css파일을 생성하기 위한 command-line tool을 가지고 있습니다. rougify명령을 이용하면 우리가 원하는 스타일의 css 파일을 생성할 수 있습니다.일단 다음의 명령어로 어떤 스타일을 사용할 수 있는지 확인합니다.  rougify help style아래 부분에 available themes가 보이는 군요. 여기에서 맘에 드는거 하나를 선택해서 style.css를 생성할 수 있습니다.제가 사용하고 있는 theme는 monokai.sublime 입니다.이제 다음과 같은 명령어로 원하는 theme로 css 파일을 생성합니다.  rougify style monokai.sublime &gt; assets/css/syntax.css자 이제 D:/blogmaker/assets/css/syntax.css 파일이 생성되었습니다. 이 css파일에 대한 링크를 post에서 사용할 수 있도록 _layouts/default.html에 추가해야 합니다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- Document Settings --&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;    &lt;!-- Base Meta --&gt;    ...    ...       &lt;!-- 웹 폰트 설정 --&gt;    &lt;link rel=\"stylesheet\"           href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;    &lt;!-- syntax.css --&gt;    &lt;link rel=\"stylesheet\" href=\"/assets/built/syntax.css\"&gt;새로운 css 파일이 생성되었으니 gulp를 이용해 css task를 실행시켜야 합니다. 그래야 minified된 css파일이생성이 되서 블로그에서 이용할 수 있을 테니까요.이제 준비가 끝났습니다. 포스트에서 글 작성할 때 다음과 같은 code block을 이용하게 됩니다.code block에 대해 사용하는 언어를 명시해 주면 그에 맞춰 문법 강조를 하게 됩니다. ~~~javascriptfunction syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}~~~위의 코드에 대한 결과입니다.function syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}End.",
        "url": "/jekyll-rouge"
    }
    ,
    
    "jekyll-font": {
        "title": "Jekyll 기반의 GitHub Page 생성(3)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 웹 폰트 설정블로그를 운영할 때 가장 신경써야 하는 부분 중 하나는 readability입니다. Jasper2는 영문일 경우 상당히 가독성이 좋은데한글을 사용하니 폰트때문에 가독성이 확 떨어지더군요. 그래서 폰트를 좀 바꾸어봤습니다.당연한 말이지만 이 부분은 “이게 정답이다” 라는게 아닙니다.  전 이렇게 바꾸었어요~ 하는 부분이지요.하지만 대부분의 Jekyll theme가 비슷한 구조를 가지고 있기 때문에 다른 theme를 사용하실 때 비슷하게 적용하실 수 있을듯 합니다.먼저 사용할 웹 폰트를 물색해야 합니다. 구글에서 찾아보면 원하시는 웹 폰트를 쉽게 찾을 수 있습니다.만만한 나눔고딕 폰트를 이용해 보겠습니다.&lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;나눔고딕 폰트에 대한 링크입니다.이제 _layout/default.html 파일을 열어서 해당 폰트 링크를 넣어줍니다. 다음과 비슷하게 되겠네요.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- Document Settings --&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;    &lt;!-- Base Meta --&gt;    ...    ...    &lt;!-- 웹 폰트 설정 --&gt;    &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;이제 css파일을 수정해서 특정 class에 대한 font-family에 나눔고딕 폰트를 추가해 주면 되겠네요.Jasper2에서 일반적인 포스트는 모두 .post-full-content css class의 영향을 받습니다.다른 theme를 이용하시는 분은 포스트들이 어떤 css class에 영향을 받는지를 확인하셔서 그 class를 찾아 수정하시면 됩니다.assets/css/screen.css 파일을 열어서 .post-full-content 부분을 찾아 다음과 같이 수정합니다.Georgia는 영문폰트이기 때문에 영문은 일단 이 폰트를 먼저 이용하게 되고 한글 부분은 Nanum Gothic을 사용하게 됩니다..post-full-content {    position: relative;    margin: 0 auto;    padding: 70px 100px 0;    min-height: 230px;    font-family: Georgia, 'Nanum Gothic', serif;    font-size: 2.2rem;    line-height: 1.6em;    background: #fff;}css가 변경되었으니 gulp를 이용하여 css task를 수행합니다. Jasper2 theme는 gulp에 대한 설정을 포함하고 있습니다. NPM(Node Package Manager)를 이용해gulp를 설치하고 gulpfile.js 파일을 이용해 css task를 수행하면 결과적으로 assets/built 폴더에 수정된 내용으로 minified된 css파일이 생성되게 됩니다.이제 다시 bundle exec jekyll serve을 수행하면 새로 만들어진 css를 이용하여 블로그가 생성될 것이고 한글로 쓴 내용의 폰트가 나눔고딕으로 변경되는 것을 볼 수 있습니다.End.",
        "url": "/jekyll-font"
    }
    ,
    
    "jekyll-struct": {
        "title": "Jekyll 기반의 GitHub Page 생성(2)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 Github Page Publishing이전 포스트에서 로컬 서버를 실행시켜 Jasper2 theme를 이용한 블로그가 실행되는 것 까지 확인을 했습니다.Jasper2나 혹은 다른 theme를 사용하실 때도 이제부터가 문제입니다. 자신의 입맛에 맞도록 theme를 수정해야 하는데이게 쉬운일이 아닙니다. 개발쪽에 있으신 분들은 쉽게 접근하실 수 있지만 그렇지 않은 경우 상당히 난해합니다.“그냥 Tistory 쓰고말지” 라는 말이 나올정도로요.사실 GitHub Page에서 블로그를 운영하는 사람들 중 많은 사람이 Front-End 개발이 가능한 사람들 입니다.Jekyll은 정적 사이트 생성기 입니다. Liquid template을 기반으로 markdown형식의 텍스트파일을 HTML로 변환해주는 변환 도구라고 보시면 됩니다.이전 포스트에서 Jasper2 theme를 압축해제한 폴더를 기억하시나요? D:/blogmaker 였습니다. 이 폴더가 Jekyll Source Folder가 됩니다.이 Jekyll Source Folder 안의 _post라는 폴더에 우리가 작성하려는 글을 markdown 형식으로 작성합니다. 그런 후 bundle exec jekyll serve 명령을 이용하면 build시키면 저장된 글에 대해 컴파일이 진행되고 결과물이 destination 폴더에 생성됩니다.GitHub Page에 올려 사용하는 실제적인 블로그가 바로 이 destination 폴더 안에 있는 내용입니다. 따라서 Git을 이용하여 변환된 결과물(destination 폴더안의 내용)을 GitHub Page와 연동되는 GitHub Repository에 push해 주어야 합니다.그럼 천천히 진행해 보겠습니다.위에서 언급했듯이 D:/blogmaker가 우리의 Jekyll Source Folder입니다.설정된 대로 컴파일 과정을 거치면 destination 폴더에 결과물을 저장하게 됩니다. Jekyll은 설정파일로 YAML 파일을 이용합니다. YAML에 대한 설명은 YAML이란 링크에 간단히 정리되어 있습니다.이 설정에 대한 파일이 바로 _config.yml입니다. 블로그 생성에 대한 전체 환경 세팅을 담당하는 파일이라고 생각하시면 됩니다.  D:/blogmaker폴더안에서 _config.yml을 찾아 해당내용을 자신에 맞게 수정해서 사용해야 합니다.아래는 _config.yml에 대한 내용과 그 설명입니다. 주석이 달린 부분을 중심으로 보시면 됩니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 10# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Blog# 자신의 blog title.description: Development &amp; Technical Training# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: sunghoons-blog# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics:  # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]exclude: [vendor]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source: destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안으로 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.production_url:  https://moon9342.github.io/source_url:  https://github.com/moon9342/GitHubPageMaker/# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules는 포함시키자)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules위의 설정파일에 destination: ./output/으로 설정되어 있기 때문에 command 창에서 “bundle exec jekyll serve”명령을 수행하면 D:/blogmaker/output/ 폴더가 생성되고 여기에 컴파일된 결과파일들이 저장되게 됩니다.결과파일을 D:/blogmaker ( Jekyll Source Folder )밑의 output folder로 지정한 이유는 나중에 Travis-CI와연동하기 위해서 입니다. ( git submodule로 처리하기 위함입니다. )Travis-CI를 이용하지 않고 그냥 수동으로 결과파일을 자신의 GitHub Page에 올리려면 설정파일에 destination: ../[GitHubPage]/과 같은 형식으로 설정하시면 됩니다.설정 후 “bundle exec jekyll serve” 명령을 수행하면D:/[GitHubPage]/라는 폴더가 생성되고 여기에 컴파일된 결과파일들이 저장되게 됩니다.Jekyll build 작업을 할 때 한가지 주의해야 할 점이 있습니다.기본적으로 Jekyll build는 development 세팅으로 진행됩니다. 만약 실제 GitHub Page에 Publishing할목적으로 build하는 것이라면 JEKYLL_ENV 환경변수의 값을 production으로 설정한 후 build를 진행해야 합니다. (참고링크)  위의 작업을 하지 않으면 정상적으로 URL이 생성되지 않습니다. localhost로 세팅됩니다.Travis-CI에 대한 설정은 다른 포스트에서 살펴보기로 하고 여기서는 수동으로 결과 파일을 GitHub Repository (GitHub Page에 대한 Repository)에 올리는 것으로 설명합니다.( destination: ../[GitHubPage]/ 으로 설정되어 있다고 가정 )이제 D:/[GitHubPage]/파일안의 내용을 GitHub Page에 Publishing하시면 됩니다.  먼저 GitHub에 접속해서 새로운 Repository를 생성합니다. 주의할 점은Repository의 이름을 (자신의 github id).github.io로 지정해야 합니다.  Git을 이용하여 방금 만든 D:/[GitHubPage]/ 안의 내용을 Repository에 push합니다.정상적으로 push가 진행되었다면 이제 https://(자신의 github id).github.io로 접속해서 블로그가 잘 개설이 되었는지 확인합니다.이 포스트에서는 Git과 GitHub에 대한 기본적인 사용법에 대해서는 다루지 않습니다. 해당 부분은 저의 다른 포스트나혹은 여기를 이용하여 살펴보시면될 듯 합니다.GitHub Page에 블로그가 잘 개설되었나요? 블로그가 잘 개설되었다면 이제 메뉴를 원하는 형식으로 바꾸고 새로운 내용의 post도 작성해서 블로그에 올리시면 됩니다. _posts 폴더에 기존에 있는 .md file을 복사해서새로운 내용을 만들고 포스팅 작업을 해 보세요.End.",
        "url": "/jekyll-struct"
    }
    ,
    
    "jekyll-start": {
        "title": "Jekyll 기반의 GitHub Page 생성(1)",
            "author": "jekyll",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - Github Page Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기 환경설정Jekyll을 이용해 GitHub Page에 기본적인 블로그를 생성하는 방법은 여러 다른 블로그나 사이트에 자세하게 나와 있으니 저는 제가 사용하는 Jasper2 theme를 이용하여 GitHub Page에 블로그를 개설하고 사용하는 방법에 대해서 알아보겠습니다. (Windows 10환경으로 진행합니다.)  Windows 환경은 조금 까다롭습니다. Ruby 때문에 그렇습니다. 먼저 컴퓨터의 계정 ID가 한글로 되어 있으면 여러 문제가 발생합니다.한글계정이라면 먼저 계정부터 영문으로 바꾸고 시작해야 합니다.아래의 그림처럼 컴퓨터의 계정이 영문으로 되어있는지 확인합니다.제일 먼저 해야하는 작업은 Ruby를 설치하는 것입니다.Ruby는 RubyInstaller for Windows 에서 받으시면 됩니다.사용할 버전은 2.2.6입니다. 다른 버전 사용할 경우 문제가 발생할 여지가 있습니다. 파란색 박스로 되어 있는 링크를 눌러파일을 받으시면 됩니다.다운로드 받은 Ruby를 설치합니다.  아래 그림과 같이 기본 경로(C:/Ruby22-x64)에 PATH 환경변수 설정만 추가해서 설치합니다.Ruby 설치가 끝나면 DevKit을 설치해야 합니다. DevKit을 설치하지 않으면 Jekyll 설치할 때 Error가 발생합니다.Ruby의 DevKit은 마찬가지로 RubyInstaller for Windows 에서 받으시면 됩니다. 파란색 박스로 되어 있는 링크를 눌러 파일을 다운로드 합니다. ( 64bit기준 )다운로드받은 파일을 실행하고 압축이 풀릴 폴더를 지정합니다. C:/RubyDevKit으로 지정합니다. (다른 경로를 사용해도 무방합니다.)따로 설치파일이 존재하는게 아니기 때문에 command 창을 열어서 초기화 및 설치작업을 진행합니다.  ruby dk.rb init  ruby dk.rb install이제 bundler를 설치합니다. bundler는 Ruby application 개발을 위한 일관된 환경을 제공합니다. 단편적 기능 중 하나는Ruby application이 사용하는 gem의 dependency를 관리하는 것입니다. 우리는 나중에 이 bundler를 이용하여 Jekyll을사용할 것이기 때문에 설치해야 합니다.  gem install bundler기본적인 준비과정은 끝났습니다.그 다음 과정은 우리가 사용할 Theme인 Jasper2를 다운받아서 원하는 폴더에 압축을 풀어줍니다. D:/blogmaker에 다음과 같은 형태로 압축을 풀어 저장했습니다.  여기서 주의해야 할 점은 폴더 이름에 공백이 포함되어 있으면 나중에 css빌드할 때 문제가 발생합니다. 즉, D:/blogmaker처럼 폴더는 소문자로 공백없이 생성합니다.command 창을 열어서 해당 폴더(D:/blogmaker)에서 다음과 같이 실행합니다.  bundle exec jekyll serve먼가 수행될거라는 기대와는 달리 다음과 같은 에러가 발생합니다.  Could not find gem ‘jekyll (~&gt; 3.6.2) x64-mingw32’ in any of the gem sources listed in your Gemfile. Run bundle install to install missing gems.command 창에서 다음의 명령을 차례로 실행해 필요한 gem을 설치합니다.  gem cleanup  bundle install이제 다시 아래와 같은 명령을 이용하여 실행시킵니다.  bundle exec jekyll serveJekyll은 template처리를 위해 Liquid template 언어를 사용합니다. template 처리를 거쳐 결과 파일이특정 폴더에 저장되고 로컬 웹 서버가 실행되어서 서비스해 주기 때문에 로컬에서 블로그를 확인해 볼 수 있습니다.build 과정을 거쳐 로컬 웹서버를 이용하여 웹 서비스까지 실행시켜주는 명령이라고 생각하시면 됩니다.아래와 같은 메시지가 출력되면서 로컬 웹 서버가 4000번 포트로 기동되고 http://localhost:4000/jasper2로 접속하면 테마페이지를 보실 수 있습니다.  일단 로컬에서 화면을 띄웠습니다. 이제 각 메뉴를 원하는 내용으로 바꾸고 이미지를 내 입맛에 맞게 수정하고 기타 등등의 기능들을 추가하면 될 듯 보입니다.End.",
        "url": "/jekyll-start"
    }
    ,
    
    "javascript-history": {
        "title": "JavaScript History",
            "author": "javascript",
            "category": "",
            "content": "Introduction아마도 JavaScript, ECMAScript, TypeScript라는 용어를 많이 들어봤을 텐데 정확하게 어떤 차이가 있는지이번 포스트에서 간단하게 정리를 해 보겠습니다. JavaScript과거부터 Web 작업을 해 오신 분들은 아시겠지만 JavaScript의 과거 인식은 “알면 좋고 몰라도 상관없는 딱 그 수준의 언어” 였습니다. 하지만 개발 방법론이 진화하면서 JavaScript기반의 Library나 Framework의 필요성이 증대되고 그에 따라JavaScript라는 언어의 위상도 상당히 올라갔습니다. ( HTML5와 Node.js의 역할이 지대했지요. )JavaScript라는 언어의 전신은 1995년 Netscape사에서 Brendan Eich가 Mocha라는 이름으로 만들어낸 스크립트 언어입니다. 개발을 완료하고 후에 LiveScript라는 이름으로 세상에 공개되었습니다. 그런데 이 시점에 Netscape사가 Java를 개발한 Sun Microsystems사와 협업하면서 Java applet이 큰 인기를 끌게 되었는데 이를 상업적으로 이용하고자 이름을 LiveScript에서 JavaScript로 변경하게 된 것입니다.  이름의 변경 순서가 Mocha  LiveScript  JavaScript 가 되는군요.MS(Microsoft)에서는 이에 대응하기 위해 JScript를 만들고 IE 3부터 JScript를 포함시켜서 제공했지요. 당연한 말이지만JavaScript와 JScript는 서로 비슷하지만 특징이 다릅니다. 그로인해 우리가 잘 알고있는 JavaScript의 고질적인 문제인 Fragmentation(파편화 현상)이 발생하게 됩니다. ECMAScript여하간 Netscape사는 이 JavaScript의 표준을 잡기 위해 ECMA(정보 통신기술 표준화 기구)에 표준화 작업을 요청합니다. 당연히JavaScript라는 이름을 사용하려고 했지만 Sun과의 라이선스 문제 때문에 ECMAScript라는 이름으로 표준화가 진행되게 됩니다.이렇게만 놓고 보면 JavaScript와 ECMAScript가 비슷한 의미로 사용되는 것처럼 보이는데 사실 작은 차이가 있습니다.우리가 흔희 말하는 JavaScript는 1개의 Core와 2개의 Module로 구성되어 있습니다. 여기서 1개의 Core는 JavaScript를 구성하고 있는 Script language(ECMAScript)입니다. 2개의 Module은 BOM(Browser Object Model), DOM(Document Object Model)을 지칭합니다.달리 말하자면 ECMAScript는 JavaScript를 구성하는 Core Script언어로 웹 환경에서만 사용되는 언어가 아닙니다. 웹 환경은 ECMAScript가 사용되는 환경 중 하나일 뿐입니다.  JavaScript = ECMAScript + BOM + DOM현재 ECMAScript version은 7까지 나와있습니다. (ECMAScript 2016 = ES7)이렇듯 JavaScript와 ECMAScript는 정확한 의미의 차이는 분명히 있지만 그냥 저냥 대충 통용해서 사용합니다. 흔히 우리가JavaScript라고 표현하면 ECMAScript를 의미한다고 보시면 됩니다. TypeScript그러면 TypeScript는 또 어떤걸까요? 왜 TypeScript가 대세로 떠오른 걸까요?TypeScript는 Microsoft에서 개발하여 2012년에 발표한 오픈 소스 프로그래밍 언어입니다. JavaScript로 대규모 application개발을 하기 위해 개발되었고 컴파일 과정을 거치면 JavaScript가 되는 언어입니다.CoffeeScript 처럼 compile하면 JavaScript가 생성되는 변환 언어의 한 종류라 볼 수 있습니다. 그냥 JavaScript로 개발하면 되지 굳이 이런 변환언어를 사용하는 이유는 무엇일까요? ( 이런 프로그래밍을 메타프로그래밍 이라고 합니다. )가장 큰 이유는 기능의 추가에 있습니다.변환언어의 가장 큰 장점은 변환되는 언어에 기능을 쉽게 추가할 수 있다는 것인데 예를 들면, 추상 클래스, 인터페이스, 정적 데이터타입 사용, 엄격한 타입 체크등을 JavaScript에 추가하여 개발을 쉽게 끌고 갈 수 있습니다.즉, 전통적인 OOP방식으로 JavaScript개발을 진행할 수 있다는 것이죠.  기존 객체지향 언어(Java, C++, C#)를 알고 있고 JavaScript를 알고 있으면 TypeScript를 아주 쉽게배울 수 있습니다.TypeScript는 다른 변환언어와는 다르게 JavaScript의 superset입니다. 그렇기 때문에 이미 JavaScript를 알고 있으면쉽게 TypeScript를 사용할 수 있으며 ES6(ECMAScript 2015)나 ES7(ECMAScript 2016)에서 제공되는 기능 중 필요한 것만 골라서 이용할 수 있습니다. 아래의 그림은 TypeScript와 ECMAScript간의 포함관계를 보여줍니다.( 이미지 출처 : https://angular2buch.de )2017년 3월부로 TypeScript는 Google의 공식언어 중 하나로 채택되었습니다. MS에서 개발한 언어를 Google이표준언어로 채택하다니 놀랍습니다. 그만큼 TypeScript의 언어적 기능이 좋고 앞으로의 발전가능성이 많다는 의미겠지요.기존 Google의 사내 표준언어 (Canonical Language)는 C, C++, Java, JavaScript, Python, Go 정도였는데 Google은 이 중 JavaScript를 이용하여 AngularJS(1.x)를 개발했었습니다.하지만 AngualrJS(1.x)의 차기버전인 Angular(2.x)를 개발하면서 JavaScript의 기능상의 한계를 느끼게 되고결국 2014년에 Google에서 발표한 AtScript를 이용해 Angular(2.x)를 개발하게 됩니다.하지만 TypeScript가 Angular의 표준언어 중 하나로 채택이 되면서 기존의 AtScript로 작성했던 Angular 2를 몽땅 TypeScript로 전환했습니다. Google에서 말하기로는 변환이 아주 쉬웠다고 하더군요.이렇게 TypeScript의 위상이 올라가면서 기존 Google에서 JavaScript의 대체 언어로 밀고있었던 Dart의 위상 역시 살짝 하락한 상태입니다. (물론 Google은 아니라고 하지만요. )  Angular는 공식적으로 3개의 언어를 지원합니다. (TypeScript, JavaScript, Dart)   그런데 공식문서에서나 커뮤니티활동에서 가장 많이 사용되는것은 TypeScript입니다. 결국 Angular는 꼭 해야할 것 중 하나이니 TypeScript도 그냥 해야지요..머..End.",
        "url": "/javascript-history"
    }
    
    
    };

</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://moon9342.github.io/">IT Blog</a> &copy; 2018</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/">GitHub Pages</a></section>
                <nav class="site-footer-nav">
                    <a href="mailto:moon9342@gmail.com">moon9342@gmail.com</a>
                    <a href="/">Latest Posts</a>
                    
                    
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search IT Blog</h1>
                <p class="subscribe-overlay-description">lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"  placeholder="Search..." />
    </div>
    <!--<button class="" onclick="myFunc()" id="searchBtn" type="button" ><span>Search</span></button>-->
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
    <!--<script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>-->
</span>


            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113135179-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
